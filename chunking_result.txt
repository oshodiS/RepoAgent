Chunk 1
Title: Consolidated Summary of Project Descriptions  
Project Description:

Chunk 2
The documents provide detailed information on various projects related to data model classes, graph execution, web scraping workflows, language model integration, and logging configuration. The projects involve creating and managing classes like

Chunk 3
and managing classes like Dish, Project, Images, and Article for efficient data organization. GraphBuilder and ChromiumLoader classes are implemented for graph creation and web scraping tasks. Language model classes like Anthropic and AzureOpenAI

Chunk 4
Anthropic and AzureOpenAI are integrated for language processing. Telemetry data handling and logging configuration functions are detailed for system monitoring. Proxy server management and dynamic module import testing are also covered. Overall,

Chunk 5
are also covered. Overall, the documents offer a comprehensive guide on implementing and utilizing these functionalities effectively within software systems.

Chunk 6
ClassDef Dish  
Dish: The function of Dish is to define the attributes of a dish including its name and description.
attributes:
- name: str (The name of the dish)
- description: str (The description of the dish)

Chunk 7
Code Description: The Dish class is a subclass of BaseModel. It contains two attributes: name and description, both of type string. The 'name' attribute represents the name of the dish, while the 'description' attribute provides a description of the

Chunk 8
provides a description of the dish. This class serves as a blueprint for creating instances of dishes with specified attributes.

Chunk 9
Note: When using the Dish class, ensure that the 'name' and 'description' attributes are provided with appropriate string values to accurately represent the dish. Additionally, as Dish is a subclass of BaseModel, it inherits functionalities from the

Chunk 10
functionalities from the BaseModel class.

Chunk 11
Dishes: The function of Dishes is to define a list of Dish objects.
attributes:
- dishes: List[Dish] (A list of Dish objects)

Chunk 12
Code Description: The Dishes class is a subclass of BaseModel. It contains a single attribute 'dishes', which is a list of Dish objects. This class is used to create instances that hold a collection of Dish objects, allowing for the organization and

Chunk 13
for the organization and management of multiple dish instances within a single entity.

Chunk 14
Note: When utilizing the Dishes class, populate the 'dishes' attribute with a list of Dish objects to represent multiple dishes within a single entity. This structure facilitates the handling of multiple dish instances in a cohesive manner.

Chunk 15
ClassDef Dishes  
Dishes: The function of Dishes is to define a list of Dish objects.
attributes:
- dishes: List[Dish] (A list of Dish objects)

Chunk 16
Code Description: The Dishes class is a subclass of BaseModel. It contains a single attribute 'dishes', which is a list of Dish objects. This class is used to create instances that hold a collection of Dish objects, allowing for the organization and

Chunk 17
for the organization and management of multiple dish instances within a single entity.

Chunk 18
When utilizing the Dishes class, populate the 'dishes' attribute with a list of Dish objects to represent multiple dishes within a single entity. This structure facilitates the handling of multiple dish instances in a cohesive manner.

Chunk 19
ClassDef Project  
Project: The function of Project is to define a class representing a project with title and description attributes.  
attributes:
- title: str (description: "The title of the project")

Chunk 20
- description: str (description: "The description of the project")  
Code Description:

Chunk 21
The Project class is a subclass of BaseModel and defines a project entity with two attributes: title and description, both of which are strings. The title attribute represents the title of the project, while the description attribute holds the

Chunk 22
attribute holds the description of the project.

Chunk 23
In the context of the project structure, the Projects class, which contains a list of Project instances, can be seen as a collection of multiple projects. Each Project instance within the Projects class represents an individual project with a

Chunk 24
an individual project with a specific title and description.

Chunk 25
Note:
Developers can use the Project class to create instances of projects with defined title and description attributes. When working with the Projects class, they can manage multiple Project instances collectively within a list structure.

Chunk 26
ClassDef Projects  
Projects: The function of Projects is to define a class representing a collection of multiple projects.  
attributes:
- projects: List[Project]  
Code Description:

Chunk 27
The Projects class is a subclass of BaseModel and contains a single attribute named "projects," which is a list of Project instances. Each Project instance represents an individual project with a title and description attribute. The Projects class

Chunk 28
attribute. The Projects class serves as a container for managing multiple Project instances collectively.

Chunk 29
In the context of the project structure, the Projects class facilitates the organization and manipulation of multiple projects by storing them in a list structure. Developers can utilize the Projects class to handle and interact with a group of

Chunk 30
and interact with a group of Project instances efficiently.

Chunk 31
Note: Developers can create instances of the Projects class to work with multiple Project instances simultaneously, enabling them to manage various projects within a unified collection.

Chunk 32
ClassDef Dish  
Dish: The function of Dish is to represent a dish with its name and description.  
attributes:
- name: str (The name of the dish)
- description: str (The description of the dish)  
Code Description:

Chunk 33
The Dish class is a part of the BaseModel and contains two attributes: name and description, both of type string. This class is designed to store information about a dish, with the name attribute representing the name of the dish and the description

Chunk 34
the dish and the description attribute providing a brief description of the dish.

Chunk 35
The Dish class is utilized within the Dishes class, which is a BaseModel containing a list of Dish objects. In the Dishes class, the dishes attribute stores a list of Dish objects, allowing for the representation of multiple dishes within a single

Chunk 36
dishes within a single object.

Chunk 37
Note:

Chunk 38
Developers can use the Dish class to create instances representing individual dishes, providing a structured way to store and access information about different dishes. When working with the Dishes class, developers can access and manipulate lists

Chunk 39
access and manipulate lists of Dish objects, enabling the management of multiple dish entities within a single container.

Chunk 40
ClassDef Dishes  
Dishes: The function of Dishes is to store a list of Dish objects.  
attributes:
- dishes: List[Dish] (A list containing Dish objects)  
Code Description:

Chunk 41
The Dishes class is a part of the BaseModel and serves as a container for a list of Dish objects. The class has a single attribute, "dishes," which is a list that holds instances of the Dish class. This design allows for the representation and

Chunk 42
for the representation and management of multiple dish entities within a single Dishes object.

Chunk 43
The Dishes class relies on the Dish class, which defines the structure of individual dish objects by specifying attributes such as name and description. By utilizing the Dishes class, developers can organize and access collections of Dish objects

Chunk 44
collections of Dish objects efficiently, enabling the handling of various dish-related data in a structured manner.

Chunk 45
Note:

Chunk 46
Developers can leverage the Dishes class to work with groups of Dish objects, facilitating the organization and manipulation of multiple dish entities within their applications. The use of Dishes in conjunction with Dish provides a structured

Chunk 47
Dish provides a structured approach to managing and interacting with dish data, enhancing the overall efficiency and maintainability of the codebase.

Chunk 48
ClassDef Project  
Project: The function of Project is to define the structure of a project with attributes like title and description.  
attributes:
- title: str (The title of the project)
- description: str (The description of the project)

Chunk 49
Code Description:

Chunk 50
The Project class is a part of the smart_scraper_schema_azure.py module in the Azure project. It is a data model that inherits from the BaseModel class. The Project class has two attributes: title and description, both of which are strings. The

Chunk 51
of which are strings. The title attribute represents the title of the project, while the description attribute represents the description of the project.

Chunk 52
The Projects class, defined in the same module, contains a list of Project instances. This relationship indicates that the Projects class is a container for multiple Project instances, allowing for the organization of multiple projects within a

Chunk 53
of multiple projects within a single entity.

Chunk 54
Note:

Chunk 55
Developers can use the Project class to create instances representing individual projects within the Azure project. When working with the Projects class, developers can access and manipulate lists of Project instances, each containing specific

Chunk 56
each containing specific information about different projects.

Chunk 57
ClassDef Projects  
Projects: The function of Projects is to define a class that contains a list of Project instances.  
attributes:
- projects: List[Project] (A list of Project instances)  
Code Description:

Chunk 58
The Projects class is a part of the smart_scraper_schema_azure.py module in the Azure project. It is a data model that inherits from the BaseModel class. The Projects class has a single attribute named "projects," which is a list containing

Chunk 59
which is a list containing instances of the Project class. Each Project instance represents an individual project with attributes like title and description.

Chunk 60
The relationship between the Projects class and the Project class allows for the organization of multiple projects within a single entity. Developers can use the Projects class to manage and access lists of Project instances, each containing

Chunk 61
instances, each containing specific information about different projects.

Chunk 62
Note:
Developers can utilize the Projects class to work with collections of Project instances, enabling the handling of multiple projects efficiently within the Azure project.

Chunk 63
ClassDef Dish  
Dish: The function of Dish is to represent a dish with its name and description.  
attributes:
- name: str (description: "The name of the dish")
- description: str (description: "The description of the dish")  
Code Description:

Chunk 64
The Dish class is a part of the BaseModel and contains two attributes: name and description, both of type string. The 'name' attribute represents the name of the dish, while the 'description' attribute provides a description of the dish.

Chunk 65
The Dish class is designed to store information about a specific dish, making it easier to manage and access details related to different dishes within the application. It serves as a structured way to represent and work with dish data.

Chunk 66
In the project, the Dish class is utilized within the Dishes class. The Dishes class is a BaseModel that contains a list of Dish objects, allowing for the organization and management of multiple dish instances.  
Note:

Chunk 67
Developers can create instances of the Dish class to store information about individual dishes, such as their names and descriptions. When working with a collection of dishes, the Dishes class can be used to manage and interact with multiple Dish

Chunk 68
interact with multiple Dish objects efficiently.

Chunk 69
ClassDef Dishes  
Dishes: The function of Dishes is to store a list of Dish objects.  
attributes:
- dishes: List[Dish] - A list containing Dish objects.  
Code Description:

Chunk 70
The Dishes class is a part of the BaseModel and serves the purpose of managing multiple Dish objects. It contains a single attribute, 'dishes', which is a list that holds instances of the Dish class. This structure allows for the organization and

Chunk 71
for the organization and storage of various dish instances within the application.

Chunk 72
The Dishes class is designed to facilitate the handling of multiple dish objects efficiently. By utilizing a list of Dish instances, developers can work with collections of dishes in a structured manner, enabling easier access and management of

Chunk 73
access and management of dish-related data.

Chunk 74
In the project's context, the Dishes class utilizes the Dish class to represent individual dishes and aggregates them into a list. This relationship enables the Dishes class to provide a centralized way to work with and manipulate multiple dish

Chunk 75
and manipulate multiple dish entities within the application.

Chunk 76
Note:

Chunk 77
Developers can create instances of the Dishes class to manage and interact with collections of Dish objects effectively. By leveraging the Dishes class, developers can handle and organize various dish instances seamlessly, enhancing the overall

Chunk 78
enhancing the overall management of dish-related data in the application.

Chunk 79
ClassDef Project  
Project: The function of Project is to define a class representing a project with attributes for title and description.  
attributes:
- title: str (description: "The title of the project")

Chunk 80
- description: str (description: "The description of the project")  
Code Description:

Chunk 81
The Project class is a subclass of BaseModel and defines two attributes: title and description, both of type string. The title attribute represents the title of the project, while the description attribute holds the description of the project.

Chunk 82
In the calling object, Projects, which is a class that contains a list of Project instances, the Project class is used to define the structure of individual projects within the list. This allows for organizing multiple projects under the Projects

Chunk 83
projects under the Projects class.

Chunk 84
Note:
Developers can utilize the Project class to create instances representing individual projects with specific titles and descriptions. The attributes can be accessed and modified as needed to store and retrieve information about each project.

Chunk 85
ClassDef Projects  
Projects: The function of Projects is to define a class that contains a list of Project instances.  
attributes:
- projects: List[Project]  
Code Description:

Chunk 86
The Projects class is a subclass of BaseModel and consists of a single attribute named projects, which is a list of Project instances. Each Project instance represents an individual project with a title and description. By utilizing the Project

Chunk 87
By utilizing the Project class structure, multiple projects can be organized and managed within the Projects class.

Chunk 88
The Project class, which is a subclass of BaseModel, defines the structure of individual projects by specifying attributes for title and description. This allows developers to create instances representing unique projects with specific information.

Chunk 89
with specific information. The Projects class, in turn, aggregates these Project instances into a list, enabling the management of multiple projects as a cohesive unit.

Chunk 90
Note:
Developers can use the Projects class to store and access multiple Project instances efficiently. By leveraging the Project class, they can define and manage individual projects within the list structure provided by the Projects class.

Chunk 91
ClassDef Dish  
Dish: The function of Dish is to represent a dish with its name and description.
attributes:
- name: str (The name of the dish)
- description: str (The description of the dish)
Code Description:

Chunk 92
The Dish class is a part of the BaseModel class. It has two attributes: name and description, both of which are strings. The 'name' attribute represents the name of the dish, while the 'description' attribute provides a description of the dish. This

Chunk 93
description of the dish. This class is designed to store information about a specific dish.

Chunk 94
Note:

Chunk 95
When using the Dish class, make sure to provide values for both the 'name' and 'description' attributes to ensure accurate representation of the dish. Additionally, this class can be utilized within other classes like Dishes, which contains a list

Chunk 96
Dishes, which contains a list of Dish objects.

Chunk 97
ClassDef Dishes  
Dishes: The function of Dishes is to store a list of Dish objects.  
attributes:
- dishes: List[Dish] (A list of Dish objects)  
Code Description:

Chunk 98
The Dishes class is a part of the BaseModel class. It contains a single attribute named 'dishes', which is a list of Dish objects. Each Dish object represents a specific dish with a name and description. By utilizing the Dishes class, multiple Dish

Chunk 99
Dishes class, multiple Dish objects can be stored and managed collectively within a list structure. This class facilitates the organization and handling of multiple dish entities in a structured manner.

Chunk 100
Note:

Chunk 101
When working with the Dishes class, ensure that the 'dishes' attribute is populated with valid Dish objects to maintain the integrity of the list structure. This class can be effectively used to manage and manipulate collections of Dish objects

Chunk 102
collections of Dish objects within a larger context, such as in a menu or recipe management system.

Chunk 103
ClassDef Project  
Project: The function of Project is to define a class representing a project with title and description attributes.  
attributes:
- title: str (The title of the project)
- description: str (The description of the project)

Chunk 104
Code Description:

Chunk 105
The Project class is a subclass of BaseModel and defines two attributes: title and description, both of type string. The title attribute represents the title of the project, while the description attribute represents the description of the project.

Chunk 106
description of the project.

Chunk 107
In the calling object, Projects, a list of Project objects is defined as the projects attribute. This structure allows for storing multiple projects within the Projects class.  
Note:

Chunk 108
Note:
Developers can use the Project class to create instances of projects with specific titles and descriptions. When working with the Projects class, they can access a list of Project objects representing different projects.  
ClassDef Projects

Chunk 109
ClassDef Projects  
Projects: The function of Projects is to define a class representing a collection of projects.  
attributes:
- projects: List[Project] (A list containing Project objects representing different projects)  
Code Description:

Chunk 110
The Projects class is a subclass of BaseModel and contains a single attribute named projects. The projects attribute is a list that stores instances of the Project class. Each Project object within the list represents a specific project with a title

Chunk 111
specific project with a title and description.

Chunk 112
By utilizing the Projects class, developers can manage and access multiple Project instances efficiently. This structure enables the storage and organization of various projects within a single container, facilitating operations on project data.

Chunk 113
Note:

Chunk 114
Developers can create instances of the Projects class to work with collections of projects. The projects attribute allows for easy manipulation and retrieval of individual Project objects, providing a structured approach to handling project-related

Chunk 115
to handling project-related data.

Chunk 116
ClassDef Project  
Project: The function of Project is to define a class with attributes for title and description.  
attributes:
- title: str
- description: str  
Code Description:

Chunk 117
The Project class is a subclass of BaseModel that represents a project with a title and description. The title attribute is a string that holds the title of the project, while the description attribute is a string that contains a description of the

Chunk 118
contains a description of the project. This class serves as a blueprint for creating project objects with specific title and description attributes.

Chunk 119
In the context of the project structure, the Project class is utilized within the Projects class. The Projects class contains a dictionary where the keys are strings and the values are instances of the Project class. This relationship allows for

Chunk 120
This relationship allows for multiple projects to be stored and accessed within the Projects class using unique identifiers.

Chunk 121
Note:

Chunk 122
Developers can create instances of the Project class by providing values for the title and description attributes. The Project class provides a structured way to manage project data within the larger Projects class, enabling organized storage and

Chunk 123
organized storage and retrieval of project information.

Chunk 124
ClassDef Projects  
Projects: The function of Projects is to define a class that contains a dictionary with keys as strings and values as instances of the Project class.  
attributes:
- Projects: Dict[str, Project]  
Code Description:

Chunk 125
The Projects class is a subclass of BaseModel that stores multiple project instances using a dictionary structure. Each key in the dictionary is a string identifier, and the corresponding value is an instance of the Project class. This design allows

Chunk 126
class. This design allows for the organized storage and retrieval of project information within the Projects class.

Chunk 127
The Projects class serves as a container for managing project data efficiently. By utilizing the dictionary format, developers can access specific project instances based on unique keys. This structured approach enhances the organization and

Chunk 128
enhances the organization and accessibility of project details within the larger context of the Projects class.

Chunk 129
The relationship between the Projects class and the Project class is crucial for maintaining a structured representation of project data. Instances of the Project class can be created with specific title and description attributes, which are then

Chunk 130
attributes, which are then stored within the Projects class using unique identifiers. This relationship enables developers to work with individual project instances while leveraging the collective functionality provided by the Projects class.

Chunk 131
Note:

Chunk 132
Developers can create, store, and access project instances within the Projects class by utilizing the dictionary structure. This approach facilitates the management of multiple projects and allows for efficient data retrieval based on unique keys.

Chunk 133
based on unique keys. The Projects class offers a systematic way to handle project information within a larger data structure, promoting organization and ease of access.

Chunk 134
ClassDef Dish  
Dish: The function of Dish is to represent a dish with its name and description.  
attributes:
- name: str (The name of the dish)
- description: str (The description of the dish)  
Code Description:

Chunk 135
The Dish class defines a data model for a dish with two attributes: name and description. The name attribute stores the name of the dish as a string, while the description attribute stores a description of the dish. This class inherits from the

Chunk 136
This class inherits from the BaseModel class.

Chunk 137
Note:
Developers can use the Dish class to create instances representing individual dishes with their respective names and descriptions. The Dish class is utilized within the Dishes class in the project to create a list of dishes.

Chunk 138
ClassDef Dishes  
Dishes: The function of Dishes is to define a data model for a list of dishes.  
attributes:
- dishes: List[Dish] (A list of Dish objects representing individual dishes)  
Code Description:

Chunk 139
The Dishes class is a data model that consists of a single attribute, "dishes," which is a list of Dish objects. Each Dish object represents an individual dish with its name and description. This class is based on the BaseModel class.  
Note:

Chunk 140
Note:
Developers can utilize the Dishes class to create instances representing multiple dishes grouped together in a list. The Dishes class relies on the Dish class within the project to define the structure of individual dishes.

Chunk 141
ClassDef Dish  
Dish: The function of Dish is to define a class representing a dish with attributes such as name and description.  
attributes:
- name: str (description: "The name of the dish")

Chunk 142
- description: str (description: "The description of the dish")  
Code Description:

Chunk 143
The Dish class is a subclass of BaseModel and defines the structure of a dish object with two attributes: name and description. The 'name' attribute is a string type that represents the name of the dish, while the 'description' attribute is also a

Chunk 144
attribute is also a string type that provides a description of the dish.

Chunk 145
The Dish class is designed to be used within the context of defining dishes in a menu or a list of dishes. It provides a structured way to store and access information about individual dishes.

Chunk 146
In the project, the Dish class is utilized within the Dishes class, where a list of Dish objects is defined. This relationship allows for organizing multiple dish objects under a common container, enabling the management of a collection of dishes.

Chunk 147
Note:

Chunk 148
Developers can create instances of the Dish class to represent individual dishes by providing values for the 'name' and 'description' attributes. The class enforces the structure of dish objects and provides a clear way to access and manipulate

Chunk 149
way to access and manipulate dish-related information.

Chunk 150
ClassDef Dishes  
Dishes: The function of Dishes is to define a class representing a collection of dish objects.  
attributes:
- dishes: List[Dish] (description: "A list containing Dish objects representing individual dishes")  
Code Description:

Chunk 151
Code Description:
The Dishes class is a subclass of BaseModel and is designed to store a list of Dish objects. The 'dishes' attribute is a list that holds instances of the Dish class, representing individual dishes within the collection.

Chunk 152
This class facilitates the organization and management of multiple dish objects under a common container, allowing for the structured storage and retrieval of information related to various dishes.

Chunk 153
The Dishes class is utilized to create a cohesive grouping of Dish objects, enabling the handling of a set of dishes as a single entity within the context of a menu or a list of dishes.  
Note:

Chunk 154
Developers can instantiate the Dishes class to create a collection of dish objects by populating the 'dishes' attribute with instances of the Dish class. This approach provides a systematic way to manage and interact with multiple dish entities

Chunk 155
with multiple dish entities within a menu or similar structure.

Chunk 156
ClassDef Project  
Project: The function of Project is to define the structure of a project with attributes like title and description.  
attributes:
- title: str (The title of the project)
- description: str (The description of the project)

Chunk 157
Code Description:

Chunk 158
The Project class is a part of the smart_scraper_schema_groq.py file in the groq directory. It is a subclass of BaseModel and defines the attributes of a project, including the title and description. The title attribute represents the title of the

Chunk 159
represents the title of the project, while the description attribute holds the description of the project.

Chunk 160
The Projects class in the same file utilizes a list of Project instances to represent multiple projects. This relationship allows the Projects class to contain and manage multiple Project instances, providing a structured way to handle a collection

Chunk 161
way to handle a collection of projects.

Chunk 162
Note:

Chunk 163
Developers can use the Project class to create instances representing individual projects with specific titles and descriptions. When working with multiple projects, they can utilize the Projects class to manage a list of Project instances

Chunk 164
a list of Project instances efficiently.

Chunk 165
ClassDef Projects  
Projects: The function of Projects is to define a class that contains a list of Project instances.  
attributes:
- projects: List[Project] (A list of Project instances)  
Code Description:

Chunk 166
The Projects class is a subclass of BaseModel and is defined in the smart_scraper_schema_groq.py file in the groq directory. It contains a single attribute named "projects", which is a list of Project instances. Each Project instance represents an

Chunk 167
instance represents an individual project with attributes such as title and description.

Chunk 168
The Projects class serves as a structured way to manage and work with multiple Project instances. By utilizing a list of Project instances, developers can efficiently handle collections of projects within the context of the Projects class.  
Note:

Chunk 169
Developers can use the Projects class to organize and manage multiple Project instances representing different projects. This class provides a convenient way to work with a group of projects and access their individual attributes through the list of

Chunk 170
through the list of Project instances.

Chunk 171
ClassDef Project  
Project: The function of Project is to define a class with attributes for title and description.  
attributes:
- title: str
- description: str  
Code Description:

Chunk 172
The Project class is a data model that inherits from the BaseModel class. It defines two attributes: title and description, both of which are of type string. This class serves as a blueprint for creating instances of projects with specific titles

Chunk 173
projects with specific titles and descriptions.

Chunk 174
In the context of the project structure, the Project class is utilized within the Projects class. The Projects class contains a dictionary where the keys are strings and the values are instances of the Project class. This relationship allows for the

Chunk 175
relationship allows for the organization of multiple projects with unique titles and descriptions.

Chunk 176
Note:
Developers can use the Project class to create instances representing individual projects, providing a structured way to store and access project information within the larger Projects class.  
ClassDef Projects

Chunk 177
ClassDef Projects  
Projects: The function of Projects is to define a class that contains a dictionary with keys as strings and values as instances of the Project class.  
attributes:
- Projects: Dict[str, Project]  
Code Description:

Chunk 178
The Projects class is a data model that inherits from the BaseModel class. It consists of a dictionary where the keys are strings and the values are instances of the Project class. This structure allows for the organization of multiple projects,

Chunk 179
of multiple projects, each with a unique title and description. By utilizing the Project class within the Projects class, developers can create and manage instances representing individual projects in a structured manner.

Chunk 180
Note:

Chunk 181
Developers can use the Projects class to store and access information about multiple projects efficiently. The relationship between the Projects class and the Project class enables the creation of a collection of projects with distinct attributes,

Chunk 182
with distinct attributes, facilitating better organization and management of project data.

Chunk 183
ClassDef Image  
Image: The function of Image is to represent an image with a URL attribute.  
attributes:
- url: A string attribute representing the URL of the image.  
Code Description:

Chunk 184
Code Description:
The Image class is a part of the BaseModel and contains a single attribute 'url' of type string, which describes the URL of the image. This class is designed to store information related to an image in the application.

Chunk 185
The Images class, which is a caller of the Image class, contains a list of Image objects. This relationship allows the Images class to manage multiple Image objects as a collection. By utilizing the Image class within the Images class, developers

Chunk 186
the Images class, developers can organize and work with image data efficiently.

Chunk 187
Note:
Developers can create instances of the Image class to store image information such as URLs. When working with multiple images, they can use the Images class to manage a collection of Image objects effectively.  
ClassDef Images

Chunk 188
ClassDef Images  
Images: The function of Images is to manage a collection of Image objects efficiently.  
attributes:
- images: A list containing Image objects.  
Code Description:

Chunk 189
The Images class is a part of the BaseModel and contains a single attribute 'images', which is a list of Image objects. Each Image object represents an image with a URL attribute. This class is designed to handle multiple Image objects as a

Chunk 190
multiple Image objects as a collection, allowing developers to organize and work with image data effectively.

Chunk 191
By utilizing the Images class, developers can create instances to store and manage multiple Image objects. This relationship enables the Images class to handle image data in a structured manner within the application.  
Note:

Chunk 192
Note:
Developers can use the Images class to work with collections of Image objects, each representing an image with a URL attribute. This class provides a convenient way to manage and organize image data within the application.

Chunk 193
ClassDef Dish  
Dish: The function of Dish is to represent a dish with its name and description.  
attributes:
- name: str (description: "The name of the dish")
- description: str (description: "The description of the dish")  
Code Description:

Chunk 194
The Dish class defines a model for a dish with attributes for the name and description. It inherits from the BaseModel class. The 'name' attribute represents the name of the dish, while the 'description' attribute provides a description of the dish.

Chunk 195
a description of the dish.

Chunk 196
Note:

Chunk 197
Developers can use the Dish class to create instances of dishes with specific names and descriptions. The class structure allows for easy access and manipulation of dish information within the application. When used in conjunction with the Dishes

Chunk 198
conjunction with the Dishes class, instances of Dish can be organized and managed effectively.

Chunk 199
ClassDef Dishes  
Dishes: The function of Dishes is to define a model for a collection of dishes.  
attributes:
- dishes: List[Dish] (description: "A list containing instances of the Dish class representing individual dishes")  
Code Description:

Chunk 200
The Dishes class represents a model for a collection of dishes. It contains an attribute 'dishes' which is a list holding instances of the Dish class. Each instance in the list represents an individual dish with its name and description.

Chunk 201
When used in conjunction with the Dish class, the Dishes class allows for the organization and management of multiple dish instances. The 'dishes' attribute provides a structured way to store and access information about various dishes within the

Chunk 202
various dishes within the application.

Chunk 203
Note:

Chunk 204
Developers can utilize the Dishes class to create and manage collections of dishes efficiently. By populating the 'dishes' attribute with instances of the Dish class, they can work with multiple dish objects seamlessly. This class structure

Chunk 205
This class structure facilitates the handling of dish-related data and operations within the application.

Chunk 206
ClassDef Project  
Project: The function of Project is to define a class representing a project with title and description attributes.  
attributes:
- title: str (description: "The title of the project")

Chunk 207
- description: str (description: "The description of the project")  
Code Description:

Chunk 208
The Project class is a subclass of BaseModel and represents a project entity with two attributes: title and description. The title attribute is a string type that holds the title of the project, while the description attribute is also a string type

Chunk 209
is also a string type that stores the description of the project.

Chunk 210
In the context of the project structure, the Projects class, defined in the smart_scraper_schema_ollama.py file, contains a list of Project instances. This relationship indicates that the Projects class is a container for multiple Project objects,

Chunk 211
for multiple Project objects, allowing for the management of multiple projects within a single entity.

Chunk 212
Note:

Chunk 213
Developers can utilize the Project class to create instances of projects with specific titles and descriptions. When working with the Projects class, they can access and manipulate a list of Project instances, each representing a distinct project

Chunk 214
a distinct project entity.

Chunk 215
ClassDef Projects  
Projects: The function of Projects is to define a class containing a list of Project instances.  
attributes:
- projects: List[Project]  
Code Description:

Chunk 216
The Projects class is a subclass of BaseModel and serves as a container for multiple Project objects. It includes a single attribute named "projects," which is a list of Project instances. Each Project instance represents a distinct project entity

Chunk 217
a distinct project entity with title and description attributes.

Chunk 218
In the context of the project structure, the Projects class allows developers to manage and manipulate multiple projects efficiently within a single entity. By utilizing the Projects class, developers can create, access, and modify a collection of

Chunk 219
and modify a collection of Project instances, each representing a specific project with its title and description.

Chunk 220
Note:
Developers can leverage the Projects class to work with a group of Project instances, enabling them to handle multiple project entities seamlessly within their applications.

Chunk 221
ClassDef Project  
Project: The function of Project is to define a class with attributes for title and description.  
attributes:
- title: str
- description: str  
Code Description:

Chunk 222
The Project class is a subclass of BaseModel and defines two attributes: title and description, both of which are of type string. This class serves as a blueprint for creating instances of projects with specific titles and descriptions.

Chunk 223
In the context of the project structure, the Projects class, which contains a dictionary of Project instances, can utilize the Project class to define individual projects with titles and descriptions.  
Note:

Chunk 224
Developers can use the Project class to create instances representing different projects by providing values for the title and description attributes. The class structure ensures consistency in the representation of project data within the

Chunk 225
of project data within the application.

Chunk 226
ClassDef Projects  
Projects: The function of Projects is to define a class that contains a dictionary of Project instances.  
attributes:
- Projects: Dict[str, Project]  
Code Description:

Chunk 227
The Projects class is a subclass of BaseModel and consists of a dictionary where the keys are strings and the values are instances of the Project class. This structure allows for the organization of multiple Project instances within a single

Chunk 228
instances within a single container. Each Project instance represents a specific project with a title and description, as defined by the Project class.

Chunk 229
By utilizing the Project class as the value type in the dictionary, the Projects class ensures that each project entry maintains consistency in its structure and attributes. Developers can access and manipulate individual projects within the

Chunk 230
projects within the Projects container by interacting with the dictionary using the project titles as keys.

Chunk 231
Note:

Chunk 232
The Projects class serves as a centralized repository for managing and accessing multiple Project instances. It provides a structured approach to working with project data and enables efficient organization and retrieval of project information

Chunk 233
of project information within the application.

Chunk 234
ClassDef Dish  
Dish: The function of Dish is to represent a dish with a name and description.  
attributes:
- name: str (The name of the dish)
- description: str (The description of the dish)  
Code Description:

Chunk 235
The Dish class defines a data model for a dish with attributes for the name and description. It inherits from the BaseModel class. The 'name' attribute is a string type that represents the name of the dish, while the 'description' attribute is also

Chunk 236
attribute is also a string type that provides a description of the dish.

Chunk 237
The Dish class is utilized within the Dishes class, where a list of Dish objects is stored. The Dishes class acts as a container for multiple Dish instances, allowing for the management and manipulation of a collection of dishes.  
Note:

Chunk 238
Developers can create instances of the Dish class to represent individual dishes, providing a structured way to store and access information about different dishes. The use of the Dish class within the Dishes class enables the organization of

Chunk 239
enables the organization of multiple dish objects, facilitating operations on a group of dishes.

Chunk 240
ClassDef Dishes  
Dishes: The function of Dishes is to store a list of Dish objects.  
attributes:
- dishes: List[Dish] (A list of Dish objects)  
Code Description:

Chunk 241
The Dishes class defines a data model that contains a list of Dish objects. Each Dish object represents an individual dish with a name and description. The Dishes class serves as a container for managing multiple Dish instances, allowing for the

Chunk 242
instances, allowing for the organization and manipulation of a collection of dishes.

Chunk 243
The Dishes class utilizes the Dish class, which defines the structure of an individual dish. By storing a list of Dish objects, the Dishes class enables the handling of multiple dishes within a single entity, facilitating operations on a group of

Chunk 244
operations on a group of dishes.

Chunk 245
Note:

Chunk 246
Developers can create instances of the Dish class to represent specific dishes and then store these instances within the Dishes class to manage a collection of dishes efficiently. This structure provides a structured way to handle and access

Chunk 247
way to handle and access information about different dishes, enhancing the organization and manipulation of dish data.

Chunk 248
ClassDef Project  
Project: The function of Project is to define the structure of a project with attributes like title and description.  
attributes:
- title: str (description: "The title of the project")

Chunk 249
- description: str (description: "The description of the project")  
Code Description:

Chunk 250
The Project class is a part of the smart_scraper_schema_oneapi.py file in the oneapi module. It inherits from the BaseModel class and defines two attributes: title and description, both of type string. The title attribute represents the title of the

Chunk 251
represents the title of the project, while the description attribute holds the description of the project.

Chunk 252
The Projects class, defined in the same file, contains a list of Project instances. This relationship indicates that the Projects class is a container for multiple Project objects, allowing for the management of multiple projects within a single

Chunk 253
projects within a single entity.

Chunk 254
Note:

Chunk 255
Developers can use the Project class to create instances representing individual projects with specific titles and descriptions. When working with multiple projects, they can utilize the Projects class to organize and manipulate a collection of

Chunk 256
manipulate a collection of Project instances efficiently.

Chunk 257
ClassDef Projects  
Projects: The function of Projects is to define a class that contains a list of Project instances.  
attributes:
- projects: List[Project]  
Code Description:

Chunk 258
The Projects class is defined in the smart_scraper_schema_oneapi.py file within the oneapi module. It consists of a single attribute named projects, which is a list of Project instances. The Project class, which is imported from the same file,

Chunk 259
imported from the same file, defines the structure of individual projects with attributes such as title and description. By utilizing the Projects class, developers can manage and organize multiple Project instances efficiently within a single

Chunk 260
efficiently within a single entity.

Chunk 261
Note:

Chunk 262
Developers can use the Project class to create instances representing individual projects with specific titles and descriptions. The Projects class serves as a container for these Project instances, enabling the manipulation of multiple projects

Chunk 263
of multiple projects collectively.

Chunk 264
ClassDef Article  
Article: The function of Article is to define the structure of an article with specific attributes related to research variables.  
attributes:
- independent_variable: str
- dependent_variable: str
- exogenous_shock: str

Chunk 265
- exogenous_shock: str  
Code Description:
The Article class is a part of the BaseModel and defines the structure of an article with three attributes:

Chunk 266
1. independent_variable: Represents the variable that is manipulated or considered as the primary cause affecting other variables. It is denoted as (IV) and is crucial in research studies.

Chunk 267
2. dependent_variable: Represents the variable that is measured or observed, which is expected to change as a result of variations in the Independent Variable. It is denoted as (DV) and plays a significant role in analyzing research outcomes.

Chunk 268
3. exogenous_shock: Identifies any external or unexpected events used in the study that serve as a natural experiment or provide a unique setting for observing the effects on the Independent Variable and Dependent Variable.

Chunk 269
The Article class is designed to encapsulate these key attributes related to research variables, providing a structured way to represent articles in a research context. It helps in organizing and managing data related to research articles

Chunk 270
related to research articles efficiently.

Chunk 271
Note:

Chunk 272
Developers can use the Article class to create instances of articles with specific attributes related to research variables. When using this class, ensure that the attributes are assigned appropriate values to accurately represent the research

Chunk 273
represent the research article's content and variables.

Chunk 274
ClassDef Articles  
Articles: The function of Articles is to define a class that contains a list of articles, each represented by the Article class.  
attributes:
- articles: List[Article]  
Code Description:

Chunk 275
Code Description:
The Articles class is a subclass of BaseModel and consists of a single attribute:

Chunk 276
- articles: This attribute is a list that holds instances of the Article class. Each element in the list represents an article with specific attributes related to research variables, as defined in the Article class.

Chunk 277
The Articles class serves as a container for multiple Article instances, allowing for the organization and management of a collection of articles within a research context.  
Note:

Chunk 278
Developers can utilize the Articles class to create a structured collection of articles, each with defined attributes related to research variables. When using this class, ensure that the 'articles' attribute is populated with instances of the

Chunk 279
with instances of the Article class to represent individual articles accurately.

Chunk 280
ClassDef Project  
Project: The function of Project is to define the structure of a project with attributes such as title and description.  
attributes:
- title: str
- description: str  
Code Description:

Chunk 281
The Project class is a data model that inherits from the BaseModel class. It defines two attributes: title and description, both of which are strings. The title attribute represents the title of the project, while the description attribute

Chunk 282
the description attribute represents the description of the project.

Chunk 283
In the context of the project structure, the Project class serves as a blueprint for defining individual projects with specific titles and descriptions. It provides a structured way to organize and store information about different projects within

Chunk 284
different projects within the system.

Chunk 285
The Projects class, which contains a list of Project instances, utilizes the Project class to create a collection of projects with titles and descriptions. By defining the Project class with title and description attributes, the Projects class can

Chunk 286
the Projects class can maintain a list of projects with detailed information about each project.

Chunk 287
Note:

Chunk 288
Developers can use the Project class to create and manage individual projects within the system by setting the title and description attributes accordingly. The Projects class then utilizes these Project instances to handle multiple projects

Chunk 289
to handle multiple projects efficiently.

Chunk 290
ClassDef Projects  
Projects: The function of Projects is to define a class that contains a list of Project instances.  
attributes:
- projects: List[Project]  
Code Description:

Chunk 291
The Projects class is a data model that contains a list of Project instances. It utilizes the Project class to define individual projects with attributes such as title and description. The projects attribute represents a list of Project instances,

Chunk 292
a list of Project instances, allowing for the organization and storage of multiple projects within the system.

Chunk 293
In the context of the project structure, the Projects class serves as a container for managing and accessing multiple Project instances. By maintaining a list of Project instances, it provides a structured way to handle and manipulate various

Chunk 294
handle and manipulate various projects with specific titles and descriptions efficiently.

Chunk 295
The Projects class relies on the Project class to define the structure of each project and uses the list of Project instances to represent a collection of projects within the system. This relationship enables developers to work with multiple

Chunk 296
to work with multiple projects seamlessly by leveraging the attributes and functionalities defined in the Project class.

Chunk 297
Note:

Chunk 298
Developers can use the Projects class to create, store, and manage multiple projects by interacting with the list of Project instances stored in the projects attribute. By utilizing the Project class as a blueprint for individual projects, the

Chunk 299
for individual projects, the Projects class facilitates the handling of project-related data and operations effectively.

Chunk 300
ClassDef Dish  
Dish: The function of Dish is to represent a dish with its name and description.  
attributes:
- name: str (The name of the dish)
- description: str (The description of the dish)  
Code Description:

Chunk 301
The Dish class defines a data model for a dish with two attributes: name and description, both of which are of type string. This class inherits from the BaseModel class. The 'name' attribute represents the name of the dish, while the 'description'

Chunk 302
dish, while the 'description' attribute provides a description of the dish.

Chunk 303
Note:
Developers can use the Dish class to create instances of dishes with specific names and descriptions. This class is utilized within the Dishes class, which contains a list of Dish instances.  
ClassDef Dishes

Chunk 304
ClassDef Dishes  
Dishes: The function of Dishes is to define a data model for a list of dishes.  
attributes:
- dishes: List[Dish] (A list of Dish instances)  
Code Description:

Chunk 305
The Dishes class is a data model that contains a list of Dish instances. Each Dish instance represents a dish with a name and description. The Dishes class itself inherits from the BaseModel class. The 'dishes' attribute is a list that holds

Chunk 306
is a list that holds instances of the Dish class, allowing for the representation of multiple dishes within a single object.

Chunk 307
Note:

Chunk 308
Developers can utilize the Dishes class to manage and work with collections of Dish instances, enabling the organization and manipulation of multiple dish objects within their applications. The Dishes class serves as a container for Dish instances,

Chunk 309
container for Dish instances, providing a structured approach to handling and accessing multiple dish entities.

Chunk 310
ClassDef Project  
Project: The function of Project is to define a data model for a project with title and description attributes.  
attributes:
- title: str (The title of the project)
- description: str (The description of the project)

Chunk 311
Code Description:

Chunk 312
The Project class is a data model that inherits from the BaseModel class. It defines two attributes: title and description, both of which are of type string. The title attribute represents the title of the project, while the description attribute

Chunk 313
the description attribute represents the description of the project.

Chunk 314
In the calling object, Projects, which is a data model that contains a list of Project objects, the Project class is used to define the structure of individual projects within the list. This allows for organizing and storing multiple projects with

Chunk 315
multiple projects with their respective titles and descriptions.

Chunk 316
Note:
Developers can use the Project class to create instances of projects with specific titles and descriptions, and then include these instances within a Projects object to manage a collection of projects effectively.  
ClassDef Projects

Chunk 317
ClassDef Projects  
Projects: The function of Projects is to define a data model that contains a list of Project objects.  
attributes:
- projects: List[Project] (A list of Project objects)  
Code Description:

Chunk 318
The Projects class is a data model that inherits from the BaseModel class. It includes an attribute named projects, which is a list of Project objects. Each Project object within the projects list represents an individual project with a title and

Chunk 319
project with a title and description.

Chunk 320
In the context of the project structure, the Projects class serves as a container for organizing and managing multiple Project instances. By utilizing the Project class to define the structure of individual projects, developers can create, store,

Chunk 321
developers can create, store, and manipulate a collection of projects effectively within the Projects object.

Chunk 322
Note:

Chunk 323
Developers can leverage the Projects class to create a structured collection of projects by populating the projects attribute with instances of the Project class. This approach facilitates the management of multiple projects within a single entity,

Chunk 324
within a single entity, enabling efficient organization and access to project details.

Chunk 325
ClassDef GraphBuilder  
GraphBuilder: The function of GraphBuilder is to dynamically construct web scraping graphs based on user prompts using a natural language understanding model.  
Attributes:

Chunk 326
Attributes:
- prompt (str): The user's natural language prompt for the scraping task.
- llm (ChatOpenAI): An instance of the ChatOpenAI class configured with the specified llm_config.

Chunk 327
- nodes_description (str): A string description of all available nodes and their arguments.
- chain (LLMChain): The extraction chain responsible for processing the prompt and creating the graph.  
Code Description:

Chunk 328
The GraphBuilder class is designed to facilitate the creation of web scraping graphs by interpreting user prompts through a natural language understanding model. It contains methods to build the graph configuration based on the user prompt and

Chunk 329
based on the user prompt and convert the configuration to a Graphviz object for visualization. The class initializes with a user prompt and language model configuration, creates an extraction chain for processing the prompt, and generates a

Chunk 330
the prompt, and generates a description of available nodes and their arguments. The class ensures that the language model configuration includes an API key and selects the appropriate model based on the provided parameters.

Chunk 331
The GraphBuilder class plays a crucial role in the ScrapeGraphAI project by enabling users to generate graph configurations for web scraping tasks efficiently. It interacts with the ChatOpenAI, LLMChain, and other related classes to process user

Chunk 332
classes to process user prompts, create extraction chains, and visualize the graph configurations.

Chunk 333
Note:
Developers can utilize the GraphBuilder class to streamline the process of creating web scraping graphs by leveraging natural language prompts and a predefined set of nodes.  
Output Example:
{
"text": [
{
"nodes": [
{
"node_name": "Node1",

Chunk 334
{
"node_name": "Node1",
"type": "TypeA"
},
{
"node_name": "Node2",
"type": "TypeB"
}
],
"edges": [
{
"from": "Node1",
"to": "Node2"
}
],
"entry_point": "Node1"
}
]
}  
FunctionDef init(self, prompt, config)

Chunk 335
init: The function of init is to initialize the GraphBuilder with a user prompt and language model configuration.  
parameters:
- prompt (str): A user prompt for the GraphBuilder.

Chunk 336
- config (dict): A dictionary containing configuration parameters for the language model.  
Code Description:

Chunk 337
The init function sets the user prompt and configuration parameters for the GraphBuilder instance. It initializes the prompt, configuration, language model (llm), nodes description, and extraction chain. The language model is created using the

Chunk 338
model is created using the _create_llm method, the nodes description is generated using the _generate_nodes_description method, and the extraction chain is created using the _create_extraction_chain method.

Chunk 339
In the project structure, the init function serves as the constructor for the GraphBuilder class. It establishes the initial state of the GraphBuilder object by setting up essential components such as the user prompt, configuration, language model,

Chunk 340
language model, nodes description, and extraction chain. This initialization process is crucial for preparing the GraphBuilder to handle user input and generate graph configurations effectively.

Chunk 341
Note:

Chunk 342
Developers should ensure that valid parameters are provided for the prompt and configuration when initializing a GraphBuilder object. Additionally, the _create_llm, _generate_nodes_description, and _create_extraction_chain methods are automatically

Chunk 343
methods are automatically called during the GraphBuilder initialization to set up necessary components for graph building and processing user prompts.

Chunk 344
FunctionDef _create_llm(self, llm_config)  
_create_llm: The function of _create_llm is to create an instance of a language model class (OpenAI, Gemini, or Ernie) based on the provided configuration parameters.  
parameters:

Chunk 345
parameters:
- llm_config (dict): A dictionary containing configuration parameters for the language model.  
Code Description:

Chunk 346
The _create_llm function initializes with default temperature and streaming parameters. It then updates these defaults with any provided llm_config parameters. If the 'api_key' is not present in the updated parameters, a ValueError is raised. The

Chunk 347
a ValueError is raised. The function determines the model type based on the model name in the configuration and returns an instance of the corresponding model class (OpenAI, Gemini, or Ernie). If the model name does not match any supported models, a

Chunk 348
match any supported models, a ValueError is raised.

Chunk 349
In the project, the _create_llm function is called within the GraphBuilder class during the initialization process. It plays a crucial role in creating instances of language models based on specific configurations provided to the GraphBuilder.

Chunk 350
provided to the GraphBuilder. Depending on the model name specified in the configuration, the function instantiates the appropriate language model class (OpenAI, Gemini, or Ernie) to be used within the graph building process.

Chunk 351
Note:

Chunk 352
Developers should ensure that the 'api_key' parameter is included in the llm_config dictionary to avoid ValueError. The _create_llm function provides flexibility in selecting and creating instances of different language model classes based on the

Chunk 353
model classes based on the specified model name in the configuration.

Chunk 354
Output Example:
An instance of the OpenAI class or its subclasses (Gemini, Ernie) based on the provided configuration parameters.  
FunctionDef _generate_nodes_description(self)

Chunk 355
_generate_nodes_description: The function of _generate_nodes_description is to generate a string description of all available nodes and their arguments.  
parameters:
 self: The instance of the class.  
Code Description:

Chunk 356
The _generate_nodes_description function creates a string description for all available nodes and their respective arguments. It iterates over the nodes_metadata dictionary, extracting the node name, description, type, and arguments. The final

Chunk 357
and arguments. The final output is a formatted string containing this information for each node.

Chunk 358
In the calling situation, this function is called within the init method of the GraphBuilder class. After initializing the GraphBuilder with a user prompt and configuration, the _generate_nodes_description function is invoked to populate the

Chunk 359
is invoked to populate the nodes_description attribute with the description of all available nodes and their arguments.

Chunk 360
Note:
Ensure that nodes_metadata is properly defined and populated before calling this function to avoid any errors related to missing node information.  
Output Example:
- Node1: Description of Node1 (Type: Type1, Args: arg1, arg2)

Chunk 361
- Node2: Description of Node2 (Type: Type2, Args: arg1, arg2, arg3)  
FunctionDef _create_extraction_chain(self)

Chunk 362
_create_extraction_chain: The function of _create_extraction_chain is to create an extraction chain for processing the user prompt and generating the graph configuration.  
parameters:
- None  
Code Description:

Chunk 363
The _create_extraction_chain function is responsible for generating an extraction chain used in processing user prompts and creating graph configurations. It constructs a prompt template that guides an AI in designing direct graphs for web scraping

Chunk 364
graphs for web scraping tasks based on user input. The function then returns an instance of the LLMChain class, which is essential for the graph building process.

Chunk 365
In the project structure, this function is called within the init method of the GraphBuilder class. When an instance of GraphBuilder is initialized, the _create_extraction_chain function is automatically invoked to set up the extraction chain needed

Chunk 366
the extraction chain needed for processing user prompts and configuring the graph.

Chunk 367
Note:
Developers using this function should ensure that the necessary dependencies such as graph_schema, nodes_description, and llm are properly set up before calling _create_extraction_chain to avoid any potential errors.  
Output Example:

Chunk 368
Output Example:
LLMChain: An instance of the LLMChain class.  
FunctionDef build_graph(self)  
build_graph: The function of build_graph is to execute the graph creation process based on the user prompt and return the graph configuration.

Chunk 369
parameters:
- None  
Code Description:

Chunk 370
The build_graph function is responsible for initiating the process of creating a graph based on user input. It calls the 'invoke' method of the 'chain' object, passing the 'prompt' as a parameter. The 'chain' object is assumed to be an instance of a

Chunk 371
to be an instance of a class that handles the graph creation process. Once the 'invoke' method is called, the graph creation process is triggered, and the function returns a JSON representation of the graph configuration.

Chunk 372
Note:

Chunk 373
Developers using this function should ensure that the 'chain' object is properly initialized and configured to handle the graph creation process. Additionally, the 'prompt' parameter should contain the necessary information for the graph

Chunk 374
information for the graph configuration.

Chunk 375
Output Example:
{
"graph_type": "directed",
"nodes": [
{"id": 1, "label": "Node 1"},
{"id": 2, "label": "Node 2"}
],
"edges": [
{"source": 1, "target": 2, "weight": 0.5}
]
}  
FunctionDef convert_json_to_graphviz(json_data, format)

Chunk 376
convert_json_to_graphviz: The function of convert_json_to_graphviz is to convert a JSON graph configuration to a Graphviz object for visualization.  
parameters:
- json_data (dict): A JSON representation of the graph configuration.

Chunk 377
- format (str): Optional parameter specifying the format of the output (default is 'pdf').  
Code Description:

Chunk 378
The function first imports the 'graphviz' library and creates a Graphviz object with specified attributes. It then extracts node, edge, and entry point information from the JSON data. Nodes are added to the graph, with special styling for the entry

Chunk 379
special styling for the entry point node. Edges are then added to connect the nodes based on the configuration provided in the JSON data. Finally, the function returns the Graphviz object representing the graph configuration.

Chunk 380
Note:
- Ensure the 'graphviz' library is installed to use this functionality.
- The entry point node is visually distinguished in the graph by using a double circle shape.  
Output Example:
A Graphviz object representing the graph configuration.

Chunk 381
ClassDef ChromiumLoader  
ChromiumLoader: The function of ChromiumLoader is to scrape HTML pages from URLs using a headless instance of the Chromium web driver with proxy protection.  
Attributes:

Chunk 382
Attributes:
- backend: The web driver backend library; defaults to 'playwright'.
- browser_config: A dictionary containing additional browser kwargs.
- headless: whether to run the browser in headless mode.

Chunk 383
- proxy: A dictionary containing proxy settings; None disables protection.
- urls: A list of URLs to scrape content from.  
Code Description:

Chunk 384
The ChromiumLoader class is designed to scrape HTML content from URLs using a headless Chromium web driver with proxy support. The class constructor initializes the loader with the necessary parameters such as backend, headless mode, proxy settings,

Chunk 385
mode, proxy settings, URLs to scrape, and additional browser configurations. It dynamically imports the required backend package and sets up the necessary attributes for scraping.

Chunk 386
The class provides methods for asynchronous scraping using Playwright's async API, lazy loading of content from URLs, and asynchronous lazy loading for improved performance. The ascrape_playwright method asynchronously scrapes content from a given

Chunk 387
scrapes content from a given URL using Playwright, while the lazy_load method lazily loads text content from URLs one at a time. The alazy_load method asynchronously loads text content from URLs using asyncio for concurrent scraping.

Chunk 388
In the calling situation within the project, the ChromiumLoader class is utilized in a node logic execution to fetch HTML content from specified URLs. Depending on the input keys and sources, the class instance is created with the appropriate

Chunk 389
created with the appropriate configurations to scrape HTML content. The scraped content is then processed and updated in the state along with metadata like source URLs, links, and images.

Chunk 390
Note:
Developers using the ChromiumLoader class should ensure the required backend package is installed to avoid ImportError. Additionally, proper handling of exceptions during scraping should be implemented to manage errors effectively.

Chunk 391
Output Example:
A possible output of the ChromiumLoader class could be a Document object containing the scraped HTML content encapsulated with metadata such as the source URL.  
FunctionDef init(self, urls)

Chunk 392
init: The function of init is to initialize the loader with a list of URL paths.  
parameters:
- self: The instance of the class.
- urls: A list of strings representing the URLs to scrape content from.

Chunk 393
- backend: A string indicating the web driver backend library (default: 'playwright').
- headless: A boolean specifying whether to run the browser in headless mode (default: True).

Chunk 394
- proxy: An optional Proxy object containing proxy information (default: None).
- load_state: A string representing the load state (default: 'domcontentloaded').
- **kwargs: Additional keyword arguments in the form of a dictionary.

Chunk 395
Code Description:

Chunk 396
The init function initializes the ChromiumLoader with the provided parameters. It sets the backend, browser configuration, headless mode, proxy settings, URLs to scrape, and the load state. If the required backend package is not installed, an

Chunk 397
package is not installed, an ImportError is raised. The function dynamically imports the specified backend library using the dynamic_import function. This allows the ChromiumLoader to adapt to different backend configurations based on user

Chunk 398
configurations based on user preferences. The proxy information is parsed or searched using the parse_or_search_proxy function based on the provided criteria.

Chunk 399
Note:
Developers should ensure that the necessary parameters are provided when initializing the ChromiumLoader object. Additionally, handle any ImportError exceptions that may occur if the required backend package is not installed.

Chunk 400
FunctionDef ascrape_playwright(self, url)  
ascrape_playwright: The function of ascrape_playwright is to asynchronously scrape the content of a given URL using Playwright's async API.  
parameters:
- url (str): The URL to scrape.  
Code Description:

Chunk 401
The ascrape_playwright function utilizes Playwright's async API to scrape the HTML content of a specified URL. It first sets up a Playwright environment, launches a Chromium browser, creates a new browsing context, navigates to the provided URL,

Chunk 402
to the provided URL, waits for the page to load, retrieves the HTML content, and finally closes the browser. If any exceptions occur during the process, an error message is returned instead of the HTML content.

Chunk 403
Note:
- This function requires the Playwright and undetected_playwright libraries to be installed.
- Ensure that the necessary dependencies are met before using this function.  
Output Example:
"<!DOCTYPE html>......"  
FunctionDef lazy_load(self)

Chunk 404
FunctionDef lazy_load(self)  
lazy_load: The function of lazy_load is to lazily load text content from the provided URLs, yielding Documents one at a time as they are scraped.  
parameters:

Chunk 405
parameters:
- No external parameters are passed explicitly to this function. However, it relies on the instance variables set within the class.  
Code Description:

Chunk 406
The lazy_load function iterates through the URLs provided in the class instance. It dynamically selects a scraping function based on the backend specified. It then asynchronously scrapes the HTML content from each URL using the selected scraping

Chunk 407
using the selected scraping function. For each URL, it creates a metadata dictionary with the source URL and yields a Document object containing the scraped HTML content and metadata.

Chunk 408
Note:
- This function utilizes asynchronous programming with asyncio to scrape content from multiple URLs efficiently.
- Ensure that the backend specified in the class instance corresponds to a valid scraping function.  
Output Example:

Chunk 409
Output Example:
A possible output from this function could be:
Document(page_content="...", metadata={"source": "https://example.com"})  
FunctionDef alazy_load(self)

Chunk 410
alazy_load: The function of alazy_load is to asynchronously load text content from the provided URLs.  
parameters:
- self: The instance of the class.  
Code Description:

Chunk 411
This method uses asyncio to scrape content from multiple URLs concurrently. It initiates the scraping process for all URLs simultaneously, improving performance through asynchronous requests. Each Document object is yielded as soon as its content is

Chunk 412
as soon as its content is available, containing the scraped content along with the source URL as metadata.

Chunk 413
The function first retrieves the scraping function based on the backend specified. It then creates tasks for scraping each URL using the scraping function. By utilizing asyncio.gather, it awaits the completion of all tasks. For each URL and its

Chunk 414
tasks. For each URL and its corresponding scraped content, a Document object is created with metadata containing the source URL. Finally, the function yields the Document objects one by one.

Chunk 415
Note:
- This function is designed to efficiently scrape content from multiple URLs concurrently using asyncio.
- Ensure that the backend attribute is correctly set before calling this function to match the scraping function.

Chunk 416
ClassDef AbstractGraph  
An unknown error occurred while generating this documentation after many tries.  
FunctionDef init(self, prompt, config, source, schema)

Chunk 417
init: The function of init is to initialize an instance of the AbstractGraph class with the provided parameters.  
parameters:
- prompt (str): The prompt string for the graph.
- config (dict): Configuration parameters for the graph.

Chunk 418
- source (Optional[str]): Optional source string for the graph. Defaults to None.
- schema (Optional[BaseModel]): Optional schema for the graph. Defaults to None.  
Code Description:

Chunk 419
The init function of the AbstractGraph class initializes an instance of the class with the provided parameters. It assigns the prompt, source, config, and schema values to the corresponding attributes of the instance. Additionally, it creates and

Chunk 420
Additionally, it creates and assigns values to other attributes such as llm_model, embedder_model, verbose, headless, loader_kwargs, cache_path, graph, final_state, and execution_info.

Chunk 421
The function first assigns the prompt, source, config, and schema parameters to the corresponding attributes of the instance. It then calls the _create_llm function to create an instance of the large language model (llm_model) based on the llm

Chunk 422
(llm_model) based on the llm configuration provided in the config parameter. The _create_llm function handles the instantiation of different language model classes based on the model name specified in the llm configuration.

Chunk 423
Next, the function checks if the "embeddings" key is present in the config dictionary. If it is not present, it calls the _create_default_embedder function to create an instance of the embedding model (embedder_model) based on the llm configuration.

Chunk 424
on the llm configuration. The _create_default_embedder function determines the type of language model being used and creates the corresponding embedding model client.

Chunk 425
The function then sets the verbose and headless attributes based on the values in the config dictionary. If the config dictionary is None, the verbose attribute is set to False and the headless attribute is set to True. Otherwise, the verbose

Chunk 426
True. Otherwise, the verbose attribute is set to the value of the "verbose" key in the config dictionary, and the headless attribute is set to the value of the "headless" key in the config dictionary.

Chunk 427
The loader_kwargs attribute is set to the value of the "loader_kwargs" key in the config dictionary. If the "loader_kwargs" key is not present, an empty dictionary is assigned to the loader_kwargs attribute.

Chunk 428
The cache_path attribute is set to the value of the "cache_path" key in the config dictionary. If the "cache_path" key is not present, the cache_path attribute is set to False.

Chunk 429
Next, the function calls the _create_graph function to create the graph representation. The _create_graph function is an abstract method defined in the AbstractGraph class, which needs to be implemented in subclasses to provide specific graph

Chunk 430
to provide specific graph creation logic.

Chunk 431
The final_state and execution_info attributes are initialized to None.

Chunk 432
After creating the graph, the function sets the common configuration parameters for the graph by calling the set_common_params function. It constructs a dictionary called common_params containing various common configuration settings such as

Chunk 433
settings such as headless, verbose, loader_kwargs, llm_model, embedder_model, and cache_path. These parameters are passed to the set_common_params function with the overwrite flag set to True, ensuring that the common configuration is applied

Chunk 434
configuration is applied uniformly across all nodes in the graph.

Chunk 435
Finally, the function sets the burr configuration parameters if the "burr_kwargs" key is present in the config dictionary. It checks if the "app_instance_id" key is not present in the burr_kwargs dictionary and sets a random UUID as the value for

Chunk 436
random UUID as the value for the "app_instance_id" key to avoid conflicts. It then assigns the burr_kwargs dictionary to the burr_config attribute of the graph.

Chunk 437
Note:
- Developers can use the init function to initialize an instance of the AbstractGraph class with the provided parameters.

Chunk 438
- The function handles the initialization of various attributes and the creation of the language model and embedding model instances.

Chunk 439
- The set_common_params function is used to set common configuration parameters for the graph, ensuring uniform application across all nodes.

Chunk 440
- The _create_graph function is an abstract method that needs to be implemented in subclasses to provide specific graph creation logic.
- The burr configuration parameters are set if the "burr_kwargs" key is present in the config dictionary.

Chunk 441
FunctionDef set_common_params(self, params, overwrite)  
set_common_params: The function of set_common_params is to pass common parameters and their values to every node in the graph unless otherwise defined in the graph.  
parameters:

Chunk 442
parameters:
- params (dict): Common parameters and their values.
- overwrite (bool): Flag indicating whether to overwrite existing parameters in the nodes.  
Code Description:

Chunk 443
The set_common_params function iterates through each node in the graph and updates their configuration with the common parameters provided. If the overwrite flag is set to True, existing parameters in the nodes will be overwritten with the new

Chunk 444
be overwritten with the new values. This function ensures that common parameters are uniformly applied across all nodes in the graph unless explicitly defined otherwise.

Chunk 445
Note:

Chunk 446
Developers can utilize the set_common_params function to streamline the application of common parameters across all nodes in the graph, providing a centralized approach to configuration management. The overwrite flag offers flexibility in updating

Chunk 447
flexibility in updating existing parameters in the nodes.

Chunk 448
FunctionDef _create_llm(self, llm_config, chat)  
_create_llm: The function of _create_llm is to create a large language model instance based on the configuration provided.  
Parameters:

Chunk 449
Parameters:
- llm_config (dict): Configuration parameters for the language model.  
Code Description:

Chunk 450
The _create_llm function takes in a dictionary parameter, llm_config, which contains the configuration parameters for the language model. It first initializes a dictionary, llm_defaults, with default values for the temperature and streaming

Chunk 451
the temperature and streaming parameters. Then, it merges the llm_defaults dictionary with the llm_config dictionary using the ** operator to create the llm_params dictionary.

Chunk 452
The function checks if the "model_instance" key is present in the llm_params dictionary. If it is, it returns the value associated with the "model_instance" key, which is expected to be a model instance.

Chunk 453
If the "model_instance" key is not present, the function proceeds to instantiate the language model based on the model name specified in the llm_params dictionary. It checks if the model name contains "gpt-" and if so, it retrieves the corresponding

Chunk 454
retrieves the corresponding model token from the models_tokens dictionary under the "openai" key. If the model name contains "oneapi", it extracts the model name after the last dash and retrieves the corresponding model token from the models_tokens

Chunk 455
token from the models_tokens dictionary under the "oneapi" key. Similarly, for "azure" and "gemini" model names, it retrieves the model tokens from the models_tokens dictionary under the respective keys. If the model name starts with "claude", it

Chunk 456
name starts with "claude", it retrieves the model token from the models_tokens dictionary under the "claude" key. If the model name contains "ollama", it extracts the model name after "ollama/" and checks if it exists in the models_tokens dictionary

Chunk 457
the models_tokens dictionary under the "ollama" key. If it does, it retrieves the corresponding model token, otherwise, it sets the model token to the default value of 8192. For "hugging_face", "groq", "bedrock", "claude-3-", "deepseek", and "ernie"

Chunk 458
"deepseek", and "ernie" model names, it retrieves the model tokens from the models_tokens dictionary under the respective keys.

Chunk 459
If none of the above conditions are met, the function raises a ValueError with the message "Model provided by the configuration not supported".

Chunk 460
Finally, the function returns an instance of the corresponding language model class (e.g., OpenAI, OneApi, AzureOpenAI, Gemini, Anthropic, Ollama, HuggingFace, Groq, Bedrock, DeepSeek, Ernie) with the llm_params as the configuration parameters.

Chunk 461
Note:

Chunk 462
Developers can use the _create_llm function to create instances of different language models based on the provided configuration parameters. The function handles the instantiation of the language model classes and retrieves the corresponding model

Chunk 463
the corresponding model tokens from the models_tokens dictionary. It provides flexibility in choosing and configuring the language model for different use cases within the project.

Chunk 464
Output Example:
An instance of the language model client.  
FunctionDef _create_default_embedder(self, llm_config)

Chunk 465
_create_default_embedder: The function of _create_default_embedder is to create an embedding model instance based on the chosen language model.  
parameters:
- self (object): The instance of the AbstractGraph class.

Chunk 466
- llm_config (dict, optional): Configuration parameters for the language model. Defaults to None.  
Code Description:

Chunk 467
The _create_default_embedder function is a method of the AbstractGraph class. It is responsible for creating an instance of the embedding model client based on the chosen language model. The function takes an optional llm_config parameter, which is

Chunk 468
parameter, which is a dictionary containing the configuration parameters for the language model.

Chunk 469
The function first checks the type of the llm_model attribute of the AbstractGraph instance to determine the type of language model being used. It then creates and returns an instance of the corresponding embedding model client based on the type of

Chunk 470
client based on the type of the language model.

Chunk 471
If the llm_model is an instance of the Gemini class, the function creates an instance of the GoogleGenerativeAIEmbeddings class, passing the llm_config["api_key"] and "models/embedding-001" as parameters.

Chunk 472
If the llm_model is an instance of the OpenAI class, the function creates an instance of the OpenAIEmbeddings class, passing the llm_model.openai_api_key and llm_model.openai_api_base as parameters.

Chunk 473
If the llm_model is an instance of the DeepSeek class, the function creates an instance of the OpenAIEmbeddings class, passing the llm_model.openai_api_key as a parameter.

Chunk 474
If the llm_model is an instance of the AzureOpenAIEmbeddings class, the function returns the llm_model itself.  
If the llm_model is an instance of the AzureOpenAI class, the function creates an instance of the AzureOpenAIEmbeddings class.

Chunk 475
If the llm_model is an instance of the Ollama class, the function creates an instance of the OllamaEmbeddings class, passing the parameters from the llm_model._lc_kwargs dictionary after removing the "streaming" and "temperature" keys.

Chunk 476
If the llm_model is an instance of the HuggingFace class, the function creates an instance of the HuggingFaceHubEmbeddings class, passing the llm_model.model as a parameter.

Chunk 477
If the llm_model is an instance of the Bedrock class, the function creates an instance of the BedrockEmbeddings class, passing None as the client and llm_model.model_id as the model_id.

Chunk 478
If the llm_model is not an instance of any of the supported classes, the function raises a ValueError with the message "Embedding Model missing or not supported".  
Note:

Chunk 479
Developers can use the _create_default_embedder function to create an embedding model instance based on the chosen language model. It provides a convenient way to instantiate the appropriate embedding model client based on the type of language model

Chunk 480
on the type of language model being used in the AbstractGraph class.

Chunk 481
Output Example:
An instance of the embedding model client.  
FunctionDef _create_embedder(self, embedder_config)  
_create_embedder: The function of _create_embedder is to create an embedding model instance based on the provided configuration.

Chunk 482
parameters:
- embedder_config (dict): Configuration parameters for the embedding model.  
Code Description:

Chunk 483
The _create_embedder function takes a dictionary of embedder_config as input and returns an instance of the embedding model client based on the specified model in the configuration. It supports various embedding models such as OpenAI, Azure, Ollama,

Chunk 484
as OpenAI, Azure, Ollama, Hugging Face, Google Generative AI, and Bedrock. If the provided model is not supported, the function raises a KeyError or ValueError accordingly.

Chunk 485
In the calling object AbstractGraph/init, the _create_embedder function is utilized to initialize the embedder_model attribute based on the configuration provided. It checks if the "embeddings" key is present in the config dictionary and calls

Chunk 486
config dictionary and calls _create_embedder with the corresponding configuration. The embedder_model instance is then used as a common parameter for setting up the graph.

Chunk 487
Note:
Developers should ensure that the embedder_config dictionary contains the necessary parameters for the desired embedding model to avoid errors during model instantiation.  
Output Example:
An instance of the embedding model client.

Chunk 488
FunctionDef get_state(self, key)  
get_state: The function of get_state is to retrieve the final state of the graph.  
parameters:
- key (str, optional): The key of the final state to retrieve.  
Code Description:

Chunk 489
Code Description:
The get_state function retrieves the final state of the graph. If a key is provided, it returns the final state corresponding to that key. Otherwise, it returns the entire final state of the graph.

Chunk 490
This function is a method of the AbstractGraph class in the abstract_graph.py module under the graphs package in the scrapegraphai project.  
Relationship with Callers:

Chunk 491
- This function is called by objects in the deep_scraper_ernie.py and deep_scraper_openai.py files in the examples directory of the project. These callers likely use the get_state function to access and utilize the final state of the graph for

Chunk 492
final state of the graph for further processing or analysis.

Chunk 493
Note:
- Ensure that the final_state attribute of the graph object is properly populated before calling this function to avoid potential errors.  
Output Example:
python
{
'node1': 'value1',
'node2': 'value2',
...
}

Chunk 494
'node2': 'value2',
...
}  
FunctionDef append_node(self, node)  
append_node: The function of append_node is to add a node to the graph.
parameters:
- node (BaseNode): The node to add to the graph.  
Code Description:

Chunk 495
Code Description:
The append_node function adds a node to the graph by taking a BaseNode object as a parameter. It appends the provided node to the graph.

Chunk 496
This function is a method of the AbstractGraph class in the abstract_graph.py file under the graphs module of the scrapegraphai project. It is responsible for adding nodes to the graph structure.  
Note:

Chunk 497
Developers can utilize this function to dynamically add nodes to the graph structure, enabling the construction and modification of the graph during runtime. The append_node function plays a crucial role in expanding the graph's nodes, allowing for

Chunk 498
graph's nodes, allowing for flexible graph manipulation within the project.

Chunk 499
FunctionDef get_execution_info(self)  
get_execution_info: The function of get_execution_info is to return the execution information of the graph.  
parameters:
- self: The instance of the class.  
Code Description:

Chunk 500
Code Description:
The get_execution_info function is a method of the AbstractGraph class that retrieves and returns the execution information of the graph. It simply returns the value stored in the execution_info attribute of the class instance.

Chunk 501
This function is called within the AbstractGraph class to provide access to the execution information of the graph. It is a simple and straightforward method that allows other parts of the codebase to retrieve this essential information when needed.

Chunk 502
information when needed.

Chunk 503
Note:
Developers can use this function to access the execution information of the graph stored in the execution_info attribute of the AbstractGraph class.  
Output Example:
python
{
'start_time': '2022-01-01 08:00:00',

Chunk 504
'end_time': '2022-01-01 09:00:00',
'status': 'completed'
}  
FunctionDef _create_graph(self)  
_create_graph: The function of _create_graph is to serve as an abstract method for creating a graph representation.  
Parameters:
- None

Chunk 505
Parameters:
- None  
Code Description:

Chunk 506
The _create_graph function is defined as an abstract method within the AbstractGraph class. It does not contain any implementation details but rather serves as a placeholder for creating a graph representation. This function is intended to be

Chunk 507
function is intended to be implemented in subclasses of AbstractGraph to provide specific graph creation logic tailored to different graph types or requirements.

Chunk 508
In the calling object AbstractGraph/init, the _create_graph function is invoked to create the graph representation. This initialization process involves setting up various configuration parameters, creating specific models such as llm_model and

Chunk 509
models such as llm_model and embedder_model, and finally, calling _create_graph to generate the graph itself. Additionally, common configuration parameters are set based on the provided config values, and specific burr configuration settings are

Chunk 510
configuration settings are handled if applicable.

Chunk 511
Note:
Developers extending the AbstractGraph class should override the _create_graph method in their subclasses to define the actual graph creation logic based on the requirements of their specific graph implementations.  
FunctionDef run(self)

Chunk 512
FunctionDef run(self)  
run: The function of run is to serve as an abstract method to execute the graph and return the result.  
parameters:
- No parameters are passed to this function.  
Code Description:

Chunk 513
The run function is defined as an abstract method within the AbstractGraph class. It is intended to be implemented by subclasses to execute the graph and provide a result. As an abstract method, it does not contain any implementation details and is

Chunk 514
implementation details and is expected to be overridden by subclasses with specific functionality tailored to their graph implementations.

Chunk 515
Note:
Developers need to implement the run function in subclasses of AbstractGraph to define the specific behavior of executing the graph and returning the result.  
Output Example:
N/A

Chunk 516
ClassDef BaseGraph  
BaseGraph: The BaseGraph class manages the execution flow of a graph composed of interconnected nodes.  
Attributes:
- nodes (list): A list of node instances that will be part of the graph.

Chunk 517
- edges (list): A list of tuples representing the directed edges of the graph.
- entry_point (str): The name of the entry point node from which the graph execution begins.  
Args:

Chunk 518
Args:
- nodes (iterable): An iterable of node instances that will be part of the graph.
- edges (iterable): An iterable of tuples where each tuple represents a directed edge in the graph.

Chunk 519
- entry_point (BaseNode): The node instance that represents the entry point of the graph.
- use_burr (bool): A flag indicating whether to use BurrBridge for execution. Default is False.

Chunk 520
- burr_config (dict): Configuration options for BurrBridge. Default is None.
- graph_name (str): The name of the graph. Default is "Custom".  
Raises:
- Warning: If the entry point node is not the first node in the list.  
Example:
python
BaseGraph(

Chunk 521
Example:
python
BaseGraph(
nodes=[
fetch_node,
parse_node,
rag_node,
generate_answer_node,
],
edges=[
(fetch_node, parse_node),
(parse_node, rag_node),
(rag_node, generate_answer_node)
],
entry_point=fetch_node,
use_burr=True,

Chunk 522
use_burr=True,
burr_config={"app_instance_id": "example-instance"}
)  
Code Description:

Chunk 523
The BaseGraph class is responsible for managing the execution flow of a graph. It takes a list of node instances and a list of edges as input, along with an entry point node. The nodes represent the individual components of the graph, while the

Chunk 524
of the graph, while the edges define the directed connections between the nodes.

Chunk 525
During initialization, the edges are processed to create a dictionary representation for efficient lookup. The entry point node is also validated to ensure it is the first node in the list. If not, a warning is raised.

Chunk 526
The class provides a method _execute_standard for executing the graph using the standard method. This method traverses the nodes starting from the entry point and executes each node in sequence. The execution time and other execution information are

Chunk 527
execution information are tracked and stored in a list.

Chunk 528
The execute method is the main entry point for executing the graph. It checks if BurrBridge should be used for execution based on the use_burr flag. If BurrBridge is enabled, it creates an instance of BurrBridge and delegates the execution to it.

Chunk 529
the execution to it. Otherwise, it calls the _execute_standard method.

Chunk 530
The append_node method allows adding a new node to the graph. It checks if the node name already exists in the graph and raises an exception if it does. It then adds the new node to the list of nodes, updates the edges to connect the last node to

Chunk 531
to connect the last node to the new node, and updates the edges dictionary.

Chunk 532
Note: The BaseGraph class relies on the presence of other classes such as FetchNode, ParseNode, RAGNode, and GenerateAnswerNode, which are not provided in the code snippet. The execution logic and behavior of the graph depend on the implementation

Chunk 533
depend on the implementation of these node classes.

Chunk 534
Output Example: None  
FunctionDef init(self, nodes, edges, entry_point, use_burr, burr_config, graph_name)  
init: The function of init is to initialize a BaseGraph object with the provided nodes, edges, entry point, and optional configurations.

Chunk 535
parameters:
- nodes (list): A list of nodes in the graph.
- edges (list): A list of tuples representing the directed edges between nodes.
- entry_point (str): The name of the entry point node in the graph.

Chunk 536
- use_burr (bool, optional): A boolean flag indicating whether to use Burr configuration. Default is False.
- burr_config (dict, optional): A dictionary containing Burr configuration settings. Default is None.

Chunk 537
- graph_name (str, optional): The name of the graph. Default is "Custom".  
Code Description:

Chunk 538
The init function initializes a BaseGraph object by setting the provided nodes, raw edges, edges created using the _create_edges method, entry point, graph name, and initial state. It also checks if the entry point node matches the first node in the

Chunk 539
matches the first node in the list and issues a warning if they differ. Additionally, it handles Burr configuration by setting the use_burr flag and Burr configuration settings.

Chunk 540
The function utilizes the _create_edges method to generate a dictionary of edges from the raw edge data. This dictionary establishes connections between nodes in the graph based on the directed edges provided. The entry point node is determined by

Chunk 541
point node is determined by the node_name attribute of the entry point node.

Chunk 542
Note:

Chunk 543
Ensure that the nodes and edges are provided in the correct format. The entry point node should match the node name of the first node in the list to avoid warnings. Adjust Burr configuration settings as needed using the use_burr flag and burr_config

Chunk 544
use_burr flag and burr_config dictionary.

Chunk 545
FunctionDef _create_edges(self, edges)  
_create_edges: The function of _create_edges is to create a dictionary of edges from the given iterable of tuples.  
parameters:
- edges (iterable): An iterable of tuples representing the directed edges.

Chunk 546
Code Description:

Chunk 547
The _create_edges function takes an iterable of tuples as input, where each tuple represents a directed edge from one node to another. It then iterates through the tuples, creating a dictionary where the keys are the from-nodes and the values are

Chunk 548
from-nodes and the values are the to-nodes. The function returns this dictionary of edges.

Chunk 549
In the calling object BaseGraph's init method, _create_edges is used to create a dictionary of edges from the raw edge data provided during the initialization of the graph object. This dictionary is then used to establish the connections between

Chunk 550
the connections between nodes in the graph. Additionally, the entry point node is set based on the node_name attribute of the entry point node provided during initialization.

Chunk 551
In the append_node method of BaseGraph, _create_edges is called again to update the edges when a new node is added to the graph. This ensures that the connections between nodes are correctly maintained after adding a new node.  
Note:

Chunk 552
Note:
Ensure that the input edges are in the correct format of an iterable of tuples, where each tuple represents a directed edge from one node to another.  
Output Example:
{
'node1': 'node2',
'node2': 'node3',
'node3': 'node4',
...
}

Chunk 553
'node3': 'node4',
...
}  
FunctionDef _execute_standard(self, initial_state)  
_execute_standard: The function of _execute_standard is to execute the graph by traversing nodes starting from the entry point using the standard method.  
parameters:

Chunk 554
parameters:
- initial_state (dict): The initial state to pass to the entry point node.  
Code Description:

Chunk 555
The _execute_standard function initiates the graph execution process by traversing nodes from the entry point. It iterates through each node, executes its functionality, and tracks relevant execution information. The function handles error logging,

Chunk 556
handles error logging, captures telemetry data, and ensures the proper flow of the graph execution. Additionally, it interacts with external functions like log_graph_execution to log essential details of the graph execution process.

Chunk 557
In the project structure, _execute_standard is a crucial method within the BaseGraph class, responsible for orchestrating the standard execution flow of the graph. It interacts with various nodes, captures execution information, and logs telemetry

Chunk 558
and logs telemetry data using the log_graph_execution function. This function plays a vital role in ensuring the successful execution and monitoring of graph operations.

Chunk 559
Note:
- Ensure accurate initialization of the initial_state parameter to kickstart the graph execution process effectively.
- Handle exceptions carefully to maintain the integrity of the graph execution and telemetry logging mechanisms.

Chunk 560
Output Example:
{
"final_state": {...},
"execution_info": [
{
"node_name": "Node1",
"total_tokens": 100,
"prompt_tokens": 80,
"completion_tokens": 20,
"successful_requests": 5,
"total_cost_USD": 10.0,
"exec_time": 0.5
},
{
"node_name": "Node2",

Chunk 561
},
{
"node_name": "Node2",
"total_tokens": 150,
"prompt_tokens": 120,
"completion_tokens": 30,
"successful_requests": 7,
"total_cost_USD": 15.0,
"exec_time": 0.8
},
...
{
"node_name": "TOTAL RESULT",
"total_tokens": 250,
"prompt_tokens": 200,

Chunk 562
"prompt_tokens": 200,
"completion_tokens": 50,
"successful_requests": 12,
"total_cost_USD": 25.0,
"exec_time": 1.3
}
]
}  
FunctionDef execute(self, initial_state)

Chunk 563
execute: The function of execute is to execute the graph by either using BurrBridge or the standard method.  
parameters:
- initial_state (dict): The initial state to pass to the entry point node.  
Code Description:

Chunk 564
The execute function is a crucial method within the BaseGraph class, responsible for executing the graph by either using BurrBridge or the standard method. It takes an initial_state parameter, which represents the initial state to pass to the entry

Chunk 565
state to pass to the entry point node.

Chunk 566
The function begins by assigning the initial_state parameter to the self.initial_state attribute. It then checks if the use_burr flag is set to True. If so, it imports the BurrBridge class from the ..integrations module and creates an instance of

Chunk 567
and creates an instance of it, passing in the current object (self) and the burr_config attribute. The execute method of the BurrBridge instance is then called, passing in the initial_state. The result of the BurrBridge execution is returned as a

Chunk 568
execution is returned as a tuple containing the "_state" key from the result and an empty list.

Chunk 569
If the use_burr flag is set to False, the function calls the _execute_standard method of the current object, passing in the initial_state. The result of the _execute_standard method is returned.  
Note:

Chunk 570
Note:
- When using BurrBridge, ensure that the burr_config attribute is properly configured to integrate Burr functionality into the graph execution process.

Chunk 571
- When using the standard method, ensure that the _execute_standard method is implemented correctly to execute the graph using the standard execution flow.  
Output Example:
{
"_state": {...},
"execution_info": []
}

Chunk 572
"execution_info": []
}  
FunctionDef append_node(self, node)  
append_node: The function of append_node is to add a node to the graph.  
parameters:
- node (BaseNode): The node instance to add to the graph.  
Code Description:

Chunk 573
The append_node function adds a node to the graph. It first checks if the node name already exists in the graph and raises a ValueError if it does. Then, it gets the last node in the list, adds an edge connecting the last node to the new node,

Chunk 574
last node to the new node, appends the new node to the list of nodes, and updates the edges connecting the last node to the new node using the _create_edges function.

Chunk 575
In the BaseGraph's init method, the _create_edges function is used to create a dictionary of edges from the raw edge data provided during the initialization of the graph object. This dictionary establishes connections between nodes in the graph.

Chunk 576
When a new node is added to the graph using the append_node method, the _create_edges function is called to update the edges, ensuring that the connections between nodes are correctly maintained after adding the new node.  
Note:

Chunk 577
Note:
Ensure that the node being added is not already present in the graph to avoid raising a ValueError.

Chunk 578
ClassDef CSVScraperGraph  
CSVScraperGraph: The CSVScraperGraph class represents a smart web scraping tool that automates the process of extracting information from web pages using a natural language model to interpret and answer prompts.

Chunk 579
Attributes:
- prompt (str): The prompt for the graph.
- source (str): The source of the graph.
- config (dict): Configuration parameters for the graph.
- schema (Optional[BaseModel]): The schema for the graph output.

Chunk 580
- input_key (str): The key for the input source.
- graph (BaseGraph): The graph representation of the web scraping workflow.  
Code Description:

Chunk 581
The CSVScraperGraph class is a subclass of the AbstractGraph class and inherits its attributes and methods. It overrides the _create_graph() method to create a graph representation of the web scraping workflow specific to CSV scraping.

Chunk 582
The init() method initializes the CSVScraperGraph object with a prompt, source, configuration, and optional schema. It calls the super() method to initialize the AbstractGraph superclass with the prompt, configuration, source, and schema. It also

Chunk 583
source, and schema. It also sets the input_key attribute based on the source file extension.

Chunk 584
The _create_graph() method creates the graph representation of the web scraping workflow. It creates three nodes: FetchNode, RAGNode, and GenerateAnswerCSVNode. The FetchNode represents fetching data from the CSV source, the RAGNode represents

Chunk 585
the RAGNode represents processing the user prompt and the fetched data using the RAG (Retrieval-Augmented Generation) model, and the GenerateAnswerCSVNode represents generating the answer to the prompt using the RAG model and the schema. The method

Chunk 586
and the schema. The method connects these nodes with edges and sets the entry point and graph name.

Chunk 587
The run() method executes the web scraping process by executing the graph and returns the answer to the prompt. It creates an inputs dictionary with the user_prompt and input_key as keys and the prompt and source as values. It then calls the graph's

Chunk 588
It then calls the graph's execute() method with the inputs dictionary and assigns the final_state and execution_info attributes. Finally, it returns the answer from the final_state or "No answer found." if the answer is not present.

Chunk 589
Note: The CSVScraperGraph class is designed to work with the AbstractGraph class and requires the implementation of the _create_graph() and run() methods.  
Output Example:
```python
prompt = "What is the capital of France?"
source = "data.csv"

Chunk 590
source = "data.csv"
config = {"llm": {"model": "gpt-3.5-turbo"}}
schema = None

Chunk 591
csv_scraper = CSVScraperGraph(prompt, source, config, schema)
answer = csv_scraper.run()

print(answer)

Output: "Paris"

Chunk 592
```  
FunctionDef init(self, prompt, source, config, schema)  
init: The function of init is to initialize the CSVScraperGraph with a prompt, source, configuration, and optional schema.  
parameters:

Chunk 593
parameters:
- prompt: A string representing the prompt for the CSVScraperGraph.
- source: A string indicating the data source for the CSVScraperGraph.
- config: A dictionary containing configuration settings for the CSVScraperGraph.

Chunk 594
- schema: An optional parameter of type BaseModel representing the schema for the CSV data.  
Code Description:

Chunk 595
The init function initializes the CSVScraperGraph object by calling the constructor of its superclass with the provided prompt, configuration, source, and schema parameters. It then sets the input_key attribute based on the source parameter,

Chunk 596
on the source parameter, assigning "csv" if the source ends with "csv", otherwise "csv_dir".

Chunk 597
Note:
- Ensure that the prompt, source, and config parameters are correctly provided when initializing a CSVScraperGraph object.
- If a schema is required, it can be passed as an optional parameter during initialization.

Chunk 598
FunctionDef _create_graph(self)  
_create_graph: The function of _create_graph is to create the graph of nodes representing the workflow for web scraping.  
Parameters:
- self: The instance of the CSVScraperGraph class.  
Code Description:

Chunk 599
Code Description:
The _create_graph function is responsible for creating the graph of nodes that represents the workflow for web scraping. It initializes and configures three different types of nodes: FetchNode, RAGNode, and GenerateAnswerCSVNode.

Chunk 600
The FetchNode is responsible for fetching the HTML content of a specified URL and updating the graph's state with this content. It takes the input from the "csv" and "csv_dir" keys in the state and outputs the fetched document to the "doc" key.

Chunk 601
The RAGNode is responsible for compressing the input tokens and storing the document in a vector database for retrieval. It takes the input from the "user_prompt" and "doc" keys in the state and outputs the relevant chunks of the document to the

Chunk 602
chunks of the document to the "relevant_chunks" key.

Chunk 603
The GenerateAnswerCSVNode is responsible for generating an answer using a language model based on the user's input and the content extracted from a webpage. It takes the input from the "user_prompt" and "relevant_chunks" keys in the state and

Chunk 604
keys in the state and outputs the generated answer to the "answer" key.

Chunk 605
The function then creates an instance of the BaseGraph class and initializes it with the nodes and edges of the graph. The fetch_node is set as the entry point of the graph. Finally, the function returns the created BaseGraph instance.

Chunk 606
Note: The BaseGraph class manages the execution flow of a graph composed of interconnected nodes. The FetchNode, RAGNode, and GenerateAnswerCSVNode classes are defined in separate files and are not provided in the code snippet.  
Output Example:

Chunk 607
Output Example:
A BaseGraph instance with the specified nodes and edges.  
FunctionDef run(self)  
run: The function of run is to execute the web scraping process and return the answer to the prompt.  
parameters:

Chunk 608
parameters:
- No parameters are passed explicitly to the run function. However, it relies on the attributes self.prompt and self.source.  
Code Description:

Chunk 609
The run function initiates the web scraping process by creating an inputs dictionary with the user's prompt and source data. It then executes the graph by calling the execute method from the graph object, passing the inputs. The final state and

Chunk 610
inputs. The final state and execution information are stored in self.final_state and self.execution_info, respectively. Finally, the function returns the value associated with the "answer" key in the final state dictionary, or "No answer found." if

Chunk 611
or "No answer found." if the key is not present.

Chunk 612
This function is an essential part of the CSVScraperGraph class, responsible for orchestrating the web scraping process and providing the final answer based on the executed graph.  
Note:

Chunk 613
Note:
- Ensure that the prompt and source attributes are properly set before calling the run function to obtain accurate results from the web scraping process.  
Output Example:
{
"answer": "Scraped data result"
}

Chunk 614
ClassDef CSVScraperMultiGraph  
CSVScraperMultiGraph: The CSVScraperMultiGraph class is a scraping pipeline that scrapes a list of URLs and generates answers to a given prompt. It is a subclass of the AbstractGraph class.  
Attributes:

Chunk 615
Attributes:
- prompt (str): The user prompt to search the internet.
- llm_model (dict): The configuration for the language model.
- embedder_model (dict): The configuration for the embedder model.

Chunk 616
- headless (bool): A flag to run the browser in headless mode.
- verbose (bool): A flag to display the execution information.
- model_token (int): The token limit for the language model.  
Args:

Chunk 617
Args:
- prompt (str): The user prompt to search the internet.
- source (List[str]): The source of the graph.
- config (dict): Configuration parameters for the graph.
- schema (Optional[BaseModel]): The schema for the graph output.

Chunk 618
Code Description:
The CSVScraperMultiGraph class is responsible for creating a graph of nodes representing the workflow for web scraping and searching. It inherits from the AbstractGraph class and overrides the _create_graph() and run() methods.

Chunk 619
The _create_graph() method creates a graph instance representing the web scraping and searching workflow. It creates a SmartScraperGraph instance, defines the graph nodes (GraphIteratorNode and MergeAnswersNode), and sets up the edges between the

Chunk 620
sets up the edges between the nodes. The method returns the created graph.

Chunk 621
The run() method executes the web scraping and searching process. It takes the user prompt and source as inputs, executes the graph using the inputs, and returns the answer to the prompt.  
Note:

Chunk 622
Note:
- The CSVScraperMultiGraph class requires a valid user prompt and a list of URLs as input.
- The configuration parameters for the language model and embedder model should be provided in the config dictionary.

Chunk 623
- The class uses the AbstractGraph class to handle common configuration parameters and create the graph instance.  
Output Example:
```python
search_graph = CSVScraperMultiGraph(
"What is Chioggia famous for?",

Chunk 624
["https://example.com/page1", "https://example.com/page2"],
{"llm": {"model": "gpt-3.5-turbo"}},
schema=MySchema
)
result = search_graph.run()
print(result)

Chunk 625
Output: "Chioggia is famous for its picturesque canals and vibrant fish market."

Chunk 626
```  
FunctionDef init(self, prompt, source, config, schema)  
init: The function of init is to initialize the CSVScraperMultiGraph object with the provided prompt, source, configuration, and optional schema.  
parameters:

Chunk 627
parameters:
- prompt: A string representing the prompt for the CSV scraper.
- source: A list of strings containing the data sources to be scraped.
- config: A dictionary containing configuration settings.

Chunk 628
- schema: An optional parameter representing the schema for the data.  
Code Description:

Chunk 629
The init function initializes the CSVScraperMultiGraph object by setting the maximum number of results based on the "max_results" key in the config dictionary. It then checks if all values in the config dictionary are strings. If they are, it

Chunk 630
are strings. If they are, it creates a shallow copy of the config dictionary; otherwise, it creates a deep copy. Finally, it calls the superclass's (presumably BaseModel) init function with the provided prompt, config, source, and schema parameters.

Chunk 631
and schema parameters.

Chunk 632
Note:
- Ensure that the config dictionary contains appropriate values to avoid errors during initialization.
- Understand the difference between shallow copy and deep copy when working with the config dictionary to maintain data integrity.

Chunk 633
FunctionDef _create_graph(self)  
_create_graph: The _create_graph function is responsible for creating a graph of nodes representing the workflow for web scraping and searching.  
Parameters:

Chunk 634
Parameters:
- self: The instance of the CSVScraperMultiGraph class.  
Code Description:

Chunk 635
The _create_graph function initializes and configures the necessary nodes to create a graph representing the web scraping and searching workflow. It creates instances of the FetchNode, MergeAnswersNode, and BaseGraph classes, and connects them with

Chunk 636
and connects them with edges.

Chunk 637
The function first creates an instance of the FetchNode class, which represents fetching data from a CSV source. It takes the input key "csv | csv_dir" and the output key "doc". The node is configured with the node_config dictionary, which contains

Chunk 638
dictionary, which contains the "graph_instance" key pointing to the smart_scraper_instance object.

Chunk 639
Next, the function creates an instance of the MergeAnswersNode class, which represents merging the answers from multiple graph instances into a single answer. It takes the input keys "user_prompt & (relevant_chunks | doc)" and the output key

Chunk 640
| doc)" and the output key "answer". The node is configured with the node_config dictionary, which contains the "llm_model" key pointing to the self.llm_model object and the "schema" key pointing to the self.schema object.

Chunk 641
Finally, the function creates an instance of the BaseGraph class, which represents the overall graph. It takes a list of nodes and edges as arguments. The nodes list contains the previously created fetch_node and merge_answers_node instances. The

Chunk 642
instances. The edges list contains a tuple representing the directed edge between the fetch_node and merge_answers_node. The entry_point is set to the fetch_node, and the graph_name is set to the name of the CSVScraperMultiGraph class.

Chunk 643
The function returns the created BaseGraph instance.

Chunk 644
Note: The _create_graph function relies on the presence of other classes such as FetchNode, MergeAnswersNode, and BaseGraph, which are not provided in the code snippet. The execution logic and behavior of the graph depend on the implementation of

Chunk 645
on the implementation of these node classes.

Chunk 646
Output Example: None  
FunctionDef run(self)  
run: The function of run is to execute the web scraping and searching process and return the answer to the prompt.  
parameters:
- self: The object itself.
- No external parameters.  
Code Description:

Chunk 647
The run function initiates the web scraping and searching process by preparing the inputs with the user prompt and JSON data source. It then calls the execute method of the graph object, passing in the prepared inputs. The final state and execution

Chunk 648
The final state and execution information are stored in the object attributes. Finally, the function returns the answer from the final state or "No answer found" if no answer is present.

Chunk 649
The run function is an essential part of the CSVScraperMultiGraph class, responsible for orchestrating the execution of the graph and handling the result.  
Note:

Chunk 650
Note:
- Ensure that the prompt and source attributes are correctly set before calling the run function.
- Verify that the graph object is properly initialized and configured to execute the desired scraping and searching operations.  
Output Example:

Chunk 651
Output Example:
{
"answer": "Scraped data from the website."
}

Chunk 652
ClassDef DeepScraperGraph

Chunk 653
DeepScraperGraph: The DeepScraperGraph class is a scraping pipeline that automates the process of extracting information from web pages using a natural language model to interpret and answer prompts. It is designed to navigate through links within

Chunk 654
navigate through links within the input webpage to fulfill the task specified in the prompt.

Chunk 655
Attributes:
- prompt (str): The prompt for the graph.
- source (str): The source of the graph.
- config (dict): Configuration parameters for the graph.
- schema (BaseModel): The schema for the graph output.

Chunk 656
- llm_model: An instance of a language model client, configured for generating answers.
- embedder_model: An instance of an embedding model client, configured for generating embeddings.

Chunk 657
- verbose (bool): A flag indicating whether to show print statements during execution.
- headless (bool): A flag indicating whether to run the graph in headless mode.  
Args:
- prompt (str): The prompt for the graph.

Chunk 658
- source (str): The source of the graph.
- config (dict): Configuration parameters for the graph.
- schema (BaseModel): The schema for the graph output.  
Code Description:

Chunk 659
Code Description:
The DeepScraperGraph class extends the AbstractGraph class and implements the _create_graph() and run() methods. It creates a graph of nodes representing the workflow for web scraping n-levels deep.

Chunk 660
The _create_graph() method creates a graph instance by calling the _create_repeated_graph() method. It sets the graph iterator node's "graph_instance" attribute to self, allowing the graph to be repeated for multiple hyperlinks found within the

Chunk 661
hyperlinks found within the input webpage. The method returns the base graph.

Chunk 662
The _create_repeated_graph() method creates a graph that can be repeatedly executed to conduct a search on hyperlinks within the webpage. It defines several nodes including FetchNode, ParseNode, RAGNode, GenerateAnswerNode, SearchLinkNode,

Chunk 663
SearchLinkNode, GraphIteratorNode, and MergeAnswersNode. These nodes represent different steps in the web scraping workflow. The method returns a BaseGraph instance representing the web scraping workflow.

Chunk 664
The run() method executes the scraping process by passing the inputs (user_prompt and source) to the graph's execute() method. It retrieves the final state and execution information from the graph and returns the answer to the prompt.

Chunk 665
Note: The DeepScraperGraph class requires the AbstractGraph class to be defined and imported.  
Output Example:
python
deep_scraper = DeepScraperGraph(
"List me all the job titles and detailed job description.",

Chunk 666
"https://www.google.com/about/careers/applications/jobs/results/?location=Bangalore%20India",
{"llm": {"model": "gpt-3.5-turbo"}}
)
result = deep_scraper.run()  
FunctionDef init(self, prompt, source, config, schema)

Chunk 667
init: The function of init is to initialize the DeepScraperGraph object with the provided prompt, source, configuration, and optional schema.  
parameters:
- prompt: A string representing the prompt for the DeepScraperGraph.

Chunk 668
- source: A string indicating the source of the data.
- config: A dictionary containing configuration settings.
- schema: An optional parameter of type BaseModel representing the schema for the data.  
Code Description:

Chunk 669
In this function, the DeepScraperGraph object is initialized by calling the superclass's constructor with the provided prompt, configuration, source, and schema parameters. Additionally, based on the source string, the input_key attribute is set to

Chunk 670
input_key attribute is set to "url" if the source starts with "http", otherwise it is set to "local_dir".

Chunk 671
Note:
- Ensure that the prompt, source, and config parameters are provided correctly when initializing the DeepScraperGraph object.
- If a schema is required for the data, it can be passed as an optional parameter during initialization.

Chunk 672
- The input_key attribute will be automatically set based on the source provided, either as "url" or "local_dir".  
FunctionDef _create_repeated_graph(self)

Chunk 673
_create_repeated_graph: This function is responsible for creating a graph instance representing the web scraping workflow. It returns a BaseGraph object that contains a series of interconnected nodes representing the different steps of the workflow.

Chunk 674
steps of the workflow.

Chunk 675
Parameters:
- None  
Code Description:

Chunk 676
The _create_repeated_graph function initializes a BaseGraph object and configures it with the necessary nodes and edges to represent the web scraping workflow. It sets up the nodes and edges based on the specific requirements of the workflow.

Chunk 677
The function then creates the edges between the nodes to define the flow of execution. It specifies the connections between the nodes based on the dependencies and data flow between them.

Chunk 678
Finally, the function creates a BaseGraph object and initializes it with the nodes and edges created earlier. It sets the entry point of the graph to be the FetchNode and assigns a unique name to the graph.

Chunk 679
Note: The _create_repeated_graph function is called by the _create_graph function in the DeepScraperGraph class. It is responsible for creating the main graph instance for the web scraping workflow.  
Output Example: None

Chunk 680
Output Example: None  
FunctionDef _create_graph(self)

Chunk 681
_create_graph: The function of _create_graph is to create a graph instance representing the web scraping workflow. It returns a BaseGraph object that contains a series of interconnected nodes representing the different steps of the workflow.

Chunk 682
Parameters:
- None  
Code Description:

Chunk 683
The _create_graph function is responsible for creating a graph instance that represents the web scraping workflow. It starts by calling the _create_repeated_graph function to create a base graph instance. This base graph represents the main workflow

Chunk 684
represents the main workflow of the web scraping process.

Chunk 685
Next, it retrieves the GraphIterator node from the base graph and assigns the current graph instance to its graph_instance attribute. This allows the GraphIterator node to repeat the same graph for multiple hyperlinks found within the input webpage.

Chunk 686
within the input webpage.

Chunk 687
Finally, it returns the base graph instance, which represents the web scraping workflow.  
Note: The _create_graph function is called by the DeepScraperGraph class to create the main graph instance for the web scraping workflow.

Chunk 688
Output Example: None  
FunctionDef run(self)  
run: The function of run is to execute the scraping process and return the answer to the prompt.  
parameters:
- None  
Code Description:

Chunk 689
The run function initiates the scraping process by preparing the inputs with the user prompt and the data source. It then calls the execute method of the graph object, passing in the inputs. The final state and execution information are stored, and

Chunk 690
information are stored, and the function returns the answer retrieved from the final state, defaulting to "No answer found." if no answer is present.

Chunk 691
The run function relies on the execute method from the BaseGraph class to interact with the graph and manage the execution flow. By utilizing the execute method, run ensures the proper execution of the scraping process and retrieval of the answer to

Chunk 692
retrieval of the answer to the prompt.

Chunk 693
Note:
- Ensure that the prompt and source attributes are correctly set before calling the run function to provide the necessary input for the scraping process.  
Output Example:
{
"answer": "Scraped answer content",
"execution_info": []
}

Chunk 694
ClassDef JSONScraperGraph  
JSONScraperGraph: The JSONScraperGraph class defines a scraping pipeline for JSON files.  
Attributes:
- prompt (str): The prompt for the graph.
- source (str): The source of the graph.

Chunk 695
- config (dict): Configuration parameters for the graph.
- schema (BaseModel): The schema for the graph output.
- llm_model: An instance of a language model client, configured for generating answers.

Chunk 696
- embedder_model: An instance of an embedding model client, configured for generating embeddings.
- verbose (bool): A flag indicating whether to show print statements during execution.

Chunk 697
- headless (bool): A flag indicating whether to run the graph in headless mode.  
Args:
- prompt (str): The prompt for the graph.
- source (str): The source of the graph.
- config (dict): Configuration parameters for the graph.

Chunk 698
- schema (BaseModel): The schema for the graph output.  
Code Description:

Chunk 699
Code Description:
The JSONScraperGraph class is a subclass of the AbstractGraph class and represents a scraping pipeline for JSON files. It inherits the attributes and methods from the AbstractGraph class.

Chunk 700
The _create_graph method is implemented to create a graph of nodes representing the workflow for web scraping. It returns a BaseGraph instance representing the web scraping workflow. The graph consists of three nodes: FetchNode, RAGNode, and

Chunk 701
FetchNode, RAGNode, and GenerateAnswerNode. The FetchNode retrieves the JSON data from the source, the RAGNode processes the user prompt and the retrieved data, and the GenerateAnswerNode generates an answer based on the processed data.

Chunk 702
The run method executes the web scraping process and returns the answer to the prompt. It first prepares the inputs for the graph execution, including the user prompt and the JSON data source. Then, it executes the graph using the execute method of

Chunk 703
using the execute method of the graph instance. The final state and execution information are stored in the final_state and execution_info attributes, respectively. Finally, the method returns the answer from the final state, or "No answer found" if

Chunk 704
or "No answer found" if no answer is available.

Chunk 705
Note: The JSONScraperGraph class requires an instance of a language model client and an embedding model client for generating answers and embeddings, respectively. These instances should be provided in the config parameter.  
Output Example:
python

Chunk 706
Output Example:
python
json_scraper = JSONScraperGraph(
"List me all the attractions in Chioggia.",
"data/chioggia.json",
{"llm": {"model": "gpt-3.5-turbo"}}
)
result = json_scraper.run()  
FunctionDef init(self, prompt, source, config, schema)

Chunk 707
init: The function of init is to initialize the JSONScraperGraph object.  
parameters:
- prompt: A string representing the prompt for the JSON scraper.
- source: A string indicating the data source.

Chunk 708
- config: A dictionary containing configuration settings.
- schema: An optional parameter of type BaseModel representing the schema.  
Code Description:

Chunk 709
The init function initializes the JSONScraperGraph object by calling the superclass's constructor with the provided prompt, config, source, and schema parameters. It then determines the input_key based on the source, setting it to "json" if the

Chunk 710
setting it to "json" if the source ends with "json", otherwise setting it to "json_dir".

Chunk 711
Note:
- Ensure that the prompt, source, config, and schema parameters are correctly provided when initializing the JSONScraperGraph object.
- The input_key attribute will be set based on the source provided, either as "json" or "json_dir".

Chunk 712
FunctionDef _create_graph(self)  
_create_graph: Creates the graph of nodes representing the workflow for web scraping.  
Parameters:
- self: The instance of the JSONScraperGraph class.  
Code Description:

Chunk 713
The _create_graph function is responsible for creating the graph of nodes that represents the workflow for web scraping. It initializes and configures three nodes: FetchNode, RAGNode, and GenerateAnswerNode. These nodes are connected through

Chunk 714
nodes are connected through directed edges to define the flow of data and execution.

Chunk 715
The fetch_node is created with the following configuration:
- Input: "json | json_dir"
- Output: ["doc", "link_urls", "img_urls"]  
The rag_node is created with the following configuration:
- Input: "user_prompt & (parsed_doc | doc)"

Chunk 716
- Output: ["relevant_chunks"]
- Node Config:
- "llm_model": The language model used for generating answers.
- "embedder_model": The embedding model used for generating embeddings.

Chunk 717
The generate_answer_node is created with the following configuration:
- Input: "user_prompt & (relevant_chunks | parsed_doc | doc)"
- Output: ["answer"]
- Node Config:
- "llm_model": The language model used for generating answers.

Chunk 718
- "schema": The schema used for parsing the output.  
The nodes are then added to the BaseGraph instance along with the edges that define the connections between them. The fetch_node is set as the entry point of the graph.

Chunk 719
Finally, the BaseGraph instance is returned, representing the web scraping workflow.

Chunk 720
Note: The _create_graph function relies on the presence of other classes such as FetchNode, RAGNode, and GenerateAnswerNode, which are not provided in the code snippet. The execution logic and behavior of the graph depend on the implementation of

Chunk 721
on the implementation of these node classes.

Chunk 722
Output Example: None  
FunctionDef run(self)  
run: The function of run is to execute the web scraping process and return the answer to the prompt.
parameters:
- None

Chunk 723
Code Description: The run function initiates the web scraping process by preparing the necessary inputs based on the user prompt and the data source. It then calls the execute method of the graph object to perform the scraping operation. The final

Chunk 724
scraping operation. The final state and execution information are stored, and the function returns the answer extracted from the final state or a default message if no answer is found.

Chunk 725
This function is a key part of the JSONScraperGraph class, responsible for orchestrating the scraping process and handling the output data.

Chunk 726
Note: Ensure that the prompt and source attributes are correctly set before calling the run function to obtain the desired scraping results.  
Output Example:
{
"answer": "Extracted answer text"
}

Chunk 727
ClassDef JSONScraperMultiGraph  
JSONScraperMultiGraph: JSONScraperMultiGraph is a scraping pipeline that scrapes a list of URLs and generates answers to a given prompt. It is a subclass of the AbstractGraph class.  
Attributes:

Chunk 728
Attributes:
- prompt (str): The user prompt to search the internet.
- llm_model (dict): The configuration for the language model.
- embedder_model (dict): The configuration for the embedder model.

Chunk 729
- headless (bool): A flag to run the browser in headless mode.
- verbose (bool): A flag to display the execution information.
- model_token (int): The token limit for the language model.  
Args:

Chunk 730
Args:
- prompt (str): The user prompt to search the internet.
- source (List[str]): The source of the graph.
- config (dict): Configuration parameters for the graph.
- schema (Optional[BaseModel]): The schema for the graph output.  
Example:
python

Chunk 731
Example:
python
search_graph = MultipleSearchGraph(
"What is Chioggia famous for?",
{"llm": {"model": "gpt-3.5-turbo"}}
)
result = search_graph.run()  
Code Description:

Chunk 732
The JSONScraperMultiGraph class is responsible for creating a graph representation and executing the web scraping and searching process. It inherits from the AbstractGraph class, which provides the scaffolding for creating and executing the graph.

Chunk 733
The class constructor takes in the prompt, source, config, and schema as arguments. The prompt is the user prompt to search the internet, the source is a list of URLs to scrape, the config is a dictionary of configuration parameters, and the schema

Chunk 734
parameters, and the schema is an optional BaseModel for the graph output.

Chunk 735
The class initializes the max_results attribute based on the "max_results" key in the config dictionary. It also creates a copy of the config and schema using the copy and deepcopy functions, respectively.

Chunk 736
The _create_graph method is responsible for creating the graph of nodes representing the workflow for web scraping and searching. It creates an instance of the JSONScraperGraph class, which is used as a node in the graph. The graph nodes are defined

Chunk 737
The graph nodes are defined using the GraphIteratorNode and MergeAnswersNode classes, and the graph is returned as a BaseGraph instance.

Chunk 738
The run method executes the web scraping and searching process. It creates an inputs dictionary with the user_prompt and jsons keys, which correspond to the prompt and source attributes, respectively. The graph is executed with the inputs, and the

Chunk 739
with the inputs, and the final_state and execution_info attributes are updated. The method returns the answer from the final_state dictionary, or "No answer found." if the answer key is not present.

Chunk 740
Note:
- The JSONScraperMultiGraph class requires a valid prompt and a list of URLs as the source to perform web scraping and searching.

Chunk 741
- The configuration parameters llm_model and embedder_model should be properly configured for the language model and embedder model, respectively.

Chunk 742
- The headless and verbose flags can be used to control the browser mode and display of execution information.
- The model_token attribute represents the token limit for the language model.  
Output Example:
python

Chunk 743
Output Example:
python
result = "The answer to the prompt."  
FunctionDef init(self, prompt, source, config, schema)

Chunk 744
init: The function of init is to initialize the JSONScraperMultiGraph object with the provided prompt, source, config, and schema.  
parameters:
- prompt: A string representing the prompt for the JSON scraper.

Chunk 745
- source: A list of strings containing the data sources to scrape.
- config: A dictionary containing configuration settings.
- schema: An optional parameter of type BaseModel representing the schema for the scraped data.  
Code Description:

Chunk 746
The init function initializes the JSONScraperMultiGraph object by setting the maximum number of results to the value specified in the config dictionary. It then checks if all values in the config dictionary are of type string. If they are, it

Chunk 747
type string. If they are, it creates a shallow copy of the config dictionary; otherwise, it creates a deep copy. The function also creates a deep copy of the schema if provided. Finally, it calls the superclass's init method with the prompt, config,

Chunk 748
with the prompt, config, source, and schema parameters.

Chunk 749
Note:
- Ensure that the prompt, source, config, and schema parameters are correctly provided when initializing the JSONScraperMultiGraph object.

Chunk 750
- The function handles the configuration settings and schema copying based on the types of values in the config dictionary.  
FunctionDef _create_graph(self)

Chunk 751
_create_graph: The _create_graph function creates a graph of nodes representing the workflow for web scraping and searching.  
Parameters:
- self: The instance of the JSONScraperMultiGraph class.  
Code Description:

Chunk 752
The _create_graph function is responsible for creating a graph of nodes that represents the workflow for web scraping and searching. It starts by creating an instance of the JSONScraperGraph class, which is used as a graph instance within the main

Chunk 753
instance within the main graph. This instance is configured with the necessary parameters such as the prompt, source, config, and schema.

Chunk 754
Next, the function defines three nodes: GraphIteratorNode, MergeAnswersNode, and BaseGraph. The GraphIteratorNode is responsible for instantiating and running multiple graph instances in parallel. It takes the user prompt and the JSON data as input

Chunk 755
and the JSON data as input and outputs the results of the graph instances. The MergeAnswersNode merges the answers from multiple graph instances into a single answer. Finally, the BaseGraph represents the main graph and contains the nodes and edges.

Chunk 756
contains the nodes and edges.

Chunk 757
The function returns an instance of the BaseGraph class, which represents the web scraping and searching workflow. The BaseGraph instance is initialized with the graph_iterator_node and merge_answers_node as its nodes, and the edge connecting them.

Chunk 758
and the edge connecting them. The entry_point is set to the graph_iterator_node, and the graph_name is set to the name of the JSONScraperMultiGraph class.

Chunk 759
Note: The JSONScraperMultiGraph class relies on the presence of the JSONScraperGraph, GraphIteratorNode, and MergeAnswersNode classes, which are not provided in the code snippet. The execution logic and behavior of the graph depend on the

Chunk 760
of the graph depend on the implementation of these classes.

Chunk 761
Output Example: None  
FunctionDef run(self)  
run: The function of run is to execute the web scraping and searching process.  
parameters:
- None  
Code Description:

Chunk 762
The run function initiates the web scraping and searching process by preparing the inputs with the user prompt and JSON data source. It then executes the graph by calling the execute method from the graph object, passing in the prepared inputs. The

Chunk 763
in the prepared inputs. The final state containing the answer to the prompt is retrieved and returned.

Chunk 764
This function is a key part of the JSONScraperMultiGraph class, responsible for coordinating the execution of the graph and providing the final answer based on the input data.  
Note:

Chunk 765
Note:
- Ensure that the prompt and JSON data source are properly set before calling the run function.
- Make sure that the graph object is correctly initialized and configured to handle the execution process.  
Output Example:
{

Chunk 766
Output Example:
{
"answer": "Scraped data for the user prompt."
}

Chunk 767
ClassDef OmniScraperGraph  
OmniScraperGraph: The OmniScraperGraph class represents a scraping pipeline that automates the process of extracting information from web pages using a natural language model to interpret and answer prompts.  
Attributes:

Chunk 768
Attributes:
- prompt (str): The prompt for the graph.
- source (str): The source of the graph.
- config (dict): Configuration parameters for the graph.
- schema (BaseModel): The schema for the graph output.

Chunk 769
- llm_model: An instance of a language model client, configured for generating answers.
- embedder_model: An instance of an embedding model client, configured for generating embeddings.

Chunk 770
- verbose (bool): A flag indicating whether to show print statements during execution.
- headless (bool): A flag indicating whether to run the graph in headless mode.
- max_images (int): The maximum number of images to process.  
Code Description:

Chunk 771
The OmniScraperGraph class is responsible for creating a scraping pipeline that automates the process of extracting information from web pages. It uses a natural language model to interpret and answer prompts. The class inherits from the

Chunk 772
The class inherits from the AbstractGraph class.

Chunk 773
The constructor (init) method initializes the OmniScraperGraph object. It takes the following parameters:
- prompt (str): The prompt for the graph.
- source (str): The source of the graph.
- config (dict): Configuration parameters for the graph.

Chunk 774
- schema (BaseModel): The schema for the graph output.

Chunk 775
The _create_graph method creates the graph of nodes representing the workflow for web scraping. It returns a BaseGraph instance representing the web scraping workflow. The graph consists of the following nodes:

Chunk 776
- FetchNode: Fetches the web page content and extracts link URLs and image URLs.
- ParseNode: Parses the web page content.
- ImageToTextNode: Converts image URLs to image descriptions using a language model.

Chunk 777
- RAGNode: Filters relevant chunks of text based on the user prompt and parsed document.
- GenerateAnswerOmniNode: Generates an answer to the prompt using the relevant chunks of text and image descriptions.

Chunk 778
The run method executes the scraping process and returns the answer to the prompt. It returns a string representing the answer.

Chunk 779
Note: The OmniScraperGraph class requires the AbstractGraph class to be defined and imported. The class also requires the following nodes to be defined and imported: FetchNode, ParseNode, ImageToTextNode, RAGNode, and GenerateAnswerOmniNode.

Chunk 780
Output Example:
python
omni_scraper = OmniScraperGraph(
"List me all the attractions in Chioggia and describe their pictures.",
"https://en.wikipedia.org/wiki/Chioggia",
{"llm": {"model": "gpt-4o"}}
)
result = omni_scraper.run()

Chunk 781
result = omni_scraper.run()  
FunctionDef init(self, prompt, source, config, schema)  
init: The function of init is to initialize the OmniScraperGraph object with the provided prompt, source, configuration, and schema.  
parameters:

Chunk 782
parameters:
- prompt: A string representing the prompt for the scraper.
- source: A string indicating the source of the data (URL or local directory).
- config: A dictionary containing configuration settings.

Chunk 783
- schema: An optional parameter of type BaseModel representing the schema for the data.  
Code Description:
In this function, the following operations are performed:

Chunk 784
1. Sets the maximum number of images to 5 if the config parameter is None, otherwise retrieves the "max_images" value from the config dictionary.
2. Calls the superclass's constructor with the provided prompt, config, source, and schema.

Chunk 785
3. Determines the input key based on the source parameter. If the source starts with "http", the input key is set to "url"; otherwise, it is set to "local_dir".  
Note:

Chunk 786
Note:
- The function initializes the OmniScraperGraph object with the necessary parameters and configuration settings.
- It dynamically sets the input key based on the source parameter, allowing flexibility in handling different data sources.

Chunk 787
FunctionDef _create_graph(self)  
_create_graph: The function of _create_graph is to create the graph of nodes representing the workflow for web scraping.  
Parameters:
- self: The instance of the class.
- None  
Code Description:

Chunk 788
The _create_graph function is responsible for creating the graph of nodes that represents the workflow for web scraping. It initializes and configures several node instances, such as FetchNode, ParseNode, ImageToTextNode, RAGNode, and

Chunk 789
ImageToTextNode, RAGNode, and GenerateAnswerOmniNode. These nodes are connected through edges to define the flow of data and execution in the graph.

Chunk 790
The function starts by creating an instance of the FetchNode class, which is responsible for fetching the HTML content from a specified URL or local directory. The output of the FetchNode is then connected to the input of the ParseNode, which parses

Chunk 791
the ParseNode, which parses the fetched HTML content and extracts relevant information.

Chunk 792
The output of the ParseNode is connected to the input of the ImageToTextNode, which retrieves images from the parsed HTML content and generates text descriptions using an image-to-text model. The output of the ImageToTextNode is connected to the

Chunk 793
is connected to the input of the RAGNode, which compresses the input tokens and stores the document in a vector database for retrieval.

Chunk 794
Finally, the output of the RAGNode is connected to the input of the GenerateAnswerOmniNode, which generates an answer using a large language model based on the user's input and the relevant chunks of the document. The final output of the

Chunk 795
The final output of the GenerateAnswerOmniNode is the generated answer.

Chunk 796
The function returns an instance of the BaseGraph class, which represents the entire graph with the configured nodes and edges. The entry point of the graph is set to the FetchNode, and the graph is named "Custom".

Chunk 797
Note: The behavior and execution of the graph depend on the implementation of the individual node classes, such as FetchNode, ParseNode, ImageToTextNode, RAGNode, and GenerateAnswerOmniNode, which are not provided in the code snippet.

Chunk 798
Output Example: None  
FunctionDef run(self)  
run: The function of run is to execute the scraping process and return the answer to the prompt.
parameters:
- None  
Code Description:

Chunk 799
The run function initiates the scraping process by creating an inputs dictionary with user_prompt and source values. It then executes the graph by calling the execute method from the graph object, passing in the inputs. The final_state and

Chunk 800
inputs. The final_state and execution_info are updated based on the execution result, and the function returns the answer from the final_state dictionary or "No answer found" if no answer is present.

Chunk 801
The run function relies on the execute method from the graph object to perform the core execution logic of the scraping process. By passing the inputs to the execute method, the function triggers the graph execution and handles the final state and

Chunk 802
handles the final state and execution information accordingly.

Chunk 803
Note:
- Ensure that the prompt and source attributes are properly set before calling the run function to execute the scraping process.

Chunk 804
- Check the implementation of the execute method in the graph object to understand how the graph execution is performed.  
Output Example:
{
"answer": "Scraped data",
"execution_info": []
}

Chunk 805
ClassDef OmniSearchGraph

Chunk 806
OmniSearchGraph: The OmniSearchGraph class is a scraping pipeline that searches the internet for answers to a given prompt. It utilizes a graph structure to represent the workflow for web scraping and searching. The class requires a user prompt to

Chunk 807
requires a user prompt to search the internet and generate an answer.

Chunk 808
Attributes:
- prompt (str): The user prompt to search the internet.
- llm_model (dict): The configuration for the language model.
- embedder_model (dict): The configuration for the embedder model.

Chunk 809
- headless (bool): A flag to run the browser in headless mode.
- verbose (bool): A flag to display the execution information.
- model_token (int): The token limit for the language model.

Chunk 810
- max_results (int): The maximum number of results to return.  
Args:
- prompt (str): The user prompt to search the internet.
- config (dict): Configuration parameters for the graph.
- schema (Optional[BaseModel]): The schema for the graph output.

Chunk 811
Example:
python
omni_search_graph = OmniSearchGraph(
"What is Chioggia famous for?",
{"llm": {"model": "gpt-4o"}}
)
result = omni_search_graph.run()  
Code Description:

Chunk 812
Code Description:
The OmniSearchGraph class is a subclass of the AbstractGraph class. It inherits the common attributes and methods from the AbstractGraph class and implements its own specific logic for web scraping and searching.

Chunk 813
The class constructor (init) takes three parameters: prompt, config, and schema. The prompt is the user prompt to search the internet. The config is a dictionary containing configuration parameters for the graph. The schema is an optional parameter

Chunk 814
is an optional parameter that specifies the schema for the graph output.

Chunk 815
The constructor initializes the max_results attribute with the value from the config dictionary. It then checks if all values in the config dictionary are of type string. If they are, it creates a shallow copy of the config dictionary; otherwise, it

Chunk 816
dictionary; otherwise, it creates a deep copy. It also creates a deep copy of the schema if it is provided.

Chunk 817
The _create_graph method is a private method that creates the graph of nodes representing the workflow for web scraping and searching. It returns an instance of the BaseGraph class.

Chunk 818
The run method executes the web scraping and searching process. It first creates an inputs dictionary with the user_prompt key set to the prompt value. It then calls the execute method of the graph instance with the inputs dictionary. The

Chunk 819
the inputs dictionary. The final_state and execution_info attributes are updated with the results of the execution. Finally, the method returns the answer from the final_state dictionary, or "No answer found." if the answer is not present.

Chunk 820
Note:
- The OmniSearchGraph class requires the AbstractGraph class to be defined and imported.

Chunk 821
- The OmniSearchGraph class relies on other classes and functions such as OmniScraperGraph, SearchInternetNode, GraphIteratorNode, and MergeAnswersNode, which are not provided in the code snippet.

Chunk 822
- The OmniSearchGraph class uses the llm_model and schema attributes from the AbstractGraph class.
- The OmniSearchGraph class overrides the _create_graph and run methods from the AbstractGraph class.  
Output Example:

Chunk 823
Output Example:
The answer to the prompt "What is Chioggia famous for?" is "Chioggia is famous for its picturesque canals and its production of radicchio."  
FunctionDef init(self, prompt, config, schema)

Chunk 824
init: The function of init is to initialize the OmniSearchGraph object with the provided prompt, configuration, and schema.  
parameters:
- prompt: A string representing the prompt for the graph.

Chunk 825
- config: A dictionary containing configuration settings.
- schema: An optional parameter of type BaseModel representing the schema.  
Code Description:
In this function, the following steps are performed:

Chunk 826
1. The max_results attribute is set to the value of "max_results" key in the config dictionary, defaulting to 3 if the key is not present.

Chunk 827
2. It checks if all values in the config dictionary are of type string. If true, it creates a shallow copy of the config dictionary; otherwise, it creates a deep copy using the deepcopy function.

Chunk 828
3. The schema is deep copied to the copy_schema attribute.
4. Finally, the superclass's (presumably BaseModel) init method is called with the provided prompt, config, and schema.  
Note:

Chunk 829
Note:
- The function initializes the OmniSearchGraph object with the provided parameters, setting default values where necessary.

Chunk 830
- It handles the configuration dictionary by either creating a shallow copy or a deep copy based on the types of values present in the dictionary.  
FunctionDef _create_graph(self)

Chunk 831
_create_graph: The _create_graph function is responsible for creating the graph of nodes representing the workflow for web scraping and searching.  
Parameters:
- self: The instance of the OmniSearchGraph class.
- None  
Code Description:

Chunk 832
The _create_graph function starts by creating an instance of the OmniScraperGraph class, which represents a scraping pipeline for extracting information from web pages. It takes the prompt, source, config, and schema as input parameters.

Chunk 833
Next, the function defines the graph nodes by creating instances of the SearchInternetNode, GraphIteratorNode, and MergeAnswersNode classes. These nodes represent the different steps in the web scraping and searching workflow.

Chunk 834
The search_internet_node is responsible for generating a search query based on the user's input and searching the internet for relevant information. It takes the user_prompt, which is the input from the user, and outputs a list of URLs.

Chunk 835
The graph_iterator_node is responsible for instantiating and running multiple graph instances in parallel. It takes the user_prompt and the list of URLs as input and outputs a list of results.

Chunk 836
The merge_answers_node is responsible for merging the answers from multiple graph instances into a single answer. It takes the user_prompt and the list of results as input and outputs the final answer.

Chunk 837
Finally, the function returns a BaseGraph instance that represents the web scraping and searching workflow. The nodes and edges of the graph are defined based on the created nodes, and the entry_point is set to the search_internet_node.

Chunk 838
Note: The _create_graph function relies on the presence of other classes such as OmniScraperGraph, SearchInternetNode, GraphIteratorNode, and MergeAnswersNode, which are not provided in the code snippet. The execution logic and behavior of the graph

Chunk 839
and behavior of the graph depend on the implementation of these node classes.

Chunk 840
Output Example: None  
FunctionDef run(self)  
run: The function of run is to execute the web scraping and searching process.  
parameters:
- None

Chunk 841
Code Description: The run function initiates the web scraping and searching process by first creating an inputs dictionary with the user's prompt. It then calls the execute method of the graph object, passing in the inputs dictionary. The final

Chunk 842
inputs dictionary. The final state and execution information are stored in the respective attributes of the object. Finally, the function returns the answer from the final state or "No answer found" if no answer is present.

Chunk 843
The run function relies on the execute method from the BaseGraph class to perform the actual execution of the graph. By passing the user's prompt to the execute method, the run function triggers the graph execution process and retrieves the answer

Chunk 844
and retrieves the answer to the prompt.

Chunk 845
Note: Ensure that the prompt attribute of the object is properly set before calling the run function to get accurate results from the web scraping and searching process.  
Output Example:
{
"answer": "Example answer"
}

Chunk 846
ClassDef PDFScraperGraph  
PDFScraperGraph: The PDFScraperGraph class represents a scraping pipeline that extracts information from PDF files using a natural language model to interpret and answer prompts.  
Attributes:

Chunk 847
Attributes:
- prompt (str): The prompt for the graph.
- source (str): The source of the graph.
- config (dict): Configuration parameters for the graph.
- schema (BaseModel): The schema for the graph output.

Chunk 848
- llm_model: An instance of a language model client, configured for generating answers.
- embedder_model: An instance of an embedding model client, configured for generating embeddings.

Chunk 849
- verbose (bool): A flag indicating whether to show print statements during execution.
- headless (bool): A flag indicating whether to run the graph in headless mode.
- model_token (int): The token limit for the language model.  
Code Description:

Chunk 850
Code Description:
The PDFScraperGraph class is a subclass of the AbstractGraph class and inherits its attributes and methods. It is designed to perform web scraping on PDF files using a natural language model to interpret and answer prompts.

Chunk 851
The constructor method __init__ initializes the PDFScraperGraph object with the provided prompt, source, config, and schema. It also calls the constructor of the AbstractGraph class and sets the input_key attribute based on the source file

Chunk 852
based on the source file extension.

Chunk 853
The _create_graph method creates the graph of nodes representing the workflow for web scraping. It defines several nodes such as FetchNode, ParseNode, RAGNode, and GenerateAnswerPDFNode, and connects them with edges to form the workflow. The method

Chunk 854
form the workflow. The method returns an instance of the BaseGraph class representing the web scraping workflow.

Chunk 855
The run method executes the web scraping process by passing the prompt and source to the graph's execute method. It returns the answer to the prompt obtained from the final state of the graph.

Chunk 856
Note: The PDFScraperGraph class requires an instance of a language model client and an embedding model client to be configured before use. The language model client is used for generating answers, while the embedding model client is used for

Chunk 857
model client is used for generating embeddings. The verbose and headless flags control the verbosity and execution mode of the graph, respectively.

Chunk 858
Output Example:
```python
pdf_scraper = PDFScraperGraph(
"List me all the attractions in Chioggia.",
"data/chioggia.pdf",
{"llm": {"model": "gpt-3.5-turbo"}}
)
result = pdf_scraper.run()
print(result)

Chunk 859
Output: The answer to the prompt.

Chunk 860
```  
FunctionDef init(self, prompt, source, config, schema)  
init: The function of init is to initialize the PDFScraperGraph object with the provided prompt, source, configuration, and schema.  
parameters:

Chunk 861
parameters:
- prompt: A string representing the prompt for the PDF scraping process.
- source: A string indicating the source of the PDF file or directory.
- config: A dictionary containing configuration settings for the PDF scraping.

Chunk 862
- schema: An optional parameter of type BaseModel representing the schema for the PDF data.  
Code Description:

Chunk 863
In the init function, the PDFScraperGraph object is initialized by calling the superclass's constructor with the provided prompt, configuration, source, and schema parameters. Additionally, based on the source file extension, the input_key attribute

Chunk 864
the input_key attribute is set to "pdf" if the source ends with "pdf", otherwise, it is set to "pdf_dir".

Chunk 865
Note:
- Ensure that the prompt, source, and configuration parameters are correctly provided when initializing the PDFScraperGraph object.
- The schema parameter is optional and can be omitted if not needed for the PDF scraping process.

Chunk 866
- The input_key attribute is determined based on the file extension of the provided source, allowing for proper handling of PDF files or directories.  
FunctionDef _create_graph(self)

Chunk 867
_create_graph: Creates the graph of nodes representing the workflow for web scraping.  
Parameters:
- self: The instance of the class.
- None  
Code Description:

Chunk 868
The _create_graph function is responsible for creating the graph of nodes that represents the workflow for web scraping. It initializes and configures various nodes such as FetchNode, ParseNode, RAGNode, and GenerateAnswerPDFNode, and connects them

Chunk 869
and connects them together using edges. The function returns an instance of the BaseGraph class, which represents the web scraping workflow.

Chunk 870
The function starts by creating instances of the FetchNode, ParseNode, RAGNode, and GenerateAnswerPDFNode classes. These nodes are initialized with input, output, and node_config parameters, which define their behavior and configuration.

Chunk 871
The fetch_node is responsible for fetching the HTML content of a specified URL or directory and updating the state with this content. The parse_node is responsible for parsing the HTML content and splitting it into chunks for further processing. The

Chunk 872
for further processing. The rag_node is responsible for compressing the input tokens and storing the document in a vector database for retrieval. The generate_answer_node_pdf is responsible for generating an answer using a language model based on

Chunk 873
a language model based on the user's input and the content extracted from the webpage.

Chunk 874
After creating the nodes, the function creates a list of nodes and a list of edges that define the connections between the nodes. The edges represent the directed connections from one node to another. In this case, the fetch_node is connected to the

Chunk 875
is connected to the parse_node, the parse_node is connected to the rag_node, and the rag_node is connected to the generate_answer_node_pdf.

Chunk 876
The function then creates an instance of the BaseGraph class and initializes it with the list of nodes, list of edges, entry_point node, and graph_name. The entry_point node is set to the fetch_node, which is the starting point of the graph

Chunk 877
starting point of the graph execution.

Chunk 878
Finally, the function returns the initialized BaseGraph instance, which represents the web scraping workflow.

Chunk 879
Note: The BaseGraph class and other classes such as FetchNode, ParseNode, RAGNode, and GenerateAnswerPDFNode are not provided in the code snippet. The execution logic and behavior of the graph depend on the implementation of these node classes.

Chunk 880
Output Example: None  
FunctionDef run(self)  
run: The function of run is to execute the web scraping process and return the answer to the prompt.  
parameters:
- None  
Code Description:

Chunk 881
The run function initiates the web scraping process by preparing the inputs based on the user prompt and the data source. It then executes the graph using the execute method from the BaseGraph class, passing in the prepared inputs. The final state

Chunk 882
inputs. The final state and execution information are stored in the respective attributes. Finally, the function retrieves the answer from the final state or returns a default message if no answer is found.

Chunk 883
Note:
- Ensure that the prompt and source attributes are properly set before calling the run function.
- The execute method from the BaseGraph class is crucial for the functionality of the run function.  
Output Example:
{

Chunk 884
Output Example:
{
"answer": "Scraped data from the provided source."
}

Chunk 885
ClassDef PdfScraperMultiGraph  
PdfScraperMultiGraph: PdfScraperMultiGraph is a scraping pipeline that scrapes a list of URLs and generates answers to a given prompt. It requires a user prompt and a list of URLs as input.  
Attributes:

Chunk 886
Attributes:
- prompt (str): The user prompt to search the internet.
- llm_model (dict): The configuration for the language model.
- embedder_model (dict): The configuration for the embedder model.

Chunk 887
- headless (bool): A flag to run the browser in headless mode.
- verbose (bool): A flag to display the execution information.
- model_token (int): The token limit for the language model.  
Args:

Chunk 888
Args:
- prompt (str): The user prompt to search the internet.
- source (List[str]): The source of the graph.
- config (dict): Configuration parameters for the graph.
- schema (Optional[BaseModel]): The schema for the graph output.  
Example:
python

Chunk 889
Example:
python
search_graph = MultipleSearchGraph(
"What is Chioggia famous for?",
{"llm": {"model": "gpt-3.5-turbo"}}
)
result = search_graph.run()  
Code Description:

Chunk 890
The PdfScraperMultiGraph class is a subclass of the AbstractGraph class. It represents a scraping pipeline that scrapes a list of URLs and generates answers to a given prompt. The class has several attributes including prompt, llm_model,

Chunk 891
including prompt, llm_model, embedder_model, headless, verbose, and model_token.

Chunk 892
The constructor method (init) initializes the PdfScraperMultiGraph object. It takes the prompt, source, config, and schema as arguments. It sets the max_results attribute based on the "max_results" value in the config dictionary. It also creates a

Chunk 893
dictionary. It also creates a copy of the config and schema objects using the copy and deepcopy functions respectively. Then, it calls the constructor of the AbstractGraph class and passes the prompt, config, source, and schema as arguments.

Chunk 894
The _create_graph method is a private method that creates the graph of nodes representing the workflow for web scraping and searching. It creates an instance of the PDFScraperGraph class and assigns it to the pdf_scraper_instance variable. Then, it

Chunk 895
variable. Then, it defines two graph nodes: graph_iterator_node and merge_answers_node. The graph_iterator_node takes the user_prompt and pdfs as input and produces results as output. It uses the pdf_scraper_instance as the graph_instance. The

Chunk 896
as the graph_instance. The merge_answers_node takes the user_prompt and results as input and produces answer as output. It uses the llm_model and schema attributes of the PdfScraperMultiGraph class. Finally, it returns a BaseGraph instance with the

Chunk 897
a BaseGraph instance with the defined nodes and edges.

Chunk 898
The run method executes the web scraping and searching process. It creates an inputs dictionary with the user_prompt and pdfs as keys and their corresponding values from the PdfScraperMultiGraph object. It then calls the execute method of the graph

Chunk 899
execute method of the graph attribute with the inputs dictionary as the argument. The final_state and execution_info attributes of the PdfScraperMultiGraph object are updated with the results of the execution. Finally, the method returns the value

Chunk 900
the method returns the value of the "answer" key in the final_state dictionary, or "No answer found." if the key is not present.

Chunk 901
Note: The PdfScraperMultiGraph class extends the AbstractGraph class and inherits its attributes and methods. It also uses the PDFScraperGraph, GraphIteratorNode, and MergeAnswersNode classes to create the graph representation and execute the web

Chunk 902
and execute the web scraping and searching process.

Chunk 903
Output Example:
```python
search_graph = MultipleSearchGraph(
"What is Chioggia famous for?",
{"llm": {"model": "gpt-3.5-turbo"}}
)
result = search_graph.run()
print(result)

Chunk 904
Output: "Chioggia is famous for its canals and its historical center."

Chunk 905
```  
FunctionDef init(self, prompt, source, config, schema)  
init: The function of init is to initialize the PdfScraperMultiGraph object with the provided prompt, source, config, and schema.  
parameters:

Chunk 906
parameters:
- prompt: A string representing the prompt for the PdfScraperMultiGraph object.
- source: A list of strings containing the data sources for scraping.
- config: A dictionary containing configuration settings.

Chunk 907
- schema: An optional parameter of type BaseModel representing the schema for the data.  
Code Description:
In the init function, the PdfScraperMultiGraph object is initialized with the following steps:

Chunk 908
1. The max_results attribute is set to the value of "max_results" key from the config dictionary, defaulting to 3 if the key is not present.

Chunk 909
2. If all values in the config dictionary are of type string, the copy_config attribute is a shallow copy of the config dictionary. Otherwise, it is a deep copy of the config dictionary.

Chunk 910
3. The copy_schema attribute is a deep copy of the schema parameter.
4. The superclass's (init method) is called with the prompt, config, source, and schema parameters.  
Note:

Chunk 911
Note:
- The function initializes the PdfScraperMultiGraph object with the provided parameters and handles the configuration and schema copies based on the conditions specified in the code.

Chunk 912
- Ensure that the prompt, source, config, and schema parameters are provided correctly when initializing a PdfScraperMultiGraph object.  
FunctionDef _create_graph(self)

Chunk 913
_create_graph: The _create_graph function is responsible for creating the graph of nodes representing the workflow for web scraping and searching.  
Parameters:
- self: The instance of the PdfScraperMultiGraph class.
- No additional parameters.

Chunk 914
- No additional parameters.  
Code Description:

Chunk 915
The _create_graph function begins by creating an instance of the PDFScraperGraph class, which represents a scraping pipeline for extracting information from PDF files using a natural language model. The instance is configured with the provided

Chunk 916
configured with the provided prompt, source, config, and schema.

Chunk 917
Next, the function defines several nodes that will be part of the graph. These nodes include a FetchNode, a ParseNode, a RAGNode, and a GenerateAnswerPDFNode. Each node is configured with the necessary input and output keys, as well as any

Chunk 918
output keys, as well as any additional configuration parameters.

Chunk 919
After defining the nodes, the function creates an instance of the BaseGraph class, which manages the execution flow of the graph. The nodes and edges of the graph are specified, with the edges connecting the nodes in the desired sequence. The entry

Chunk 920
desired sequence. The entry point of the graph is set to the FetchNode.

Chunk 921
Finally, the function returns the created BaseGraph instance, representing the web scraping and searching workflow.

Chunk 922
Note: The PdfScraperMultiGraph class relies on the presence of other classes such as PDFScraperGraph, FetchNode, ParseNode, RAGNode, and GenerateAnswerPDFNode, which are not provided in the code snippet. The execution logic and behavior of the graph

Chunk 923
and behavior of the graph depend on the implementation of these node classes.

Chunk 924
Output Example: None  
FunctionDef run(self)  
run: The function of run is to execute the web scraping and searching process.  
parameters:
- self: The instance of the PdfScraperMultiGraph class.  
Code Description:

Chunk 925
The run function initiates the web scraping and searching process by preparing the inputs with the user prompt and PDF sources. It then executes the graph by calling the execute method of the graph object, passing in the prepared inputs. The final

Chunk 926
prepared inputs. The final state and execution information are stored in the respective attributes of the PdfScraperMultiGraph instance. Finally, the function returns the answer retrieved from the final state or "No answer found" if no answer is

Chunk 927
answer found" if no answer is present.

Chunk 928
This function is an essential part of the PdfScraperMultiGraph class, enabling the execution of the graph and retrieval of the answer based on the provided inputs.  
Note:

Chunk 929
Note:
- Ensure that the prompt and source attributes of the PdfScraperMultiGraph instance are correctly set before calling the run function.

Chunk 930
- The execute method of the graph object should be implemented to handle the inputs and execute the graph logic effectively.  
Output Example:
{
"answer": "Scraped data from PDF files."
}

Chunk 931
ClassDef ScriptCreatorGraph  
ScriptCreatorGraph: The ScriptCreatorGraph class defines a scraping pipeline for generating web scraping scripts.  
Attributes:
- prompt (str): The prompt for the graph.
- source (str): The source of the graph.

Chunk 932
- config (dict): Configuration parameters for the graph.
- schema (BaseModel): The schema for the graph output.
- llm_model: An instance of a language model client, configured for generating answers.

Chunk 933
- embedder_model: An instance of an embedding model client, configured for generating embeddings.
- verbose (bool): A flag indicating whether to show print statements during execution.

Chunk 934
- headless (bool): A flag indicating whether to run the graph in headless mode.
- model_token (int): The token limit for the language model.
- library (str): The library used for web scraping.  
Code Description:

Chunk 935
Code Description:
The ScriptCreatorGraph class is a subclass of the AbstractGraph class and represents a scraping pipeline for generating web scraping scripts. It inherits the attributes and methods from the AbstractGraph class.

Chunk 936
The constructor method (init) initializes the ScriptCreatorGraph object. It takes the following parameters:
- prompt (str): The prompt for the graph.
- source (str): The source of the graph.
- config (dict): Configuration parameters for the graph.

Chunk 937
- schema (BaseModel): The schema for the graph output.

Chunk 938
The constructor initializes the attributes of the ScriptCreatorGraph object, including the library used for web scraping. It then calls the constructor of the AbstractGraph class to initialize the inherited attributes.

Chunk 939
The _create_graph method creates the graph of nodes representing the workflow for web scraping. It returns a BaseGraph instance representing the web scraping workflow. The graph consists of three nodes: FetchNode, ParseNode, and GenerateScraperNode.

Chunk 940
and GenerateScraperNode. These nodes are connected by edges to define the flow of data between them.

Chunk 941
The run method executes the web scraping process and returns the answer to the prompt. It first creates the inputs dictionary with the user_prompt and source information. It then executes the graph using the execute method of the graph object. The

Chunk 942
of the graph object. The final_state and execution_info attributes are updated with the final state and execution information of the graph. Finally, the method returns the answer from the final_state, or "No answer found" if no answer is available.

Chunk 943
if no answer is available.

Chunk 944
Note: The ScriptCreatorGraph class is designed to be used as part of a larger scraping pipeline and requires the AbstractGraph class for its functionality.  
Output Example:
python
script_creator = ScriptCreatorGraph(

Chunk 945
"List me all the attractions in Chioggia.",
"https://en.wikipedia.org/wiki/Chioggia",
{"llm": {"model": "gpt-3.5-turbo"}}
)
result = script_creator.run()  
FunctionDef init(self, prompt, source, config, schema)

Chunk 946
init: The function of init is to initialize the ScriptCreatorGraph object with the provided prompt, source, config, and schema.  
parameters:
- prompt: A string representing the prompt for the script.

Chunk 947
- source: A string indicating the source of the script.
- config: A dictionary containing configuration settings.
- schema: An optional parameter of type BaseModel representing the schema.  
Code Description:

Chunk 948
In this function, the 'library' key is extracted from the 'config' dictionary and assigned to the 'library' attribute of the object. Then, the superclass's init method is called with the provided prompt, config, source, and schema parameters.

Chunk 949
and schema parameters. Finally, based on the source, the 'input_key' attribute is set to "url" if the source starts with "http", otherwise it is set to "local_dir".

Chunk 950
Note: Ensure that the 'config' dictionary contains the 'library' key to avoid any KeyError during initialization.  
FunctionDef _create_graph(self)  
_create_graph: Creates the graph of nodes representing the workflow for web scraping.  
Parameters:

Chunk 951
Parameters:
- self: The instance of the object.
- No additional parameters.

Chunk 952
The function starts by creating a FetchNode instance, which is responsible for fetching the HTML content of a specified URL or from a local directory. It takes the input keys "url" and "local_dir" and produces the output keys "doc", "link_urls", and

Chunk 953
keys "doc", "link_urls", and "img_urls".

Chunk 954
Next, a ParseNode instance is created, which is responsible for parsing the fetched HTML content. It takes the input key "doc" and produces the output key "parsed_doc". The ParseNode can also be configured to chunk the parsed content into smaller

Chunk 955
parsed content into smaller chunks using the "chunk_size" parameter.

Chunk 956
Finally, a GenerateScraperNode instance is created, which generates a Python script for scraping a website using the specified library. It takes the input keys "user_prompt" and "doc" and produces the output key "answer". The GenerateScraperNode can

Chunk 957
The GenerateScraperNode can be configured with the "llm_model" and "schema" parameters, as well as the "library" and "website" attributes.

Chunk 958
The function then creates an instance of the BaseGraph class and initializes it with the created nodes and edges. The BaseGraph class manages the execution flow of the graph and provides methods for executing the graph and adding new nodes. The

Chunk 959
and adding new nodes. The entry point of the graph is set to the FetchNode instance, and the graph is given a name based on the class name.

Chunk 960
The function returns the created BaseGraph instance, which represents the web scraping workflow.

Chunk 961
Note: The BaseGraph class and other node classes such as FetchNode, ParseNode, and GenerateScraperNode are not provided in the code snippet. The behavior and functionality of the graph depend on the implementation of these classes.

Chunk 962
Output Example: None  
FunctionDef run(self)  
run: The function of run is to execute the web scraping process and return the answer to the prompt.  
parameters:
- None  
Code Description:

Chunk 963
The run function initiates the web scraping process by creating inputs based on the user prompt and the data source. It then executes the graph by calling the execute method from the BaseGraph class, passing in the generated inputs. The final state

Chunk 964
inputs. The final state and execution information are stored, and the function returns the answer retrieved from the final state or a default message if no answer is found.

Chunk 965
The execute method from the BaseGraph class is responsible for executing the graph using either BurrBridge or the standard method. If BurrBridge is used, it creates an instance of BurrBridge and calls its execute method with the initial state. If

Chunk 966
with the initial state. If the standard method is used, it calls the _execute_standard method of the current object with the initial state.

Chunk 967
Note:
- Ensure that the prompt and source attributes are properly set before calling the run function.
- Check the implementation of the execute method in the BaseGraph class to understand the graph execution process.  
Output Example:
{

Chunk 968
Output Example:
{
"answer": "Scraped data from the website"
}

Chunk 969
ClassDef ScriptCreatorMultiGraph

Chunk 970
ScriptCreatorMultiGraph: The function of ScriptCreatorMultiGraph is to create a scraping pipeline that scrapes a list of URLs and generates web scraping scripts. It requires a user prompt and a list of URLs as input.  
Attributes:

Chunk 971
Attributes:
- prompt (str): The user prompt to search the internet.
- llm_model (dict): The configuration for the language model.
- embedder_model (dict): The configuration for the embedder model.

Chunk 972
- headless (bool): A flag to run the browser in headless mode.
- verbose (bool): A flag to display the execution information.
- model_token (int): The token limit for the language model.  
Code Description:

Chunk 973
Code Description:
The ScriptCreatorMultiGraph class is a subclass of the AbstractGraph class. It overrides the _create_graph() and run() methods to create a graph representation and execute the web scraping and searching process.

Chunk 974
The _create_graph() method creates a graph of nodes representing the workflow for web scraping and searching. It creates an instance of the ScriptCreatorGraph class and defines two graph nodes: GraphIteratorNode and MergeGeneratedScriptsNode. The

Chunk 975
The GraphIteratorNode takes the user prompt and URLs as input and outputs the generated scripts. The MergeGeneratedScriptsNode takes the user prompt and scripts as input and outputs the merged script. The method returns the created graph.

Chunk 976
The run() method executes the web scraping and searching process. It takes the user prompt and URLs as inputs, executes the graph using the inputs, and returns the merged script generated by the graph.

Chunk 977
Note: The ScriptCreatorMultiGraph class requires the AbstractGraph class and the ScriptCreatorGraph, GraphIteratorNode, and MergeGeneratedScriptsNode classes to be defined and imported.  
Output Example:
python

Chunk 978
Output Example:
python
script_graph = ScriptCreatorMultiGraph(
"What is Chioggia famous for?",
source=[],
config={"llm": {"model": "gpt-3.5-turbo"}},
schema={}
)
result = script_graph.run()  
FunctionDef init(self, prompt, source, config, schema)

Chunk 979
init: The function of init is to initialize the ScriptCreatorMultiGraph object with the provided prompt, source, config, and schema.  
parameters:
- prompt: A string representing the prompt for the graph generation.

Chunk 980
- source: A list of strings containing the data sources for the graph.
- config: A dictionary containing configuration settings.
- schema: An optional parameter of type BaseModel representing the schema for the graph.  
Code Description:

Chunk 981
The init function initializes the ScriptCreatorMultiGraph object by setting the maximum number of results based on the "max_results" key in the config dictionary. It then checks if all values in the config dictionary are of type string. If they are,

Chunk 982
of type string. If they are, it creates a shallow copy of the config dictionary; otherwise, it creates a deep copy. Finally, it calls the superclass's init method with the provided prompt, config, source, and schema parameters.

Chunk 983
Note:
- Ensure that the prompt, source, config, and schema parameters are correctly provided when initializing the ScriptCreatorMultiGraph object.

Chunk 984
- The function handles the configuration dictionary by either creating a shallow copy or a deep copy based on the types of values present in the dictionary.  
FunctionDef _create_graph(self)

Chunk 985
_create_graph: The function of _create_graph is to create a graph of nodes representing the workflow for web scraping and searching.  
Parameters:
- self: The instance of the ScriptCreatorMultiGraph class.
- No additional parameters.

Chunk 986
- No additional parameters.  
Code Description:

Chunk 987
The _create_graph function is responsible for creating a graph of nodes that represents the workflow for web scraping and searching. It initializes a ScriptCreatorGraph instance and sets the necessary configuration parameters. Then, it defines three

Chunk 988
Then, it defines three nodes: GraphIteratorNode, MergeGeneratedScriptsNode, and BaseGraph. These nodes are connected by edges to define the flow of data between them.

Chunk 989
The function first creates an instance of the ScriptCreatorGraph class, which represents a scraping pipeline for generating web scraping scripts. It takes the prompt, source, config, and schema as input parameters. The prompt is the user's query or

Chunk 990
prompt is the user's query or instruction, the source is the URL or local directory to scrape, the config is a dictionary of configuration parameters, and the schema is the expected output format.

Chunk 991
Next, the function defines the graph_iterator_node, which is an instance of the GraphIteratorNode class. This node is responsible for instantiating and running multiple graph instances in parallel. It takes the user_prompt and urls as input and

Chunk 992
and urls as input and outputs the scripts generated by the graph instances. The node_config parameter is set to include the script_generator_instance.

Chunk 993
Then, the function defines the merge_scripts_node, which is an instance of the MergeGeneratedScriptsNode class. This node merges the scripts generated for different URLs into a single script. It takes the user_prompt and scripts as input and outputs

Chunk 994
scripts as input and outputs the merged_script. The node_config parameter includes the llm_model and schema.

Chunk 995
Finally, the function creates an instance of the BaseGraph class, which manages the execution flow of the graph. It takes the graph_iterator_node and merge_scripts_node as nodes and connects them with an edge. The entry_point is set to the

Chunk 996
The entry_point is set to the graph_iterator_node, and the graph_name is set to the name of the ScriptCreatorMultiGraph class.

Chunk 997
The function returns the BaseGraph instance representing the web scraping and searching workflow.

Chunk 998
Note: The ScriptCreatorGraph, GraphIteratorNode, MergeGeneratedScriptsNode, and BaseGraph classes are assumed to be defined in other parts of the code and are not provided in the given code snippet.  
Output Example: None  
FunctionDef run(self)

Chunk 999
FunctionDef run(self)  
run: The function of run is to execute the web scraping and searching process and return the answer to the prompt.  
parameters:
- self: The instance of the class.
- prompt: The user prompt for the web scraping process.

Chunk 1000
- source: The URLs to be scraped.  
Code Description:

Chunk 1001
The run function initiates the web scraping and searching process by preparing the inputs with the user prompt and URLs. It then executes the graph by calling the execute method from the BaseGraph class, passing in the prepared inputs. The final

Chunk 1002
prepared inputs. The final state and execution information are stored in the respective attributes. Finally, the function returns the merged script from the final state, or a default message if the script generation fails.

Chunk 1003
The run function is a key part of the ScriptCreatorMultiGraph class, responsible for orchestrating the execution of the graph to generate scripts based on user prompts and URLs.  
Note:

Chunk 1004
Note:
- Ensure that the prompt and source attributes are correctly set before calling the run function.
- Handle any potential failures in script generation by checking the returned value for errors.  
Output Example:
{

Chunk 1005
Output Example:
{
"merged_script": "Generated script content here"
}

Chunk 1006
ClassDef SearchGraph  
SearchGraph: The SearchGraph class represents a scraping pipeline that searches the internet for answers to a given prompt. It utilizes a graph-based workflow to perform web scraping and searching operations.  
Attributes:

Chunk 1007
Attributes:
- prompt (str): The user prompt to search the internet.
- llm_model (dict): The configuration for the language model.
- embedder_model (dict): The configuration for the embedder model.

Chunk 1008
- headless (bool): A flag to run the browser in headless mode.
- verbose (bool): A flag to display the execution information.
- model_token (int): The token limit for the language model.

Chunk 1009
- considered_urls (List[str]): A list of URLs considered during the search.  
Args:
- prompt (str): The user prompt to search the internet.
- config (dict): Configuration parameters for the graph.

Chunk 1010
- schema (Optional[BaseModel]): The schema for the graph output.  
Example:
python
search_graph = SearchGraph(
"What is Chioggia famous for?",
{"llm": {"model": "gpt-3.5-turbo"}}
)
result = search_graph.run()

Chunk 1011
)
result = search_graph.run()
print(search_graph.get_considered_urls())  
Code Description:

Chunk 1012
The SearchGraph class is a subclass of the AbstractGraph class and represents a scraping pipeline that searches the internet for answers to a given prompt. It utilizes a graph-based workflow to perform web scraping and searching operations.

Chunk 1013
The class constructor (init) initializes the SearchGraph object with the provided prompt, configuration, and schema. It also sets up the necessary attributes such as max_results, copy_config, copy_schema, and considered_urls.

Chunk 1014
The _create_graph method is a private method that creates a graph instance representing the web scraping and searching workflow. It creates instances of SmartScraperGraph, SearchInternetNode, GraphIteratorNode, and MergeAnswersNode, and defines the

Chunk 1015
and defines the connections between them.

Chunk 1016
The run method executes the web scraping and searching process by executing the graph with the provided inputs. It stores the final state and execution information, and returns the answer to the prompt. It also updates the considered_urls attribute

Chunk 1017
the considered_urls attribute with the URLs considered during the search.

Chunk 1018
The get_considered_urls method returns the list of URLs considered during the search.  
Note:
- The SearchGraph class is designed to be used as part of a larger scraping pipeline and requires the AbstractGraph class to be implemented.

Chunk 1019
- The configuration parameters for the graph should be provided in the config dictionary, including the llm_model and embedder_model configurations.

Chunk 1020
- The schema parameter is optional and can be used to define the expected output schema of the graph.
- The run method executes the graph and returns the answer to the prompt. If no answer is found, it returns "No answer found."

Chunk 1021
- The get_considered_urls method can be used to retrieve the list of URLs considered during the search.  
Output Example:

Chunk 1022
Output Example:
['https://en.wikipedia.org/wiki/Chioggia', 'https://www.tripadvisor.com/Tourism-g194821-Chioggia_Veneto-Vacations.html', 'https://www.lonelyplanet.com/italy/veneto/chioggia']  
FunctionDef init(self, prompt, config, schema)

Chunk 1023
init: The function of init is to initialize the SearchGraph object with the provided prompt, configuration, and schema.  
parameters:
- prompt: A string representing the prompt for the search graph.

Chunk 1024
- config: A dictionary containing configuration settings.
- schema: An optional parameter that is an instance of BaseModel.  
Code Description:

Chunk 1025
The init function initializes the SearchGraph object by setting the maximum number of results based on the "max_results" key in the config dictionary. It then checks if all values in the config dictionary are strings, and if so, it creates a shallow

Chunk 1026
if so, it creates a shallow copy of the config. Otherwise, it creates a deep copy of the config. The function also makes a deep copy of the schema if provided. A new attribute called "considered_urls" is initialized as an empty list to store URLs.

Chunk 1027
an empty list to store URLs. Finally, the superclass's init method is called with the prompt, config, and schema parameters.

Chunk 1028
Note:
- Ensure that the prompt is a string, config is a dictionary, and schema is an instance of BaseModel when initializing the SearchGraph object.

Chunk 1029
- The function handles the configuration settings by creating either a shallow or deep copy based on the values in the config dictionary.  
FunctionDef _create_graph(self)

Chunk 1030
_create_graph: The _create_graph function is responsible for creating a graph of nodes representing the workflow for web scraping and searching.  
Parameters:
- self: The instance of the class.
- None

Chunk 1031
- None  
Next, the function defines three graph nodes: search_internet_node, graph_iterator_node, and merge_answers_node. Each node is instantiated with specific input, output, and node configuration parameters.

Chunk 1032
The search_internet_node is responsible for searching the internet based on the user's prompt. It takes the user_prompt as input and outputs a list of urls. The node configuration includes the llm_model and max_results parameters.

Chunk 1033
Finally, the function returns an instance of the BaseGraph class, which represents the web scraping and searching workflow. It takes the three nodes (search_internet_node, graph_iterator_node, and merge_answers_node), the edges connecting the nodes,

Chunk 1034
edges connecting the nodes, the entry point node (search_internet_node), and the graph name as input parameters.

Chunk 1035
Output Example: None  
FunctionDef run(self)  
run: The function of run is to execute the web scraping and searching process based on the provided user prompt and return the answer.  
parameters:
- self: The instance of the class.

Chunk 1036
Code Description:

Chunk 1037
The run function initiates the web scraping and searching process by passing the user prompt to the graph. It then stores the final state and execution information after executing the graph. If URLs are present in the final state, they are stored as

Chunk 1038
state, they are stored as considered URLs. Finally, the function returns the answer from the final state or "No answer found" if no answer is available.

Chunk 1039
The run function is called within the SearchGraph class to trigger the execution of the graph and retrieve the answer to the user prompt.  
Note:

Chunk 1040
Note:
- Ensure that the prompt attribute is properly set before calling the run function to provide the user prompt for the search process.  
Output Example:
{
"answer": "Example answer",
"execution_info": []
}

Chunk 1041
"execution_info": []
}  
FunctionDef get_considered_urls(self)  
get_considered_urls: The function of get_considered_urls is to return a list of URLs that were considered during the search.  
parameters:
- None  
Code Description:

Chunk 1042
The get_considered_urls function retrieves and returns a list of URLs that were considered during the search process. The function does not take any parameters and simply returns the list of considered URLs stored in the attribute "considered_urls"

Chunk 1043
attribute "considered_urls" of the object.

Chunk 1044
Note:

Chunk 1045
Developers can use this function to access the list of URLs that were evaluated during the search operation. It is important to ensure that the object has been properly initialized and that the "considered_urls" attribute has been populated before

Chunk 1046
has been populated before calling this function to avoid any potential errors.

Chunk 1047
Output Example:
['https://example.com/page1', 'https://example.com/page2', 'https://example.com/page3']

Chunk 1048
ClassDef SmartScraperGraph

Chunk 1049
SmartScraperGraph: The SmartScraperGraph class is responsible for creating a scraping pipeline that automates the process of extracting information from web pages using a natural language model to interpret and answer prompts.  
Attributes:

Chunk 1050
Attributes:
- prompt (str): The prompt for the graph.
- source (str): The source of the graph.
- config (dict): Configuration parameters for the graph.
- schema (BaseModel): The schema for the graph output.

Chunk 1051
- llm_model: An instance of a language model client, configured for generating answers.
- embedder_model: An instance of an embedding model client, configured for generating embeddings.

Chunk 1052
- verbose (bool): A flag indicating whether to show print statements during execution.
- headless (bool): A flag indicating whether to run the graph in headless mode.  
Code Description:

Chunk 1053
Code Description:
The SmartScraperGraph class is a subclass of the AbstractGraph class. It inherits the attributes and methods from the AbstractGraph class and overrides the _create_graph() and run() methods.

Chunk 1054
The _create_graph() method creates a graph of nodes representing the workflow for web scraping. It initializes and configures nodes such as FetchNode, ParseNode, RAGNode, and GenerateAnswerNode. These nodes are connected through edges to define the

Chunk 1055
through edges to define the flow of data and operations in the graph. The method returns an instance of the BaseGraph class representing the web scraping workflow.

Chunk 1056
The run() method executes the scraping process by passing the user prompt and source to the graph. It retrieves the final state and execution information from the graph and returns the answer to the prompt.

Chunk 1057
The SmartScraperGraph class takes the following arguments in its constructor:
- prompt (str): The prompt for the graph.
- source (str): The source of the graph.
- config (dict): Configuration parameters for the graph.

Chunk 1058
- schema (BaseModel): The schema for the graph output.  
The class also defines a private attribute, input_key, which is set based on the source. If the source starts with "http", the input_key is set to "url", otherwise it is set to "local_dir".

Chunk 1059
Note: The SmartScraperGraph class relies on the AbstractGraph class for its functionality. It creates a graph representation of the web scraping workflow and executes it to retrieve the answer to the prompt.  
Output Example:
python

Chunk 1060
Output Example:
python
smart_scraper = SmartScraperGraph(
"List me all the attractions in Chioggia.",
"https://en.wikipedia.org/wiki/Chioggia",
{"llm": {"model": "gpt-3.5-turbo"}}
)
result = smart_scraper.run()

Chunk 1061
FunctionDef init(self, prompt, source, config, schema)  
init: The function of init is to initialize the SmartScraperGraph object with the provided prompt, source, configuration, and optional schema.  
parameters:

Chunk 1062
parameters:
- prompt: A string representing the prompt for the SmartScraperGraph.
- source: A string indicating the source of data, either a URL or a local directory.

Chunk 1063
- config: A dictionary containing configuration settings for the SmartScraperGraph.
- schema: An optional parameter of type BaseModel representing the schema for the data.  
Code Description:

Chunk 1064
The init function initializes the SmartScraperGraph object by calling the constructor of its superclass with the provided prompt, configuration, source, and schema. It then determines the input key based on the source, setting it to "url" if the

Chunk 1065
setting it to "url" if the source starts with "http", or "local_dir" otherwise.

Chunk 1066
Note:
- Ensure that the prompt, source, and config parameters are provided when initializing a SmartScraperGraph object.
- The schema parameter is optional and can be omitted if not needed for the specific use case.

Chunk 1067
FunctionDef _create_graph(self)  
_create_graph: Creates the graph of nodes representing the workflow for web scraping.  
Parameters:
- self: The instance of the SmartScraperGraph class.  
Code Description:

Chunk 1068
The _create_graph function is responsible for creating the graph of nodes that represents the workflow for web scraping. It initializes and configures four different types of nodes: FetchNode, ParseNode, RAGNode, and GenerateAnswerNode. Each node is

Chunk 1069
Each node is instantiated with specific input, output, and configuration parameters.

Chunk 1070
The fetch_node is created with the input parameter set to "url | local_dir" and the output parameter set to ["doc", "link_urls", "img_urls"]. It also takes a node_config parameter that contains additional configuration options.

Chunk 1071
The parse_node is created with the input parameter set to "doc" and the output parameter set to ["parsed_doc"]. It also takes a node_config parameter that contains additional configuration options, such as the chunk_size.

Chunk 1072
The rag_node is created with the input parameter set to "user_prompt & (parsed_doc | doc)" and the output parameter set to ["relevant_chunks"]. It also takes a node_config parameter that contains additional configuration options, such as the

Chunk 1073
options, such as the llm_model and embedder_model.

Chunk 1074
The generate_answer_node is created with the input parameter set to "user_prompt & (relevant_chunks | parsed_doc | doc)" and the output parameter set to ["answer"]. It also takes a node_config parameter that contains additional configuration

Chunk 1075
additional configuration options, such as the llm_model and schema.

Chunk 1076
Finally, an instance of the BaseGraph class is returned, initialized with the created nodes, edges, entry point, and graph name.

Chunk 1077
Note: The _create_graph function relies on the presence of other classes such as FetchNode, ParseNode, RAGNode, and GenerateAnswerNode, which are not provided in the code snippet. The execution logic and behavior of the graph depend on the

Chunk 1078
of the graph depend on the implementation of these node classes.

Chunk 1079
Output Example: None  
FunctionDef run(self)  
run: The function of run is to execute the scraping process and return the answer to the prompt.  
parameters:
- None  
Code Description:

Chunk 1080
The run function executes the scraping process by passing the user prompt and the data source to the graph for execution. It then retrieves the final state, including the answer to the prompt, or "No answer found" if no answer is available.

Chunk 1081
This function is a part of the SmartScraperGraph class in the smart_scraper_graph.py file. It plays a crucial role in the scraping process by orchestrating the execution and retrieval of the prompt answer.  
Note:

Chunk 1082
Note:
- Ensure that the prompt and source data are properly set before calling this function to get accurate results.  
Output Example:
If the scraping process is successful, the function may return something like: "The answer to the prompt."

Chunk 1083
ClassDef SmartScraperMultiGraph  
SmartScraperMultiGraph: The SmartScraperMultiGraph class is a scraping pipeline that scrapes a list of URLs and generates answers to a given prompt. It is a subclass of the AbstractGraph class.  
Attributes:

Chunk 1084
Attributes:
- prompt (str): The user prompt to search the internet.
- llm_model (dict): The configuration for the language model.
- embedder_model (dict): The configuration for the embedder model.

Chunk 1085
- headless (bool): A flag to run the browser in headless mode.
- verbose (bool): A flag to display the execution information.
- model_token (int): The token limit for the language model.  
Args:

Chunk 1086
Args:
- prompt (str): The user prompt to search the internet.
- source (List[str]): The source of the graph.
- config (dict): Configuration parameters for the graph.
- schema (Optional[BaseModel]): The schema for the graph output.  
Example:
python

Chunk 1087
Example:
python
search_graph = MultipleSearchGraph(
"What is Chioggia famous for?",
{"llm": {"model": "gpt-3.5-turbo"}}
)
result = search_graph.run()  
Code Description:

Chunk 1088
The SmartScraperMultiGraph class is a subclass of the AbstractGraph class and represents a scraping pipeline that scrapes a list of URLs and generates answers to a given prompt. It requires a user prompt and a list of URLs as input.

Chunk 1089
The class has a private method _create_graph() that creates the graph of nodes representing the workflow for web scraping and searching. It returns a BaseGraph instance representing the web scraping and searching workflow.

Chunk 1090
The class also has a run() method that executes the web scraping and searching process. It takes no arguments and returns the answer to the prompt as a string. The method first creates the graph using the _create_graph() method, then executes the

Chunk 1091
method, then executes the graph using the execute() method of the graph instance. The final state and execution information are stored in the final_state and execution_info attributes respectively.

Chunk 1092
Note: The SmartScraperMultiGraph class is designed to work with the AbstractGraph class and requires the implementation of the _create_graph() method in the subclass.  
Output Example:
python

Chunk 1093
Output Example:
python
result = "Chioggia is famous for its canals and its historical center."  
FunctionDef init(self, prompt, source, config, schema)

Chunk 1094
init: The function of init is to initialize the SmartScraperMultiGraph object with the provided prompt, source, configuration, and schema.  
parameters:
- prompt: A string representing the prompt for the SmartScraperMultiGraph object.

Chunk 1095
- source: A list of strings containing the data sources for scraping.
- config: A dictionary containing configuration settings.
- schema: An optional parameter of type BaseModel representing the schema for the scraped data.  
Code Description:

Chunk 1096
The init function initializes the SmartScraperMultiGraph object by setting the maximum number of results based on the "max_results" key in the config dictionary. It then checks if all values in the config dictionary are of type string, and if so, it

Chunk 1097
of type string, and if so, it creates a shallow copy of the config dictionary. Otherwise, it creates a deep copy of the config dictionary. The function also creates a deep copy of the schema if provided. Finally, it calls the superclass's init

Chunk 1098
calls the superclass's init method with the prompt, config, source, and schema parameters.

Chunk 1099
Note:
- Ensure that the prompt, source, config, and schema parameters are correctly provided when initializing the SmartScraperMultiGraph object.

Chunk 1100
- The function handles the configuration dictionary differently based on the types of values it contains, either creating a shallow copy or a deep copy accordingly.  
FunctionDef _create_graph(self)

Chunk 1101
_create_graph: The function of _create_graph is to create a graph of nodes representing the workflow for web scraping and searching.  
Parameters:
- self: The instance of the SmartScraperMultiGraph class.
- No additional parameters.

Chunk 1102
- No additional parameters.  
Code Description:

Chunk 1103
The _create_graph function is responsible for creating a graph that represents the workflow for web scraping and searching. It starts by creating an instance of the SmartScraperGraph class, which is used as the main graph instance for the workflow.

Chunk 1104
instance for the workflow. The prompt and source parameters of the SmartScraperGraph instance are set to empty strings, while the config and schema parameters are set to the copy_config and copy_schema attributes of the SmartScraperMultiGraph

Chunk 1105
of the SmartScraperMultiGraph instance, respectively.

Chunk 1106
Next, the function defines two graph nodes: graph_iterator_node and merge_answers_node. The graph_iterator_node is an instance of the GraphIteratorNode class, which is responsible for iterating over a list of user prompts and URLs and executing the

Chunk 1107
and URLs and executing the SmartScraperGraph instance for each combination. The input parameter of the graph_iterator_node is set to "user_prompt & urls", indicating that it requires both the user_prompt and urls keys from the state. The output

Chunk 1108
from the state. The output parameter is set to ["results"], indicating that it will update the state with the results of the graph instances. The node_config parameter is set to a dictionary containing the "graph_instance" key, which is assigned the

Chunk 1109
key, which is assigned the value of the smart_scraper_instance created earlier.

Chunk 1110
The merge_answers_node is an instance of the MergeAnswersNode class, which is responsible for merging the answers from the graph instances into a single answer. The input parameter of the merge_answers_node is set to "user_prompt & results",

Chunk 1111
to "user_prompt & results", indicating that it requires both the user_prompt and results keys from the state. The output parameter is set to ["answer"], indicating that it will update the state with the generated answer. The node_config parameter is

Chunk 1112
The node_config parameter is set to a dictionary containing the "llm_model" and "schema" keys, which are assigned the values of the llm_model and schema attributes of the SmartScraperMultiGraph instance, respectively.

Chunk 1113
Finally, the function returns an instance of the BaseGraph class, which represents the overall graph of the workflow. The nodes parameter is set to a list containing the graph_iterator_node and merge_answers_node instances, while the edges parameter

Chunk 1114
while the edges parameter is set to a list containing a tuple representing the directed edge between the graph_iterator_node and merge_answers_node. The entry_point parameter is set to the graph_iterator_node, indicating that the graph execution

Chunk 1115
that the graph execution should start from this node. The graph_name parameter is set to the name of the SmartScraperMultiGraph class.

Chunk 1116
Note: The BaseGraph class is a separate class that manages the execution flow of a graph composed of interconnected nodes. The GraphIteratorNode and MergeAnswersNode classes are also separate classes responsible for specific tasks within the graph

Chunk 1117
tasks within the graph workflow. The execution logic and behavior of the graph depend on the implementation of these node classes.

Chunk 1118
Output Example:
```python
graph = _create_graph()
print(graph)

Chunk 1119
Output: BaseGraph(nodes=[graph_iterator_node, merge_answers_node], edges=[(graph_iterator_node, merge_answers_node)], entry_point=graph_iterator_node, graph_name="SmartScraperMultiGraph")

Chunk 1120
```  
FunctionDef run(self)  
run: The function of run is to execute the web scraping and searching process and return the answer to the prompt.  
parameters:
- None  
Code Description:

Chunk 1121
The run function initiates the web scraping and searching process by passing the user prompt and URLs to the graph for execution. It then retrieves the final state, including the answer to the prompt, or "No answer found" if no answer is available.

Chunk 1122
if no answer is available.

Chunk 1123
This function plays a crucial role in the SmartScraperMultiGraph class by orchestrating the execution of the scraping process and providing the final answer to the user prompt.  
Note:

Chunk 1124
Note:
Developers using this function should ensure that the necessary inputs (user prompt and URLs) are correctly set before calling the run function to avoid unexpected behavior.  
Output Example:

Chunk 1125
Output Example:
If the web scraping process is successful and an answer is found, the function may return: "The answer to the prompt."

Chunk 1126
ClassDef SpeechGraph  
SpeechGraph: The SpeechGraph class represents a scraping pipeline that scrapes the web, provides an answer to a given prompt, and generates an audio file.  
Attributes:
- prompt (str): The prompt for the graph.

Chunk 1127
- source (str): The source of the graph.
- config (dict): Configuration parameters for the graph.
- schema (BaseModel): The schema for the graph output.
- llm_model: An instance of a language model client, configured for generating answers.

Chunk 1128
- embedder_model: An instance of an embedding model client, configured for generating embeddings.
- verbose (bool): A flag indicating whether to show print statements during execution.

Chunk 1129
- headless (bool): A flag indicating whether to run the graph in headless mode.
- model_token (int): The token limit for the language model.  
Code Description:

Chunk 1130
Code Description:
The SpeechGraph class is a subclass of the AbstractGraph class and inherits its attributes and methods. It is responsible for creating a graph of nodes representing the workflow for web scraping and audio generation.

Chunk 1131
The _create_graph method is implemented to create the graph by instantiating various nodes such as FetchNode, ParseNode, RAGNode, GenerateAnswerNode, and TextToSpeechNode. These nodes are connected through edges to define the workflow. The graph is

Chunk 1132
the workflow. The graph is then returned as an instance of the BaseGraph class.

Chunk 1133
The run method executes the scraping process by passing the user prompt and source to the graph's execute method. It retrieves the final state and execution information from the graph. If an audio file is generated, it is saved to the specified

Chunk 1134
it is saved to the specified output path. The method returns the answer to the prompt.

Chunk 1135
Note: The SpeechGraph class requires the AbstractGraph class to be defined and imported.  
Output Example:
```python
speech_graph = SpeechGraph(
"List me all the attractions in Chioggia and generate an audio summary.",

Chunk 1136
"https://en.wikipedia.org/wiki/Chioggia",
{"llm": {"model": "gpt-3.5-turbo"}}
)
answer = speech_graph.run()
print(answer)

Chunk 1137
Output: The answer to the prompt

Chunk 1138
```  
FunctionDef init(self, prompt, source, config, schema)  
init: The function of init is to initialize the SpeechGraph object.  
parameters:
- prompt: A string representing the prompt for the speech graph.

Chunk 1139
- source: A string indicating the source of the data.
- config: A dictionary containing configuration settings.
- schema: An optional parameter of type BaseModel representing the schema.  
Code Description:

Chunk 1140
The init function initializes the SpeechGraph object by calling the parent class's constructor with the provided prompt, config, source, and schema parameters. It then sets the input_key attribute based on the source value. If the source starts with

Chunk 1141
If the source starts with "http", the input_key is set to "url"; otherwise, it is set to "local_dir".

Chunk 1142
Note:
- Ensure that the prompt, source, and config parameters are correctly provided when initializing the SpeechGraph object.
- The schema parameter is optional and can be omitted if not needed.

Chunk 1143
- The input_key attribute determines the key to be used based on the source value, which can be useful for further processing within the SpeechGraph object.  
FunctionDef _create_graph(self)

Chunk 1144
_create_graph: The function of _create_graph is to create the graph of nodes representing the workflow for web scraping and audio generation.  
Parameters:
- self: The instance of the class.
- None  
Code Description:

Chunk 1145
The _create_graph function is responsible for creating the graph of nodes that represents the workflow for web scraping and audio generation. It initializes and configures various nodes such as FetchNode, ParseNode, RAGNode, GenerateAnswerNode, and

Chunk 1146
GenerateAnswerNode, and TextToSpeechNode. These nodes are interconnected through edges to define the flow of data and execution in the graph.

Chunk 1147
The function starts by creating instances of the different nodes and configuring their input, output, and node_config parameters. The FetchNode is responsible for fetching the HTML content from a specified URL or local directory. The ParseNode

Chunk 1148
directory. The ParseNode parses the fetched HTML content and extracts relevant information. The RAGNode compresses the input tokens and stores the document in a vector database for retrieval. The GenerateAnswerNode generates an answer using a large

Chunk 1149
an answer using a large language model based on the user's input and the scraped content. The TextToSpeechNode converts the generated answer to speech using a specified text-to-speech model.

Chunk 1150
After creating the nodes, the function creates the edges between the nodes to define the flow of data and execution. The edges are defined as tuples representing the directed connections between the nodes. The function also sets the entry point of

Chunk 1151
also sets the entry point of the graph to be the FetchNode.

Chunk 1152
Finally, the function creates an instance of the BaseGraph class and initializes it with the created nodes, edges, entry point, and graph name. The BaseGraph class manages the execution flow of the graph and provides methods for executing the graph

Chunk 1153
for executing the graph and adding new nodes.

Chunk 1154
Note: The function relies on the presence of other classes such as FetchNode, ParseNode, RAGNode, GenerateAnswerNode, and TextToSpeechNode, which are not provided in the code snippet. The execution logic and behavior of the graph depend on the

Chunk 1155
of the graph depend on the implementation of these node classes.

Chunk 1156
Output Example: None  
FunctionDef run(self)  
run: The function of run is to execute the scraping process, save the generated audio as an audio file, and return the answer to the prompt.  
parameters:

Chunk 1157
parameters:
- No explicit parameters are passed to the run function. However, it relies on attributes set within the class instance.  
Code Description:

Chunk 1158
The run function initiates the scraping process by executing the graph with the provided inputs, which include the user prompt and the data source. It then retrieves the final state and execution information from the graph. The function checks if

Chunk 1159
graph. The function checks if audio data is present in the final state, raises a ValueError if no audio is generated, and proceeds to save the audio as an audio file at the specified output path using the save_audio_from_bytes function. Finally, it

Chunk 1160
function. Finally, it returns the answer to the prompt or a default message if no answer is found.

Chunk 1161
The run function is an integral part of the SpeechGraph class, where it orchestrates the execution of the scraping process, handling audio generation and saving. By utilizing the save_audio_from_bytes function, it ensures that any audio generated

Chunk 1162
that any audio generated from the text is saved to the designated output path as specified in the configuration settings. This function plays a crucial role in the overall functionality of the SpeechGraph class by managing the execution flow and

Chunk 1163
the execution flow and handling the audio output.

Chunk 1164
Note:
- It is essential to provide a valid user prompt and data source for the function to execute successfully.
- Ensure that the configuration settings include a valid output path for saving the audio file.

Chunk 1165
- In case no audio is generated during the scraping process, a ValueError will be raised to indicate the issue.  
Output Example:
"Audio saved to output.mp3"

Chunk 1166
ClassDef XMLScraperGraph  
XMLScraperGraph: XMLScraperGraph is a scraping pipeline that extracts information from XML files using a natural language model to interpret and answer prompts.  
Attributes:
- prompt (str): The prompt for the graph.

Chunk 1167
- source (str): The source of the graph.
- config (dict): Configuration parameters for the graph.
- schema (BaseModel): The schema for the graph output.
- llm_model: An instance of a language model client, configured for generating answers.

Chunk 1168
- embedder_model: An instance of an embedding model client, configured for generating embeddings.
- verbose (bool): A flag indicating whether to show print statements during execution.

Chunk 1169
- headless (bool): A flag indicating whether to run the graph in headless mode.
- model_token (int): The token limit for the language model.  
Code Description:

Chunk 1170
Code Description:
The XMLScraperGraph class is a subclass of the AbstractGraph class. It represents a scraping pipeline that extracts information from XML files using a natural language model to interpret and answer prompts.

Chunk 1171
The constructor method (init) initializes the XMLScraperGraph object with the provided prompt, source, config, and schema. It also calls the constructor of the AbstractGraph class and sets the input_key attribute based on the file extension of the

Chunk 1172
on the file extension of the source.

Chunk 1173
The _create_graph method creates the graph of nodes representing the workflow for web scraping. It creates FetchNode, RAGNode, and GenerateAnswerNode instances and connects them with edges. The method returns a BaseGraph instance representing the

Chunk 1174
instance representing the web scraping workflow.

Chunk 1175
The run method executes the web scraping process by calling the execute method of the graph. It passes the user_prompt and input_key values to the graph and stores the final state and execution information. The method returns the answer to the

Chunk 1176
returns the answer to the prompt from the final state, or "No answer found." if no answer is found.

Chunk 1177
Note: The XMLScraperGraph class inherits attributes and methods from the AbstractGraph class.  
Output Example:
python
xml_scraper = XMLScraperGraph(
"List me all the attractions in Chioggia.",
"data/chioggia.xml",

Chunk 1178
"data/chioggia.xml",
{"llm": {"model": "gpt-3.5-turbo"}}
)
result = xml_scraper.run()  
FunctionDef init(self, prompt, source, config, schema)

Chunk 1179
init: The function of init is to initialize the XMLScraperGraph object with the provided prompt, source, configuration, and optional schema.  
parameters:
- prompt: A string representing the prompt for the XML scraper.

Chunk 1180
- source: A string indicating the source of the XML data.
- config: A dictionary containing configuration settings for the XML scraper.
- schema: An optional parameter of type BaseModel representing the schema for the XML data.  
Code Description:

Chunk 1181
The init function initializes the XMLScraperGraph object by calling the constructor of its superclass with the provided prompt, configuration, source, and schema parameters. It then sets the input_key attribute based on the source parameter. If the

Chunk 1182
the source parameter. If the source ends with "xml", the input_key is set to "xml"; otherwise, it is set to "xml_dir".

Chunk 1183
Note:
- Ensure that the prompt, source, and config parameters are correctly provided when initializing an instance of the XMLScraperGraph class.
- The schema parameter is optional and can be omitted if not needed for the XML scraping process.

Chunk 1184
- The input_key attribute determines the key to be used for input data based on the source parameter.  
FunctionDef _create_graph(self)  
_create_graph: Creates the graph of nodes representing the workflow for web scraping.  
Parameters:

Chunk 1185
Parameters:
- self: The instance of the XMLScraperGraph class.  
Code Description:

Chunk 1186
The _create_graph function is responsible for creating the graph of nodes that represents the workflow for web scraping. It initializes and configures three nodes: FetchNode, RAGNode, and GenerateAnswerNode. These nodes are connected through

Chunk 1187
nodes are connected through directed edges to define the flow of data and execution in the graph.

Chunk 1188
The fetch_node is created with the input set to "xml | xml_dir" and the output set to ["doc", "link_urls", "img_urls"]. This node is responsible for fetching the HTML content from a specified URL or directory and extracting relevant information such

Chunk 1189
relevant information such as title, body, links, and images.

Chunk 1190
The rag_node is created with the input set to "user_prompt & doc" and the output set to ["relevant_chunks"]. It represents the Retrieval-Augmented Generation (RAG) technique and is responsible for compressing the input tokens, storing the document

Chunk 1191
tokens, storing the document in a vector database for retrieval, and retrieving relevant chunks based on user prompts.

Chunk 1192
The generate_answer_node is created with the input set to "user_prompt & (relevant_chunks | doc)" and the output set to ["answer"]. It generates an answer using a large language model (LLM) based on the user's input and the content extracted from

Chunk 1193
the content extracted from the webpage. It constructs a prompt from the user's input and the scraped content, feeds it to the LLM, and parses the LLM's response to produce an answer.

Chunk 1194
The function then returns an instance of the BaseGraph class, initialized with the created nodes and their connections. The fetch_node is set as the entry point of the graph, and the graph is named after the XMLScraperGraph class.

Chunk 1195
Note: The execution logic and behavior of the graph depend on the implementation of the FetchNode, RAGNode, and GenerateAnswerNode classes, which are not provided in the code snippet.  
Output Example:
python
{
"nodes": [
{
"node_name": "Fetch",

Chunk 1196
{
"node_name": "Fetch",
"input": "xml | xml_dir",
"output": ["doc", "link_urls", "img_urls"]
},
{
"node_name": "RAG",
"input": "user_prompt & doc",
"output": ["relevant_chunks"]
},
{
"node_name": "GenerateAnswer",

Chunk 1197
"input": "user_prompt & (relevant_chunks | doc)",
"output": ["answer"]
}
],
"edges": [
("Fetch", "RAG"),
("RAG", "GenerateAnswer")
],
"entry_point": "Fetch",
"graph_name": "XMLScraperGraph"
}  
FunctionDef run(self)

Chunk 1198
}  
FunctionDef run(self)  
run: The function of run is to execute the web scraping process and return the answer to the prompt.  
parameters:
- self: The instance of the class.  
Code Description:

Chunk 1199
The run function executes the web scraping process by passing the user prompt and the data source to the graph for execution. It then retrieves the final state, including the answer to the prompt, or a default message if no answer is found.

Chunk 1200
In the project structure, the run function is a part of the XMLScraperGraph class in the xml_scraper_graph.py file. It is called within the project by other components to initiate and complete the web scraping process.  
Note:

Chunk 1201
Note:
- Ensure that the prompt and source data are properly set before calling the run function.
- Handle the case where no answer is found appropriately based on the return value.  
Output Example:

Chunk 1202
Output Example:
"Successful web scraping process completed. The answer is: XXX."

Chunk 1203
ClassDef XMLScraperMultiGraph  
XMLScraperMultiGraph: XMLScraperMultiGraph is a scraping pipeline that scrapes a list of URLs and generates answers to a given prompt. It is a subclass of the AbstractGraph class.  
Attributes:

Chunk 1204
Attributes:
- prompt (str): The user prompt to search the internet.
- llm_model (dict): The configuration for the language model.
- embedder_model (dict): The configuration for the embedder model.

Chunk 1205
- headless (bool): A flag to run the browser in headless mode.
- verbose (bool): A flag to display the execution information.
- model_token (int): The token limit for the language model.  
Args:

Chunk 1206
Args:
- prompt (str): The user prompt to search the internet.
- source (List[str]): The source of the graph.
- config (dict): Configuration parameters for the graph.
- schema (Optional[BaseModel]): The schema for the graph output.  
Example:
python

Chunk 1207
Example:
python
search_graph = MultipleSearchGraph(
"What is Chioggia famous for?",
{"llm": {"model": "gpt-3.5-turbo"}}
)
result = search_graph.run()  
Code Description:

Chunk 1208
The XMLScraperMultiGraph class is a subclass of the AbstractGraph class and represents a scraping pipeline that scrapes a list of URLs and generates answers to a given prompt. It is designed to be used in conjunction with the XMLScraperGraph class.

Chunk 1209
the XMLScraperGraph class.

Chunk 1210
The class has a private method _create_graph() that creates a graph of nodes representing the workflow for web scraping and searching. It returns an instance of the BaseGraph class.

Chunk 1211
The class also has a run() method that executes the web scraping and searching process. It takes no arguments and returns the answer to the prompt as a string.

Chunk 1212
Note: The XMLScraperMultiGraph class relies on the XMLScraperGraph class to perform the actual web scraping. It creates an instance of the XMLScraperGraph class and uses it as a node in the graph representation. The XMLScraperGraph class must be

Chunk 1213
XMLScraperGraph class must be properly configured and implemented for the XMLScraperMultiGraph class to work correctly.

Chunk 1214
Output Example:
python
result = "Chioggia is famous for its picturesque canals and its production of radicchio, a type of Italian chicory."  
FunctionDef init(self, prompt, source, config, schema)

Chunk 1215
init: The function of init is to initialize the XMLScraperMultiGraph object with the provided prompt, source, configuration, and schema.  
parameters:
- prompt: A string representing the prompt for the XML scraper.

Chunk 1216
- source: A list of strings containing the data sources for scraping.
- config: A dictionary containing configuration settings.
- schema: An optional parameter representing the schema for the data.  
Code Description:

Chunk 1217
Code Description:
In the init function, the following actions are performed:
1. The function initializes the max_results attribute by retrieving the value from the config dictionary with a default value of 3.

Chunk 1218
2. It checks if all values in the config dictionary are of type string. If true, it creates a shallow copy of the config dictionary; otherwise, it creates a deep copy.
3. It creates a deep copy of the schema if provided.

Chunk 1219
4. Finally, it calls the superclass's (init) constructor with the provided prompt, config, source, and schema parameters.  
Note:

Chunk 1220
Note:
- The function handles the configuration settings by either creating a shallow copy or a deep copy based on the types of values in the config dictionary.

Chunk 1221
- It allows for an optional schema parameter to be passed for defining the data structure.
- Ensure that the prompt, source, and config parameters are provided correctly when initializing the XMLScraperMultiGraph object.

Chunk 1222
FunctionDef _create_graph(self)  
_create_graph: The _create_graph function creates the graph of nodes representing the workflow for web scraping and searching.  
Parameters:
- self: The instance of the XMLScraperMultiGraph class.

Chunk 1223
- No additional parameters.  
Code Description:

Chunk 1224
The _create_graph function is responsible for creating the graph of nodes that represents the workflow for web scraping and searching. It starts by creating an instance of the XMLScraperGraph class, which is responsible for scraping XML files using

Chunk 1225
for scraping XML files using a natural language model. The instance is configured with the provided prompt, source, config, and schema.

Chunk 1226
Next, the function defines three nodes: graph_iterator_node, merge_answers_node, and generate_answer_node. The graph_iterator_node is responsible for instantiating and running multiple graph instances in parallel. It takes the user_prompt and jsons

Chunk 1227
the user_prompt and jsons as input and outputs the results. The merge_answers_node is responsible for merging the answers from multiple graph instances into a single answer. It takes the user_prompt and results as input and outputs the answer. The

Chunk 1228
and outputs the answer. The generate_answer_node is responsible for generating the final answer based on the user_prompt and the relevant_chunks or doc. It outputs the answer.

Chunk 1229
The function then creates a BaseGraph instance with the defined nodes and edges. The nodes are graph_iterator_node and merge_answers_node, and the edge connects graph_iterator_node to merge_answers_node. The entry_point is set to

Chunk 1230
The entry_point is set to graph_iterator_node, and the graph_name is set to the name of the XMLScraperMultiGraph class.

Chunk 1231
Finally, the function returns the created BaseGraph instance.  
Note: The _create_graph function is called by the _create_graph function in the XMLScraperMultiGraph class.  
Output Example:
python
BaseGraph(
nodes=[
graph_iterator_node,

Chunk 1232
nodes=[
graph_iterator_node,
merge_answers_node,
],
edges=[
(graph_iterator_node, merge_answers_node),
],
entry_point=graph_iterator_node,
graph_name="XMLScraperMultiGraph"
)  
FunctionDef run(self)

Chunk 1233
)  
FunctionDef run(self)  
run: The function of run is to execute the web scraping and searching process and return the answer to the prompt.  
parameters:
- None  
Code Description:

Chunk 1234
The run function initiates the web scraping and searching process by passing the user prompt and JSON data to the graph for execution. It then retrieves the final state, including the answer to the prompt, or a default message if no answer is found.

Chunk 1235
if no answer is found.

Chunk 1236
This function plays a crucial role in the XMLScraperMultiGraph class as it is responsible for orchestrating the scraping and searching operations based on the provided inputs.  
Note:

Chunk 1237
Note:
- Ensure that the prompt and source data are properly set before calling this function to obtain accurate results.
- Handle the case where no answer is found by checking the return value appropriately.  
Output Example:

Chunk 1238
Output Example:
If the web scraping and searching process is successful, the function may return: "The answer to the prompt."

Chunk 1239
ClassDef PrintLnHook  
PrintLnHook: The function of PrintLnHook is to print the action name before and after it is executed.  
attributes:
- state: Represents the state of the action.
- action: Represents the specific action being executed.

Chunk 1240
- future_kwargs: Additional keyword arguments.  
Code Description:

Chunk 1241
Code Description:
PrintLnHook is a class that serves as a hook to print the name of an action before it starts and after it finishes execution. It inherits from both PostRunStepHook and PreRunStepHook classes. The class contains two methods:

Chunk 1242
1. pre_run_step: This method prints "Starting action: {action.name}" before the action is executed.
2. post_run_step: This method prints "Finishing action: {action.name}" after the action has been executed.

Chunk 1243
In the project, PrintLnHook is utilized within the _initialize_burr_app method of the BurrBridge class in the burr_bridge.py file. When initializing a Burr application, an instance of PrintLnHook is added to the list of hooks. This allows the action

Chunk 1244
hooks. This allows the action names to be printed before and after their execution, providing visibility into the workflow of the application.

Chunk 1245
Note: Developers can leverage PrintLnHook to add logging functionality to actions within a Burr application, aiding in debugging and monitoring the application's behavior during runtime.  
FunctionDef pre_run_step(self)

Chunk 1246
pre_run_step: The function of pre_run_step is to print a message indicating the starting action.  
parameters:
- state: Represents the current state of the system.
- action: Represents the action being performed.

Chunk 1247
- future_kwargs: Additional keyword arguments that may be passed to the function.  
Code Description:

Chunk 1248
Code Description:
The pre_run_step function takes in the current state, the action to be performed, and any additional keyword arguments. It then prints a message indicating the starting action by displaying the name of the action.  
Note:

Chunk 1249
Note:
Ensure that the required parameters are correctly provided when calling this function to avoid any errors in the output.  
FunctionDef post_run_step(self)

Chunk 1250
post_run_step: The function of post_run_step is to print a message indicating the finishing action with the name of the action.  
parameters:
- state: Represents the state of the action.
- action: Represents the specific action being executed.

Chunk 1251
- future_kwargs: Additional keyword arguments that may be passed to the function.  
Code Description:

Chunk 1252
Code Description:
The post_run_step function takes in the state, action, and any additional keyword arguments. It then prints a message using f-string formatting to indicate the finishing action by displaying the name of the action.  
Note:

Chunk 1253
Note:
Ensure that the action parameter is passed correctly to provide the accurate finishing action message.  
ClassDef BurrNodeBridge  
The function of BurrNodeBridge is to act as a bridge class that converts a base graph node to a Burr action.

Chunk 1254
attributes:
- parameter1: node (base graph node)

Chunk 1255
In the project, the BurrNodeBridge class is utilized within the BurrBridge class in the _create_actions method. This method creates Burr actions from base graph nodes by instantiating BurrNodeBridge objects for each node and storing them in a

Chunk 1256
node and storing them in a dictionary with the node name as keys.

Chunk 1257
Note:
Developers can use BurrNodeBridge to seamlessly convert base graph nodes to Burr actions, facilitating the integration of different components within the project.  
Output Example:
python
{

Chunk 1258
Output Example:
python
{
'node_name1': <BurrNodeBridge object at 0x0000000000>,
'node_name2': <BurrNodeBridge object at 0x0000000001>,
...
}  
FunctionDef init(self, node)  
init: The function of init is to instantiate a BurrNodeBridge object.

Chunk 1259
parameters:
- self: The instance of the class.
- node: The node parameter to be assigned to the object.  
Code Description:

Chunk 1260
Code Description:
The init function initializes a BurrNodeBridge object by assigning the provided node parameter to the object's node attribute. It also calls the superclass's init method using super().  
Note:

Chunk 1261
Note:
Ensure that a valid node parameter is provided when instantiating a BurrNodeBridge object to avoid any potential errors during initialization.  
FunctionDef reads(self)

Chunk 1262
FunctionDef reads(self)  
reads: The function of reads is to extract keys from the input of a node by parsing a boolean expression.  
parameters:
- None  
Code Description:

Chunk 1263
The reads function in the BurrNodeBridge class utilizes the parse_boolean_expression function to extract keys from the input of a node. It calls the parse_boolean_expression function passing the node input as a parameter. The

Chunk 1264
input as a parameter. The parse_boolean_expression function parses the boolean expression and returns a list of unique keys used in the expression. The reads function then returns this list of keys.

Chunk 1265
This function plays a crucial role in isolating and identifying the keys used in a boolean expression, providing developers with a way to work with the extracted keys in their applications.  
Note:

Chunk 1266
Note:
Developers can use the reads function to analyze boolean expressions and extract keys from the input of a node for further processing.  
Output Example:

Chunk 1267
Output Example:
If the input boolean expression is "A AND B OR C", the reads function may return ['A', 'B', 'C'] as the list of unique keys used in the expression.  
FunctionDef run(self, state)

Chunk 1268
run: The function of run is to execute the node with the provided state and return the result state.  
parameters:
- state: The current state of the node.
- **run_kwargs: Additional keyword arguments for the execution.  
Code Description:

Chunk 1269
The run function within the BurrNodeBridge class takes the current state as input and extracts specific keys from the state based on the reads attribute. It then executes the node using the extracted inputs along with any additional keyword

Chunk 1270
with any additional keyword arguments provided. The result state from the node execution is returned by the function.

Chunk 1271
This function serves as a crucial step in the workflow of the BurrNodeBridge class, as it orchestrates the execution of the node with the necessary inputs and parameters, facilitating the processing and transformation of data within the integration.

Chunk 1272
data within the integration.

Chunk 1273
Note:
Developers can utilize the run function to trigger the execution of the node within the BurrNodeBridge, providing the required state and any extra parameters needed for the node operation.  
Output Example:

Chunk 1274
Output Example:
If the node execution is successful, the run function may return a dictionary representing the updated state after the node processing.  
FunctionDef writes(self)

Chunk 1275
FunctionDef writes(self)  
writes: The function of writes is to return the output of the node.  
parameters: This Function does not take any parameters.

Chunk 1276
Code Description: The writes function is a method that belongs to the BurrNodeBridge class. It returns the output of the node that is stored in the 'output' attribute of the class instance.

Chunk 1277
Note: Ensure that the node has been properly initialized and contains the necessary output before calling this function to avoid any potential errors.  
Output Example:

Chunk 1278
Output Example:
If the output attribute of the node contains ['data1', 'data2', 'data3'], calling writes() will return:
['data1', 'data2', 'data3']  
FunctionDef update(self, result, state)

Chunk 1279
update: The function of update is to update the state with the values provided in the result dictionary.  
parameters:
- result: A dictionary containing the values to update the state with.

Chunk 1280
- state: An object of the State class representing the current state.  
Code Description:

Chunk 1281
The update function takes in a dictionary named result and an object of the State class named state as parameters. It then updates the state object with the key-value pairs present in the result dictionary using the update method. The update method

Chunk 1282
method. The update method in Python allows updating a dictionary with key-value pairs from another dictionary.

Chunk 1283
Note:
Make sure that the result parameter is a dictionary and the state parameter is an instance of the State class.  
Output Example:

Chunk 1284
If the result dictionary is {'key1': 'value1', 'key2': 'value2'} and the state object contains {'key3': 'value3'}, the updated state object after calling the update function would be {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}.

Chunk 1285
FunctionDef get_source(self)  
get_source: The function of get_source is to retrieve the source code of the class to which the node belongs.  
parameters:
- self: The instance of the class.  
Code Description:

Chunk 1286
Code Description:
The get_source function utilizes the inspect module to retrieve the source code of the class to which the node attribute of the current instance belongs. It returns the source code as a string.  
Note:

Chunk 1287
Note:
It is important to ensure that the node attribute of the instance is properly initialized before calling the get_source function to avoid any potential errors related to the class inspection.  
Output Example:

Chunk 1288
Output Example:
"class BurrNodeBridge:\n    def init(self):\n        pass\n    def some_method(self):\n        return something"  
FunctionDef parse_boolean_expression(expression)

Chunk 1289
parse_boolean_expression: The function of parse_boolean_expression is to parse a boolean expression and extract the keys used in the expression without boolean operators.  
parameters:
- expression (str): The boolean expression to parse.

Chunk 1290
Code Description:

Chunk 1291
The parse_boolean_expression function takes a boolean expression as input and uses a regular expression to extract all unique keys from the expression. It then returns a list of unique keys used in the expression by removing any duplicates. This

Chunk 1292
removing any duplicates. This function helps in isolating and identifying the keys used in a boolean expression.

Chunk 1293
This function is called by the reads method in the BurrNodeBridge class in the BurrNodeBridge object. The reads method utilizes parse_boolean_expression to extract keys from the input of a node.  
Note:

Chunk 1294
Note:
Developers can use this function to analyze boolean expressions and work with the extracted keys in their applications.  
Output Example:

Chunk 1295
Output Example:
If the input boolean expression is "A AND B OR C", the function may return ['A', 'B', 'C'] as the list of unique keys used in the expression.  
ClassDef BurrBridge

Chunk 1296
ClassDef BurrBridge  
BurrBridge: The function of BurrBridge is to act as a bridge class to integrate Burr into ScrapeGraphAI graphs.  
Attributes:
- base_graph (BaseGraph): The base graph to convert to a Burr application.

Chunk 1297
- burr_config (dict): Configuration parameters for the Burr application.
- tracker (LocalTrackingClient): The tracking client for the Burr application.
- app_instance_id (str): The instance ID for the Burr application.

Chunk 1298
- burr_inputs (dict): The inputs for the Burr application.
- burr_app (Application): The Burr application instance.  
Code Description:

Chunk 1299
The BurrBridge class serves as a bridge to integrate Burr functionality into ScrapeGraphAI graphs. It takes a base graph and Burr configuration as input parameters. The class initializes various attributes such as the base graph, Burr configuration,

Chunk 1300
graph, Burr configuration, tracker, app instance ID, Burr inputs, and Burr application instance. The class provides methods to initialize the Burr application, create Burr actions and transitions from the base graph nodes and edges, convert Burr

Chunk 1301
nodes and edges, convert Burr state to a dictionary state, and execute the Burr application with an initial state.

Chunk 1302
When the execute method is called, the Burr application is initialized, and the final state of the Burr application is returned after running the application with the provided initial state.

Chunk 1303
The BurrBridge class is utilized in the BaseGraph class to execute the graph either using BurrBridge or the standard method based on the 'use_burr' flag.  
Note:

Chunk 1304
Note:
Developers can utilize the BurrBridge class to seamlessly integrate Burr functionality into ScrapeGraphAI graphs by providing the base graph and Burr configuration.  
Output Example:
{'key1': 'value1', 'key2': 'value2', ...}

Chunk 1305
FunctionDef init(self, base_graph, burr_config)  
init: The function of init is to initialize the BurrBridge object with the provided base graph and Burr configuration.  
parameters:
- base_graph: The base graph object to be used by the BurrBridge.

Chunk 1306
- burr_config: The configuration settings for the BurrBridge.  
Code Description:
In this function, the BurrBridge object is initialized with the following attributes:
- base_graph: Assigned with the provided base graph.

Chunk 1307
- burr_config: Assigned with the provided Burr configuration.
- project_name: Set to the value of "project_name" from burr_config, defaulting to "scrapegraph: {}" if not provided.

Chunk 1308
- app_instance_id: Set to the value of "app_instance_id" from burr_config, defaulting to "default-instance" if not provided.
- burr_inputs: Set to the value of "inputs" from burr_config, defaulting to an empty dictionary if not provided.

Chunk 1309
- burr_app: Initialized as None.  
Note:
- This function is crucial for setting up the BurrBridge object with the necessary parameters for further operations.

Chunk 1310
- Ensure that the base graph and Burr configuration are correctly provided to avoid any unexpected behavior during initialization.  
FunctionDef _initialize_burr_app(self, initial_state)

Chunk 1311
_initialize_burr_app: The function of _initialize_burr_app is to initialize a Burr application from the base graph.  
parameters:
- initial_state (dict): The initial state of the Burr application.  
Code Description:

Chunk 1312
The _initialize_burr_app function sets up a Burr application by creating actions, transitions, and hooks. It initializes the application context, state, and builder to construct the Burr application instance. The function also handles the addition

Chunk 1313
also handles the addition of a tracker and spawning parent if an application context exists. Finally, it returns the built Burr application.

Chunk 1314
This function is an essential part of the BurrBridge class in the burr_bridge.py file. It leverages the _create_actions and _create_transitions functions to generate actions and transitions based on the base graph. Additionally, it includes a

Chunk 1315
Additionally, it includes a PrintLnHook to print action names before and after execution, enhancing visibility into the application workflow.

Chunk 1316
Note:

Chunk 1317
Developers can utilize _initialize_burr_app to create and configure a Burr application with actions, transitions, and hooks. It provides a structured approach to setting up a Burr application from the base graph, ensuring proper initialization and

Chunk 1318
proper initialization and execution.

Chunk 1319
Output Example:
python
{
'actions': {...},
'transitions': [...],
'hooks': [PrintLnHook()],
'state': {...},
'application_context': {...},
'builder': ApplicationBuilder(),
...
}  
FunctionDef _create_actions(self)

Chunk 1320
_create_actions: The function of _create_actions is to create Burr actions from the base graph nodes.  
parameters:
- self: The instance of the class.  
Code Description:

Chunk 1321
The _create_actions function iterates over the nodes in the base graph and instantiates BurrNodeBridge objects for each node. It then stores these objects in a dictionary with the node name as keys. This function facilitates the conversion of base

Chunk 1322
the conversion of base graph nodes to Burr actions within the BurrBridge class.

Chunk 1323
In the BurrNodeBridge class, the BurrNodeBridge objects are initialized with the provided base graph node, allowing for dynamic declaration of inputs and outputs without relying on function parsing. The BurrNodeBridge class provides methods such as

Chunk 1324
provides methods such as reads, run, writes, update, and get_source to handle the conversion process effectively.

Chunk 1325
The _create_actions function is called within the _initialize_burr_app method of the BurrBridge class to set up a Burr application from the base graph. By utilizing the actions created in _create_actions, the Burr application is configured with the

Chunk 1326
is configured with the necessary actions, transitions, and hooks for execution.

Chunk 1327
Note:
Developers can use _create_actions to automate the creation of Burr actions based on the nodes in the base graph, streamlining the integration process within the project.  
Output Example:
python
{

Chunk 1328
Output Example:
python
{
'node_name1': <BurrNodeBridge object at 0x0000000000>,
'node_name2': <BurrNodeBridge object at 0x0000000001>,
...
}  
FunctionDef _create_transitions(self)

Chunk 1329
_create_transitions: The function of _create_transitions is to create Burr transitions from the base graph edges.  
parameters:
- self: The instance of the class.  
Code Description:

Chunk 1330
Code Description:
The _create_transitions function iterates through the edges of the base graph and creates transitions between Burr actions. It returns a list of tuples representing the transitions.

Chunk 1331
This function is called within the _initialize_burr_app method of the BurrBridge class. In _initialize_burr_app, after initializing the Burr application, _create_transitions is invoked to generate transitions between Burr actions based on the base

Chunk 1332
actions based on the base graph edges.

Chunk 1333
Note:
Ensure that the base graph is properly initialized before calling this function to create transitions.  
Output Example:
[('node1', 'node2', default), ('node2', 'node3', default), ...]  
FunctionDef _convert_state_from_burr(self, burr_state)

Chunk 1334
_convert_state_from_burr: The function of _convert_state_from_burr is to convert a Burr state object into a dictionary state.  
parameters:
- burr_state (State): The Burr state to convert.  
Code Description:

Chunk 1335
The _convert_state_from_burr function takes a Burr state object as input and converts it into a dictionary state by iterating over the keys of the Burr state object and retrieving their corresponding values. The function then returns the dictionary

Chunk 1336
then returns the dictionary state instance.

Chunk 1337
This function is called within the execute method of the BurrBridge class in the burr_bridge.py file. In the execute method, the Burr application is initialized with an initial state, and after running the application, the final state is obtained.

Chunk 1338
the final state is obtained. The _convert_state_from_burr function is used to convert this final state from a Burr state object to a dictionary state before returning it as the final output of the execute method.

Chunk 1339
Note:
Ensure that the burr_state object passed to the _convert_state_from_burr function is an instance of the State class.  
Output Example:
{
'key1': value1,
'key2': value2,
...
}  
FunctionDef execute(self, initial_state)

Chunk 1340
execute: The function of execute is to execute the Burr application with the given initial state.  
parameters:
- initial_state (dict): The initial state to pass to the Burr application.  
Code Description:

Chunk 1341
The execute function initializes the Burr application with the provided initial state. It then runs the Burr application, halting after reaching the final nodes specified in the final_nodes list. The function retrieves the last action, result, and

Chunk 1342
the last action, result, and final state of the application. Finally, it converts the final state from a Burr state object to a dictionary state using the _convert_state_from_burr function before returning it as the output.

Chunk 1343
The execute function is a crucial part of the BurrBridge class in the burr_bridge.py file. It interacts with the _initialize_burr_app function to set up the Burr application and with the _convert_state_from_burr function to convert the Burr state to

Chunk 1344
to convert the Burr state to a dictionary state for output.

Chunk 1345
Note:

Chunk 1346
Developers can utilize the execute function to execute a Burr application with a specified initial state and retrieve the final state after execution. It provides a structured approach to running the Burr application and handling the final state

Chunk 1347
and handling the final state conversion.

Chunk 1348
Output Example:
python
{
'key1': value1,
'key2': value2,
...
}

Chunk 1349
ClassDef IndexifyNode  
IndexifyNode: The function of IndexifyNode is to index the content present in the state.  
attributes:
- input: str (Boolean expression defining the input keys needed from the state)

Chunk 1350
- output: List[str] (List of output keys to be updated in the state)
- node_config: Optional[dict] (Additional configuration for the node)
- node_name: str (The unique identifier name for the node, defaulting to "Indexify")

Chunk 1351
- verbose: bool (A flag indicating whether to show print statements during execution)  
Code Description:

Chunk 1352
IndexifyNode is a class responsible for indexing content present in the state. It inherits from the BaseNode class, which is an abstract base class for nodes in a graph-based workflow. The constructor initializes the node with input, output, node

Chunk 1353
node with input, output, node configuration, and node name. The execute method executes the node's logic to index the content by fetching data from the state based on input keys and updating the state with the indexed content.

Chunk 1354
This class utilizes the get_input_keys method to determine the necessary state keys based on the input specification. It also contains helper methods for validating input keys, parsing input keys expression, and updating the node configuration. The

Chunk 1355
the node configuration. The execute method logs the execution of the node and updates the state with the indexed content.

Chunk 1356
Note: Ensure to provide valid input keys in the state to successfully execute the indexing logic.  
Output Example:
{'output_key': True}  
FunctionDef init(self, input, output, node_config, node_name)

Chunk 1357
init: The function of init is to initialize an instance of the IndexifyNode class with specified input, output, node configuration, and node name.  
parameters:
- self: The instance of the class.

Chunk 1358
- input: A string representing the input data for the node.
- output: A list of strings representing the output data for the node.
- node_config: An optional dictionary containing configuration settings for the node (default is None).

Chunk 1359
- node_name: A string representing the name of the node (default is "Indexify").  
Code Description:

Chunk 1360
The init function initializes an instance of the IndexifyNode class by calling the constructor of the superclass with the provided parameters. It sets the 'verbose' attribute based on the 'verbose' key in the node_config dictionary, defaulting to

Chunk 1361
dictionary, defaulting to False if the key is not present or if node_config is None.

Chunk 1362
Note:
- The init function is responsible for setting up the initial state of the IndexifyNode instance.
- The 'verbose' attribute controls the verbosity of the node, allowing for different levels of output information based on the configuration.

Chunk 1363
FunctionDef execute(self, state)  
execute: The function of execute is to execute the node's logic to index the content present in the state.
parameters:

Chunk 1364
parameters:
- state (dict): The current state of the graph. The input keys will be used to fetch the correct data from the state.  
Code Description:

Chunk 1365
The execute function is responsible for executing the logic of the node to index the content available in the state. It begins by logging the execution of the node. The function then utilizes the get_input_keys method from the BaseNode class to

Chunk 1366
from the BaseNode class to determine the necessary input keys based on the input expression provided during node initialization. These input keys are used to fetch relevant data from the state. Once the input data is retrieved, the function proceeds

Chunk 1367
the function proceeds to index the content, updating the state with the output key containing the parsed content chunks. In case the required input keys are not found in the state, a KeyError is raised to indicate missing information necessary for

Chunk 1368
information necessary for parsing the content.

Chunk 1369
The execute function is a crucial part of the IndexifyNode's functionality within the project. It ensures that the content indexing process is carried out effectively based on the provided input keys and state data. By updating the state with the

Chunk 1370
updating the state with the indexified content, the function plays a significant role in the overall data processing flow of the project.

Chunk 1371
Note:
Developers utilizing the execute function should ensure that the input keys specified during node initialization are present in the state to avoid KeyError exceptions and enable successful content indexing.  
Output Example:

Chunk 1372
Output Example:
{'output_key': True}

Chunk 1373
ClassDef Anthropic  
Anthropic: The function of Anthropic is to serve as a wrapper for the ChatAnthropic class, providing default configuration and the ability to be extended with additional methods if necessary.  
attributes:

Chunk 1374
attributes:
- llm_config (dict): Configuration parameters for the language model.  
Code Description:

Chunk 1375
The Anthropic class is designed as a wrapper for the ChatAnthropic class. It takes a dictionary llm_config as an argument during initialization, which contains configuration parameters for the language model. The class inherits from ChatAnthropic

Chunk 1376
inherits from ChatAnthropic and initializes the ChatAnthropic class with the provided llm_config parameters.

Chunk 1377
In the project structure, the Anthropic class is utilized in the abstract_graph.py file within the _create_llm method of the AbstractGraph class. Within the _create_llm method, different language model instances are created based on the model

Chunk 1378
created based on the model specified in the llm_config parameters. If the model is identified as starting with "claude", an instance of the Anthropic class is returned, utilizing the llm_params for configuration.

Chunk 1379
Note:

Chunk 1380
Developers can utilize the Anthropic class to create instances of language models with default configurations and the option to extend functionality as needed. The class plays a specific role in the project's language model instantiation process,

Chunk 1381
model instantiation process, particularly when dealing with models identified with the "claude" prefix.

Chunk 1382
FunctionDef init(self, llm_config)  
init: The function of init is to initialize the object with the provided llm_config dictionary.  
parameters:
- llm_config: A dictionary containing configuration settings.  
Code Description:

Chunk 1383
The init function is a constructor method that initializes the object with the configuration settings provided in the llm_config dictionary. It calls the constructor of the superclass using the ** operator to unpack the llm_config dictionary.

Chunk 1384
Note:
Make sure to provide a valid dictionary containing the required configuration settings when initializing an instance of this object.

Chunk 1385
ClassDef AzureOpenAI  
AzureOpenAI: The function of AzureOpenAI is to serve as a wrapper for the AzureChatOpenAI class with default configuration and the ability to be extended with additional methods if required.  
attributes:

Chunk 1386
attributes:
- llm_config (dict): Configuration parameters for the language model.  
Code Description:

Chunk 1387
AzureOpenAI is a class that extends the AzureChatOpenAI class. It acts as a wrapper providing default configuration settings. The class takes a dictionary parameter, llm_config, during initialization to set up the language model configuration. This

Chunk 1388
model configuration. This class can be further extended with additional methods as needed.

Chunk 1389
In the project, AzureOpenAI is utilized within the AbstractGraph class to create a large language model instance based on the provided configuration parameters. The _create_llm method in the AbstractGraph class instantiates AzureOpenAI when the

Chunk 1390
AzureOpenAI when the model name contains "azure". This demonstrates the usage of AzureOpenAI within the project for language model creation.

Chunk 1391
Note:

Chunk 1392
Developers can utilize AzureOpenAI to streamline the configuration and extension of the AzureChatOpenAI class for language model operations. Ensure to provide the required llm_config dictionary parameter during initialization to set up the language

Chunk 1393
to set up the language model configuration correctly.

Chunk 1394
FunctionDef init(self, llm_config)  
init: The function of init is to initialize the AzureOpenAI object with the provided llm_config dictionary.  
parameters:
- llm_config: A dictionary containing configuration settings for the AzureOpenAI object.

Chunk 1395
Code Description:
The init function takes in a dictionary llm_config as a parameter and initializes the AzureOpenAI object by passing the llm_config dictionary to the parent class using the super() function.  
Note:

Chunk 1396
Note:
Ensure that the llm_config dictionary contains the necessary configuration settings required for the AzureOpenAI object to function properly.

Chunk 1397
ClassDef Bedrock  
Bedrock: The function of Bedrock is to serve as a wrapper for the ChatBedrock class, providing default configuration and the ability to be extended with additional methods if necessary.  
attributes:

Chunk 1398
attributes:
- llm_config: Configuration parameters for the language model.  
Code Description:

Chunk 1399
The Bedrock class acts as a wrapper for the ChatBedrock class. It is initialized with the provided configuration parameters, allowing for customization and extension of functionality through additional methods. By inheriting from the ChatBedrock

Chunk 1400
from the ChatBedrock class, Bedrock encapsulates the core functionality while offering the flexibility to tailor the behavior based on the specific requirements defined in the llm_config parameter.

Chunk 1401
In the project structure, Bedrock is utilized within the AbstractGraph class to create instances of language models based on the configuration provided. The _create_llm method in AbstractGraph dynamically selects the appropriate language model based

Chunk 1402
language model based on the model name specified in the llm_config. When the model name includes "bedrock," the method instantiates a Bedrock object with the necessary parameters, such as the client, model ID, and model-specific settings. This

Chunk 1403
model-specific settings. This demonstrates how Bedrock is integrated into the broader functionality of language model instantiation within the project.

Chunk 1404
The Bedrock class serves as a foundational component for managing language models within the project's architecture. Its role in providing a customizable wrapper for the ChatBedrock class highlights its importance in facilitating the interaction

Chunk 1405
facilitating the interaction with language models while maintaining a structured and extensible design.

Chunk 1406
Note: Developers can leverage the Bedrock class to streamline the configuration and utilization of language models within the project. By extending the class with additional methods, specific functionalities can be incorporated to enhance the

Chunk 1407
incorporated to enhance the overall capabilities of language model management.

Chunk 1408
FunctionDef init(self, llm_config)  
init: The function of init is to serve as a wrapper for the ChatBedrock class, providing default configuration and the ability to be extended with additional methods if necessary.  
parameters:

Chunk 1409
parameters:
- llm_config (dict): Configuration parameters for the language model.  
Code Description:

Chunk 1410
Code Description:
The init function initializes the Bedrock object by calling the superclass (ChatBedrock) with the provided configuration parameters (llm_config) using the kwargs syntax.  
Note:

Chunk 1411
Note:
Developers can utilize this function to create instances of the Bedrock class with specific configuration parameters for the language model.

Chunk 1412
ClassDef DeepSeek  
DeepSeek: The function of DeepSeek is to act as a wrapper for the ChatOpenAI class, providing default configuration and the ability to be extended with additional methods if necessary.  
attributes:

Chunk 1413
attributes:
- llm_config (dict): Configuration parameters for the language model.  
Code Description:

Chunk 1414
The DeepSeek class serves as a wrapper for the ChatOpenAI class, utilizing an OpenAI-like API. It is initialized with a dictionary of llm_config, which contains configuration parameters for the language model. The class inherits from the ChatOpenAI

Chunk 1415
inherits from the ChatOpenAI class and passes the llm_config parameters to the parent class during initialization.

Chunk 1416
In the project structure, the DeepSeek class is utilized within the AbstractGraph class for creating language model instances based on specific configurations. The AbstractGraph class contains methods like _create_llm and _create_default_embedder,

Chunk 1417
and _create_default_embedder, where DeepSeek is instantiated based on the model provided in the llm_config parameters.

Chunk 1418
Note:
Developers can leverage the DeepSeek class to customize and extend functionality related to language models using an OpenAI-like API. Ensure to provide the required llm_config parameters when initializing an instance of the DeepSeek class.

Chunk 1419
FunctionDef init(self, llm_config)  
init: The function of init is to initialize the DeepSeek object with the provided llm_config dictionary.  
parameters:
- llm_config: A dictionary containing configuration settings for the DeepSeek object.

Chunk 1420
Code Description:

Chunk 1421
The init function is a constructor method for the DeepSeek class. It takes in a dictionary named llm_config as a parameter. Inside the function, it calls the constructor of the superclass (presumably to initialize inherited attributes) by unpacking

Chunk 1422
attributes) by unpacking the llm_config dictionary using **llm_config.

Chunk 1423
Note:
It is important to ensure that the llm_config dictionary contains the necessary configuration settings required for the DeepSeek object to function properly.

Chunk 1424
ClassDef Ernie  
Ernie: The function of Ernie is to serve as a wrapper for the ErnieBotChat class with default configuration and the ability to be extended with additional methods.  
attributes:

Chunk 1425
attributes:
- llm_config (dict): Configuration parameters for the language model.  
Code Description:

Chunk 1426
The Ernie class is designed as a wrapper for the ErnieBotChat class, providing default configuration settings. It takes a dictionary llm_config as an argument during initialization to configure the language model. The class inherits from

Chunk 1427
The class inherits from ErnieBotChat and initializes it with the provided llm_config parameters.

Chunk 1428
In the project, the _create_llm method in the GraphBuilder and AbstractGraph classes calls the Ernie class when the model name in the configuration matches 'ernie'. This demonstrates the usage of the Ernie class within the project for creating

Chunk 1429
the project for creating instances of language models based on specific configurations.

Chunk 1430
Note:

Chunk 1431
Developers can utilize the Ernie class to easily create instances of the ErnieBotChat class with default configurations and the flexibility to add more methods if required. Ensure to provide the necessary configuration parameters in the llm_config

Chunk 1432
parameters in the llm_config dictionary when initializing the Ernie class.

Chunk 1433
FunctionDef init(self, llm_config)  
init: The function of init is to initialize the object with the provided llm_config dictionary.  
parameters:
- llm_config: A dictionary containing configuration settings for the object.  
Code Description:

Chunk 1434
The init function is a constructor method that initializes the object with the configuration settings provided in the llm_config dictionary. It calls the constructor of the superclass using the **kwargs syntax to unpack the dictionary and pass the

Chunk 1435
the dictionary and pass the configuration settings to the superclass constructor.

Chunk 1436
Note:
- Ensure that the llm_config parameter is a dictionary when calling this function to avoid any errors related to parameter type mismatch.

Chunk 1437
ClassDef Gemini  
Gemini: The function of Gemini is to serve as a wrapper for the Gemini class with default configuration and the ability to be extended with additional methods if necessary.  
attributes:

Chunk 1438
attributes:
- llm_config (dict): Configuration parameters for the language model (e.g., model="gemini-pro")  
Code Description:

Chunk 1439
The Gemini class acts as a wrapper for the Gemini class, providing default configuration settings. It takes in a dictionary llm_config as a parameter during initialization. The constructor of the class replaces the "api_key" key with

Chunk 1440
the "api_key" key with "google_api_key" in the llm_config dictionary and then calls the constructor of the superclass ChatGoogleGenerativeAI with the updated configuration.

Chunk 1441
The Gemini class can be utilized to instantiate a Gemini object with specific configuration parameters for the language model. It allows for easy customization and extension of functionality if required.

Chunk 1442
In the project, the _create_llm method in the AbstractGraph class instantiates a Gemini object when the model name in the llm_config matches "gemini". This demonstrates how the Gemini class is integrated into the project's graph creation process

Chunk 1443
graph creation process based on the specified language model.

Chunk 1444
The _create_default_embedder method in the AbstractGraph class also showcases the usage of the Gemini class by checking if the llm_model is an instance of Gemini and creating GoogleGenerativeAIEmbeddings accordingly.  
Note:

Chunk 1445
Developers can leverage the Gemini class to work with the Gemini language model by providing the necessary configuration parameters. It offers a convenient way to interact with the Gemini model within the project's graph building and embedding

Chunk 1446
graph building and embedding processes.

Chunk 1447
FunctionDef init(self, llm_config)  
init: The function of init is to initialize the Gemini class with the provided configuration.  
parameters:
- llm_config: A dictionary containing configuration parameters.  
Code Description:

Chunk 1448
The init function takes a dictionary llm_config as a parameter. It replaces the key "api_key" with "google_api_key" in the llm_config dictionary and then calls the superclass's (init) method with the unpacked llm_config dictionary.  
Note:

Chunk 1449
Note:
Ensure that the llm_config dictionary contains the necessary configuration parameters for the Gemini class initialization.

Chunk 1450
ClassDef Groq  
Groq: The function of Groq is to serve as a wrapper for the Groq class that provides default configuration and can be extended with additional methods if needed.  
attributes:

Chunk 1451
attributes:
- llm_config (dict): Configuration parameters for the language model (e.g., model="llama3-70b-8192")  
Code Description:

Chunk 1452
The Groq class is designed as a wrapper for the Groq class, offering default configuration settings and the potential for extension with additional methods. It takes a dictionary parameter, llm_config, which includes configuration parameters for the

Chunk 1453
parameters for the language model. The class initializes by calling the parent class ChatGroq with the provided llm_config parameters.

Chunk 1454
In the project structure, the Groq class is utilized within the AbstractGraph class to create instances of different language models based on the configuration provided. The _create_llm method in the AbstractGraph class handles the instantiation of

Chunk 1455
handles the instantiation of various language model instances, including the Groq class, based on specific model names.

Chunk 1456
Note:

Chunk 1457
Developers can utilize the Groq class to easily configure and extend the functionality of the Groq class for language model operations within the project. Ensure that the llm_config parameter is correctly formatted with the necessary configuration

Chunk 1458
the necessary configuration parameters for the language model.

Chunk 1459
FunctionDef init(self, llm_config)  
init: The function of init is to initialize an object with the provided llm_config dictionary.  
parameters:
- llm_config: A dictionary containing configuration settings.  
Code Description:

Chunk 1460
The init function takes in a dictionary named llm_config as a parameter and initializes the object using the values from this dictionary by unpacking it with **llm_config. This allows for setting up the object with specific configuration parameters

Chunk 1461
configuration parameters provided in the dictionary.

Chunk 1462
Note:
Ensure that the llm_config dictionary contains the necessary configuration settings required for the object initialization to avoid any errors during the initialization process.

Chunk 1463
ClassDef HuggingFace  
HuggingFace: The function of HuggingFace is to serve as a wrapper for the HuggingFace class with default configuration and the ability to be extended with additional methods if required.  
attributes:

Chunk 1464
attributes:
- llm_config: Configuration parameters for the language model.  
Code Description:

Chunk 1465
The HuggingFace class is designed as a wrapper for the HuggingFace class, providing default configuration settings. It can be extended with additional methods as needed. The class takes a dictionary llm_config as an argument during initialization,

Chunk 1466
during initialization, which contains configuration parameters for the language model. The class inherits from ChatHuggingFace and initializes the HuggingFace object with the provided configuration parameters.

Chunk 1467
In the project, the HuggingFace class is utilized within the AbstractGraph class for creating a large language model instance based on the configuration provided. The _create_llm method in the AbstractGraph class handles the instantiation of various

Chunk 1468
the instantiation of various language model classes based on the model name specified in the configuration. When the model name contains "hugging_face", the method creates an instance of the HuggingFace class with the provided configuration

Chunk 1469
the provided configuration parameters.

Chunk 1470
Note:

Chunk 1471
Developers can utilize the HuggingFace class to easily work with the HuggingFace language model by providing custom configuration parameters. The class offers a convenient way to interact with the HuggingFace functionality within the project's

Chunk 1472
within the project's graph-related components.

Chunk 1473
FunctionDef init(self, llm_config)  
init: The function of init is to initialize the HuggingFace class with the provided llm_config dictionary.  
parameters:
- llm_config: A dictionary containing configuration settings for the HuggingFace model.

Chunk 1474
Code Description:
The init function takes in a dictionary llm_config as a parameter and initializes the HuggingFace class by passing the llm_config dictionary using the ** unpacking operator (**llm_config).  
Note:

Chunk 1475
Note:
- Ensure that the llm_config dictionary is properly formatted with the required configuration settings before initializing the HuggingFace class.

Chunk 1476
ClassDef Ollama  
Ollama: The function of Ollama is to serve as a wrapper for the ChatOllama class, providing default configuration and the ability to extend with additional methods if needed.  
Attributes:

Chunk 1477
Attributes:
- llm_config (dict): Configuration parameters for the language model.  
Code Description:

Chunk 1478
Code Description:
The Ollama class is a wrapper for the ChatOllama class, providing default configuration and the ability to extend with additional methods if needed. It inherits from the ChatOllama class.

Chunk 1479
The constructor method __init__ takes in a llm_config parameter, which is a dictionary containing the configuration parameters for the language model. It then calls the constructor of the parent class using the super() function and passes the

Chunk 1480
function and passes the llm_config as keyword arguments.

Chunk 1481
The _create_llm method is a private method that creates a large language model instance based on the provided configuration. It takes in the llm_config parameter, which is a dictionary containing the configuration parameters for the language model.

Chunk 1482
for the language model. It returns an instance of the language model client based on the model name specified in the llm_config. If the model name is not supported, it raises a KeyError.

Chunk 1483
The _create_default_embedder method is another private method that creates an embedding model instance based on the chosen language model. It returns an instance of the embedding model client based on the type of the language model specified in the

Chunk 1484
model specified in the llm_model attribute. If the language model is not supported, it raises a ValueError.

Chunk 1485
Note: The Ollama class is designed to be a wrapper for the ChatOllama class, providing default configuration and the ability to extend with additional methods if needed. It is important to provide the correct configuration parameters when creating

Chunk 1486
parameters when creating an instance of the Ollama class to ensure proper functionality.

Chunk 1487
FunctionDef init(self, llm_config)  
init: The function of init is to initialize the Ollama object with the provided llm_config dictionary.  
parameters:
- llm_config: A dictionary containing configuration settings for the Ollama object.

Chunk 1488
Code Description:

Chunk 1489
The init function is a constructor method for the Ollama class. It takes in a dictionary named llm_config as a parameter. Inside the function, it calls the constructor of the superclass (presumably to initialize inherited attributes) by using the

Chunk 1490
attributes) by using the super() function with the double asterisks (**) to unpack the llm_config dictionary and pass its contents as keyword arguments.

Chunk 1491
Note:
- Make sure to provide a valid dictionary containing the necessary configuration settings when initializing an instance of the Ollama class.

Chunk 1492
ClassDef OneApi  
OneApi: The function of OneApi is to serve as a wrapper for the OneApi class, providing default configuration and the ability to be extended with additional methods if necessary.  
attributes:

Chunk 1493
attributes:
- llm_config (dict): Configuration parameters for the language model.  
Code Description:

Chunk 1494
The OneApi class is designed as a wrapper for the OneApi class, inheriting from ChatOpenAI. It takes a dictionary parameter llm_config during initialization, which contains configuration parameters for the language model. The class initializes by

Chunk 1495
The class initializes by calling the superclass constructor with the llm_config parameters.

Chunk 1496
In the project structure, the OneApi class is utilized within the _create_llm method of the AbstractGraph class. Within the _create_llm method, based on the model specified in llm_params, different language model instances are created. When the

Chunk 1497
are created. When the model is identified as "oneapi", an instance of the OneApi class is returned with the provided llm_params.

Chunk 1498
Note:
Developers can utilize the OneApi class to create instances of the OneApi model with specific configuration parameters. The class can be extended with additional methods as needed for further customization.

Chunk 1499
FunctionDef init(self, llm_config)  
init: The function of init is to initialize the OneApi object with the provided llm_config dictionary.  
parameters:
- llm_config: A dictionary containing configuration settings for the OneApi object.

Chunk 1500
Code Description:

Chunk 1501
The init function is a constructor method for the OneApi class. It takes in a dictionary named llm_config as a parameter. Inside the function, it calls the constructor of the superclass using the super() function and passes the llm_config dictionary

Chunk 1502
the llm_config dictionary as keyword arguments (**llm_config).

Chunk 1503
Note:
- Ensure that the llm_config parameter is a dictionary to avoid any unexpected behavior.
- The super() function is used to access and call methods from the parent class, ensuring proper initialization of the OneApi object.

Chunk 1504
ClassDef OpenAI  
OpenAI: The function of OpenAI is to serve as a wrapper for the ChatOpenAI class with default configuration and the ability to be extended with additional methods.  
attributes:

Chunk 1505
attributes:
- llm_config: Configuration parameters for the language model.  
Code Description:

Chunk 1506
The OpenAI class is designed as a wrapper for the ChatOpenAI class, providing default configuration settings. It can be extended with additional methods as needed. The class takes in a dictionary parameter, llm_config, during initialization, which

Chunk 1507
during initialization, which contains configuration parameters for the language model. The class inherits from the ChatOpenAI class and passes the llm_config parameters to the parent class during initialization.

Chunk 1508
In the project, the OpenAI class is utilized within the _create_llm method in the AbstractGraph class. This method creates an instance of the OpenAI class based on the provided language model configuration. The _create_llm method checks the model

Chunk 1509
method checks the model name in the llm_params dictionary and returns an instance of the corresponding model class, such as OpenAI, Gemini, Ernie, etc., based on the model name provided in the configuration.

Chunk 1510
The _create_default_embedder method in the AbstractGraph class also utilizes the OpenAI class. It creates an embedding model instance based on the chosen language model. If the llm_model is an instance of OpenAI, it returns OpenAIEmbeddings with the

Chunk 1511
OpenAIEmbeddings with the necessary parameters.

Chunk 1512
Note:

Chunk 1513
Developers can use the OpenAI class to create instances with default configurations for language models and extend its functionality by adding custom methods if required. The class plays a crucial role in creating language model instances based on

Chunk 1514
model instances based on provided configurations within the project's graph building process.

Chunk 1515
FunctionDef init(self, llm_config)  
init: The function of init is to initialize the OpenAI class with the provided configuration.  
parameters:
- llm_config: A dictionary containing the configuration settings for the OpenAI class.

Chunk 1516
Code Description:

Chunk 1517
The init function takes in a dictionary, llm_config, which holds the configuration settings for the OpenAI class. It then calls the superclass's (parent class) init method with the unpacked llm_config using **llm_config. This allows the OpenAI class

Chunk 1518
This allows the OpenAI class to be initialized with the specified configuration parameters.

Chunk 1519
Note:
It is important to ensure that the llm_config parameter is a dictionary with the necessary configuration settings required for the OpenAI class initialization.

Chunk 1520
ClassDef OpenAIImageToText  
OpenAIImageToText: The function of OpenAIImageToText is to convert an image to text using the OpenAI language model.  
attributes:
- llm_config (dict): Configuration parameters for the language model.  
Code Description:

Chunk 1521
The OpenAIImageToText class is a wrapper that facilitates image-to-text conversion using the OpenAI language model. It initializes with the provided language model configuration and has a method run to perform the image-to-text conversion. The run

Chunk 1522
conversion. The run method takes an image URL as input, creates a message with the image URL, invokes the superclass method to process the message, and returns the text description of the image.

Chunk 1523
In the project, the OpenAIImageToText class is utilized within the OmniScraperGraph to convert image URLs to text descriptions as part of a web scraping workflow. It is instantiated with the language model configuration and maximum number of images

Chunk 1524
and maximum number of images to process.

Chunk 1525
Note:
- Ensure the language model configuration is provided correctly to initialize the OpenAIImageToText class.
- The run method expects a valid image URL as input to perform the conversion.  
Output Example:

Chunk 1526
Output Example:
"An image of a cat sitting on a chair."  
FunctionDef init(self, llm_config)  
init: The function of init is to initialize the OpenAIImageToText object with the provided llm_config dictionary.  
parameters:

Chunk 1527
parameters:
- llm_config: A dictionary containing configuration settings for the OpenAIImageToText object.  
Code Description:

Chunk 1528
Code Description:
The init function initializes the OpenAIImageToText object by passing the llm_config dictionary to the superclass constructor. It sets the max_tokens parameter to 256 during initialization.  
Note:

Chunk 1529
Note:
Ensure that the llm_config dictionary is properly formatted and contains the necessary configuration settings required by the OpenAIImageToText object.  
FunctionDef run(self, image_url)

Chunk 1530
run: The function of run is to perform image-to-text conversion using the provided image URL.  
parameters:
- image_url (str): The URL of the image to convert.  
Code Description:

Chunk 1531
The run function initiates the image-to-text conversion process by creating a HumanMessage object with a text prompt asking "What is this image showing" and an image URL. It then invokes the superclass method with the created message and returns the

Chunk 1532
message and returns the text description of the image.

Chunk 1533
Note:
Ensure that the image URL provided is accessible and valid for successful conversion.  
Output Example:
"An image of a cat sitting on a window sill."

Chunk 1534
ClassDef OpenAITextToSpeech  
OpenAITextToSpeech: The function of OpenAITextToSpeech is to convert the provided text to speech using the OpenAI API.  
Attributes:
- client (OpenAI): The OpenAI client used to interact with the API.

Chunk 1535
- model (str): The model to use for text-to-speech conversion.
- voice (str): The voice model to use for generating speech.  
Code Description:

Chunk 1536
The OpenAITextToSpeech class implements a text-to-speech model utilizing the OpenAI API. Upon initialization, it takes a dictionary of configuration parameters for the text-to-speech model. The run method converts the input text to speech by

Chunk 1537
the input text to speech by utilizing the specified model and voice, returning the bytes of the generated speech audio.

Chunk 1538
In the project structure, the OpenAITextToSpeech class is utilized within the SpeechGraph class in the speech_graph.py file. Specifically, it is used as a node in the graph representing the workflow for web scraping and audio generation. The

Chunk 1539
and audio generation. The TextToSpeechNode in the graph incorporates the OpenAITextToSpeech class to convert the generated answer to speech audio.

Chunk 1540
Note:
Developers can customize the text-to-speech model and voice by providing appropriate configuration parameters when initializing the OpenAITextToSpeech class.  
Output Example:
b'\x12\x34\x56\x78' (example bytes of the generated speech audio)

Chunk 1541
FunctionDef init(self, tts_config)  
init: The function of init is to initialize the OpenAITextToSpeech object with the provided tts_config parameters.  
parameters:

Chunk 1542
parameters:
- tts_config: A dictionary containing configuration parameters for the OpenAI Text-to-Speech API, including "api_key", "base_url", "model", and "voice".  
Code Description:

Chunk 1543
Code Description:
In this function, the OpenAITextToSpeech object is initialized with the following parameters:
- The "api_key" is extracted from the tts_config dictionary to authenticate with the OpenAI API.

Chunk 1544
- The "base_url" is set to the value provided in tts_config, or it defaults to None if not specified.
- The "model" is set to the value provided in tts_config, or it defaults to "tts-1".

Chunk 1545
- The "voice" is set to the value provided in tts_config, or it defaults to "alloy".

Chunk 1546
Note: Ensure that the tts_config dictionary contains the necessary parameters for the OpenAI Text-to-Speech API to initialize the OpenAITextToSpeech object correctly.  
FunctionDef run(self, text)

Chunk 1547
FunctionDef run(self, text)  
run: The function of run is to convert the provided text to speech and return the bytes of the generated speech.  
parameters:
- text (str): The text to convert to speech.  
Code Description:

Chunk 1548
The run function takes a text input, converts it to speech using the specified model and voice, and returns the bytes of the generated speech audio. It utilizes the OpenAI API to generate the speech audio based on the provided text.  
Note:

Chunk 1549
Note:
Make sure to set the appropriate model and voice parameters before calling the run function to ensure the desired speech output.  
Output Example:

Chunk 1550
Output Example:
b'\x52\x49\x46\x46\x24\x08\x00\x00WAVEfmt ...\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'

Chunk 1551
ClassDef BaseNode  
An unknown error occurred while generating this documentation after many tries.  
FunctionDef init(self, node_name, node_type, input, output, min_input_len, node_config)

Chunk 1552
init: The function of init is to initialize a BaseNode object with the provided parameters.  
Parameters:
- node_name: str - The name of the node.
- node_type: str - The type of the node, must be either 'node' or 'conditional_node'.

Chunk 1553
- input: str - The input of the node.
- output: List[str] - The list of outputs of the node.
- min_input_len: int (default is 1) - The minimum length of the input.

Chunk 1554
- node_config: Optional[dict] (default is None) - Configuration settings for the node.  
Code Description:

Chunk 1555
The init function initializes a BaseNode object by assigning the provided parameters to the object's attributes. It sets the node_name, input, output, min_input_len, and node_config based on the input parameters. Additionally, it retrieves a logger

Chunk 1556
it retrieves a logger using the get_logger function from the logging module to set up logging for the node. If the provided node_type is not 'node' or 'conditional_node', a ValueError is raised to ensure the correct node type is specified for the

Chunk 1557
type is specified for the object.

Chunk 1558
Note:
- The node_type parameter must be either 'node' or 'conditional_node'.
- The function relies on the get_logger function to set up logging for the node.
- Ensure to provide valid parameters when initializing a BaseNode object to avoid errors.

Chunk 1559
FunctionDef execute(self, state)  
execute: The function of execute is to execute the node's logic based on the current state and update it accordingly.  
parameters:
- state (dict): The current state of the graph.  
Code Description:

Chunk 1560
The execute function takes in a dictionary named state as a parameter, representing the current state of the graph. Within the function, the node's logic is executed based on the provided state, and the state is updated accordingly. However, the

Chunk 1561
accordingly. However, the actual implementation of the logic is not provided in the code snippet, as it is represented by the 'pass' statement.

Chunk 1562
Note:

Chunk 1563
Developers using this function should ensure that the state parameter is correctly formatted as a dictionary to avoid any potential errors during execution. Additionally, the logic to be executed within this function should be implemented after the

Chunk 1564
be implemented after the 'pass' statement to ensure the desired functionality of the node.

Chunk 1565
FunctionDef update_config(self, params, overwrite)  
update_config: The function of update_config is to update the node_config dictionary as well as attributes with the same key.  
parameters:

Chunk 1566
parameters:
- params (dict): The dictionary to update node_config with.
- overwrite (bool): Flag indicating if the values of node_config should be overwritten if their value is not None.  
Code Description:

Chunk 1567
The update_config function iterates through the key-value pairs in the params dictionary. If the key exists as an attribute in the object and the overwrite flag is False, the function skips updating that key. Otherwise, it sets the attribute with

Chunk 1568
it sets the attribute with the corresponding value from the params dictionary.

Chunk 1569
Note:

Chunk 1570
It is important to ensure that the params dictionary contains valid keys that correspond to attributes of the object to update them correctly. The overwrite flag should be used carefully to control whether existing values should be overwritten or

Chunk 1571
should be overwritten or not.

Chunk 1572
FunctionDef get_input_keys(self, state)  
get_input_keys: The function of get_input_keys is to determine the necessary state keys based on the input specification.  
parameters:

Chunk 1573
parameters:
- state (dict): The current state of the graph used to parse input keys.  
Code Description:

Chunk 1574
The get_input_keys function takes the current state of the graph as input and parses it to determine the necessary state keys based on the input specification. It calls the _parse_input_keys function to parse the input keys expression and extract

Chunk 1575
keys expression and extract relevant keys from the state based on logical conditions such as AND (&), OR (|), and parentheses to group conditions. The function then returns a list of key names that match the input keys expression logic.

Chunk 1576
The get_input_keys function is called within the execute method of various nodes in the project, such as the GenerateAnswerNode, GenerateAnswerOmniNode, and GenerateScraperNode. It is used to determine the necessary input keys for node operation,

Chunk 1577
keys for node operation, which are then used to fetch the correct data from the state.

Chunk 1578
Note:
Developers using this function should ensure that the input keys provided match the specified logical conditions to obtain the desired state keys.  
Output Example:
['key1', 'key2', 'key3']

Chunk 1579
['key1', 'key2', 'key3']  
FunctionDef _validate_input_keys(self, input_keys)  
_validate_input_keys: The function of _validate_input_keys is to validate if the provided input keys meet the minimum length requirement.  
parameters:

Chunk 1580
parameters:
- input_keys (List[str]): The list of input keys to validate.  
Code Description:

Chunk 1581
The _validate_input_keys function checks if the number of input keys provided meets the minimum length requirement specified by the node. If the length of input_keys is less than the minimum required length (self.min_input_len), a ValueError is

Chunk 1582
a ValueError is raised indicating the number of input keys required by the node.

Chunk 1583
This function is called within the get_input_keys method of the BaseNode class. In the get_input_keys method, the input_keys are parsed using _parse_input_keys and then validated using _validate_input_keys before being returned. If an error occurs

Chunk 1584
returned. If an error occurs during parsing or validation, a ValueError is raised to indicate the issue.

Chunk 1585
Note:
Developers using this function should ensure that the input_keys provided meet the minimum length requirement specified by the node to avoid ValueErrors during validation.  
FunctionDef _parse_input_keys(self, state, expression)

Chunk 1586
_parse_input_keys: The function of _parse_input_keys is to parse an input keys expression to extract relevant keys from the state based on logical conditions.  
parameters:
- state (dict): The current state of the graph.

Chunk 1587
- expression (str): The input keys expression to parse.  
Code Description:

Chunk 1588
The _parse_input_keys function takes a state dictionary and an expression as input. It parses the expression to extract relevant keys from the state based on logical conditions such as AND (&), OR (|), and parentheses to group conditions. The

Chunk 1589
to group conditions. The function performs various checks on the expression for validity, operator placement, balanced parentheses, and evaluates the expression to return a list of key names that match the input keys expression logic. If no keys

Chunk 1590
expression logic. If no keys match the expression, a ValueError is raised.

Chunk 1591
In the project, this function is called by the get_input_keys method of the BaseNode class. The get_input_keys method determines the necessary state keys based on the input specification by calling _parse_input_keys with the current state and the

Chunk 1592
the current state and the input keys expression. If an error occurs during parsing input keys, a ValueError is raised with a specific error message.

Chunk 1593
Note:
- Ensure the input expression follows the specified logical conditions.
- Handle any potential ValueErrors raised by the function.  
Output Example:
['key1', 'key2', 'key3']  
FunctionDef evaluate_simple_expression(exp)

Chunk 1594
evaluate_simple_expression: The function of evaluate_simple_expression is to evaluate an expression without parentheses.  
parameters:
- exp: A string representing the expression to be evaluated.  
Code Description:

Chunk 1595
The evaluate_simple_expression function takes an expression as input and evaluates it without considering parentheses. It splits the expression by the OR operator and processes each segment individually. For each segment, it further splits by the

Chunk 1596
it further splits by the AND operator and checks if all elements in the AND segment are present in the state. If all elements are found, it returns the elements after stripping any whitespace. If no segment satisfies the condition, an empty list is

Chunk 1597
condition, an empty list is returned.

Chunk 1598
This function is utilized in the evaluate_expression function, which evaluates an expression with parentheses. In evaluate_expression, when parentheses are present in the expression, it extracts the sub-expression within the parentheses, evaluates

Chunk 1599
the parentheses, evaluates it using evaluate_simple_expression, and replaces the evaluated part with a placeholder. The sub-results are then joined with OR to reprocess them later until no parentheses are left in the expression.

Chunk 1600
Note:
- The evaluate_simple_expression function is designed to handle simple expressions without parentheses and relies on the presence of elements in the 'state' variable.

Chunk 1601
- It returns a list of elements that satisfy the conditions specified in the expression.  
Output Example:
If the input expression is "A & B | C", and 'state' contains ['A', 'C'], the function would return ['A', 'C'].

Chunk 1602
FunctionDef evaluate_expression(expression)  
evaluate_expression: The function of evaluate_expression is to evaluate an expression with parentheses.  
parameters:
- expression: A string representing the expression to be evaluated.

Chunk 1603
Code Description:

Chunk 1604
The evaluate_expression function processes an expression containing parentheses by iteratively evaluating sub-expressions within the parentheses. It locates the innermost parentheses, evaluates the enclosed sub-expression using the

Chunk 1605
sub-expression using the evaluate_simple_expression function, and replaces it with a placeholder. This process continues until all parentheses are resolved. The sub-results are then combined using the OR operator for further processing. Finally, the

Chunk 1606
processing. Finally, the function evaluates the modified expression using evaluate_simple_expression and returns the result.

Chunk 1607
The evaluate_expression function relies on the evaluate_simple_expression function to handle sub-expressions without parentheses. By utilizing this recursive approach, it effectively evaluates complex expressions with nested parentheses.  
Note:

Chunk 1608
Note:
- The evaluate_expression function is designed to handle expressions with parentheses and is dependent on the evaluate_simple_expression function for evaluating sub-expressions.

Chunk 1609
- It returns a list of elements that satisfy the conditions specified in the input expression.  
Output Example:
If the input expression is "(A & B) | (C & D)" and 'state' contains ['A', 'C'], the function would return ['A', 'C'].

Chunk 1610
ClassDef ConditionalNode  
ConditionalNode: The function of ConditionalNode is to determine the next step in the graph's execution flow based on the presence and content of a specified key in the graph's state.  
attributes:

Chunk 1611
attributes:
- key_name (str): The name of the key in the state to check for its presence.  
Code Description:

Chunk 1612
ConditionalNode is a class that extends the BaseNode and adds condition-based logic to the execution process in a graph-based workflow. It is used to implement branching logic within the graph, allowing for dynamic paths based on the data available

Chunk 1613
based on the data available in the current state. The class expects exactly two edges to be created out of this node. The first node is chosen for execution if the key exists and has a non-empty value, and the second node is chosen if the key does

Chunk 1614
is chosen if the key does not exist or is empty. The class has an __init__ method to initialize the node with the key to check and the next node names based on the condition. The execute method checks if the specified key is present in the state and

Chunk 1615
is present in the state and decides the next node accordingly.

Chunk 1616
This class plays a crucial role in controlling the flow of the graph based on specific conditions, enabling developers to create dynamic and flexible workflows within their applications.

Chunk 1617
Note: It is important to ensure that the key_name provided during initialization accurately reflects the key in the state that needs to be checked for branching logic.  
Output Example:
{'next_node': 0}

Chunk 1618
{'next_node': 0}  
FunctionDef init(self, key_name, node_name)  
init: The function of init is to initialize the ConditionalNode object with a key to check in the state and the names of the next nodes based on the condition.  
parameters:

Chunk 1619
parameters:
- key_name (str): The name of the key to check in the state.
- node_name (str): The name of the node.  
Code Description:

Chunk 1620
The init function initializes the ConditionalNode object by setting the key_name attribute to the provided key_name parameter value. It also calls the parent class constructor with the node_name and "conditional_node" as arguments.  
Note:

Chunk 1621
Note:
- Ensure that the key_name parameter is a string value.
- The node_name parameter defaults to "ConditionalNode" if not provided explicitly.  
FunctionDef execute(self, state)

Chunk 1622
execute: The function of execute is to check if a specified key is present in the state and determine the next node based on the key's presence.  
parameters:
- state (dict): The current state of the graph.  
Code Description:

Chunk 1623
The execute function first checks if the key specified by self.key_name is present in the state dictionary and if the length of the value associated with the key is greater than 0. Based on this condition, it sets the "next_node" key in the state

Chunk 1624
"next_node" key in the state dictionary to either 0 or 1.

Chunk 1625
Note:
- Ensure that the key_name attribute is properly set before calling the execute function to determine the next node accurately.  
Output Example:
{
"next_node": 0
}

Chunk 1626
ClassDef FetchNode

Chunk 1627
FetchNode: FetchNode is a class responsible for fetching the HTML content of a specified URL and updating the graph's state with this content. It is used as a starting point in many scraping workflows, preparing the state with the necessary HTML

Chunk 1628
state with the necessary HTML content for further processing by subsequent nodes in the graph.

Chunk 1629
Attributes:
- headless (bool): A flag indicating whether the browser should run in headless mode.
- verbose (bool): A flag indicating whether to print verbose output during execution.  
Code Description:

Chunk 1630
The FetchNode class inherits from the BaseNode class and overrides its execute method. The execute method fetches the HTML content from a specified URL and updates the state with this content. It handles different types of input keys and performs

Chunk 1631
of input keys and performs the necessary operations accordingly. The fetched HTML content is then parsed and processed to extract relevant information such as title, body, links, and images. The processed content is stored in the state with

Chunk 1632
is stored in the state with appropriate output keys.

Chunk 1633
The FetchNode class takes several arguments in its constructor:
- input (str): A boolean expression defining the input keys needed from the state.
- output (List[str]): A list of output keys to be updated in the state.

Chunk 1634
- node_config (Optional[dict]): Additional configuration for the node.
- node_name (str): The unique identifier name for the node, defaulting to "Fetch".

Chunk 1635
The FetchNode class has an execute method that takes the current state of the graph as an argument. It performs the following steps:
1. Parses the input keys based on the provided input expression.

Chunk 1636
2. Fetches the data from the state based on the input keys.
3. Handles different types of input data (e.g., JSON, XML, CSV, PDF) and performs the necessary operations to fetch the HTML content.

Chunk 1637
4. Parses and processes the fetched HTML content to extract relevant information.
5. Updates the state with the processed content and appropriate output keys.

Chunk 1638
Note: The FetchNode class relies on other classes and functions such as ChromiumLoader, cleanup_html, PyPDFLoader, and Document to perform its operations.  
Output Example:
{
"doc": [
{

Chunk 1639
"page_content": "Title: ScrapeGraph AI, Body: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec euismod, nunc et feugiat ultricies, metus nisl consectetur eros, in luctus diam elit id nunc. Links:

Chunk 1640
diam elit id nunc. Links: [https://github.com/VinciGit00/Scrapegraph-ai], Images: [https://raw.githubusercontent.com/VinciGit00/Scrapegraph-ai/main/docs/assets/scrapegraphai_logo.png]"

Chunk 1641
}
],
"links": ["https://github.com/VinciGit00/Scrapegraph-ai"],
"images": ["https://raw.githubusercontent.com/VinciGit00/Scrapegraph-ai/main/docs/assets/scrapegraphai_logo.png"]
}  
FunctionDef init(self, input, output, node_config, node_name)

Chunk 1642
init: The function of init is to initialize the FetchNode object with input parameters.  
parameters:
- self: The instance of the class.
- input: A string representing the input data.
- output: A list of strings representing the output data.

Chunk 1643
- node_config: An optional dictionary containing configuration settings for the node (default is None).
- node_name: A string representing the name of the node (default is "Fetch").  
Code Description:

Chunk 1644
The init function initializes the FetchNode object by calling the superclass constructor with specific parameters. It sets the headless, verbose, useSoup, and loader_kwargs attributes based on the values provided in the node_config dictionary or

Chunk 1645
the node_config dictionary or default values if the dictionary is None.

Chunk 1646
Note:
- The node_name parameter allows customizing the name of the node during initialization.

Chunk 1647
- The node_config parameter can be used to provide additional configuration settings for the node, such as headless mode, verbosity, use of BeautifulSoup, and loader keyword arguments.  
FunctionDef execute(self, state)

Chunk 1648
execute: The function of execute is to execute the node's logic to fetch HTML content from a specified URL and update the state with this content.  
Parameters:

Chunk 1649
Parameters:
- state (dict): The current state of the graph. The input keys will be used to fetch the correct data types from the state.  
Code Description:

Chunk 1650
The execute function is responsible for executing the logic of the node to fetch HTML content from a specified URL and update the state with this content. It takes the current state of the graph as input and uses the input keys to fetch the required

Chunk 1651
keys to fetch the required data types from the state.

Chunk 1652
The function begins by logging the execution of the node. It then interprets the input keys based on the provided input expression and fetches the corresponding data from the state. The fetched data is stored in the input_data variable.

Chunk 1653
Next, the function checks the value of the first input key (input_keys[0]) to determine the type of source. If the source is a directory for JSON, XML, CSV, or PDF files, the function creates a compressed document containing the source and updates

Chunk 1654
the source and updates the state with this document.

Chunk 1655
If the source is a PDF file, the function creates an instance of the PyPDFLoader class and uses it to load the PDF content. The loaded content is then stored in the compressed_document variable and added to the state.

Chunk 1656
If the source is a CSV file, the function reads the CSV file using the pd.read_csv function and creates a compressed document containing the page content and metadata. The compressed document is added to the state.

Chunk 1657
If the source is a JSON file, the function opens the file, loads the JSON content using the json.load function, and creates a compressed document containing the page content and metadata. The compressed document is added to the state.

Chunk 1658
If the source is an XML file, the function reads the file, extracts the content, and creates a compressed document containing the page content and metadata. The compressed document is added to the state.

Chunk 1659
If the input is not a directory or a file, the function assumes it is HTML content. It logs the fetching of HTML from the source and checks if the source is empty. If the source is empty, it raises a ValueError indicating that no HTML body content

Chunk 1660
that no HTML body content was found in the local source.

Chunk 1661
If the useSoup flag is set to True, the function fetches the HTML content from the source using the requests.get function. If the response status code is 200, it checks if the response text is empty. If the response text is empty, it raises a

Chunk 1662
text is empty, it raises a ValueError indicating that no HTML body content was found in the response. Otherwise, it cleans up the HTML content using the cleanup_html function, extracts the title, minimized body, link URLs, and image URLs, and

Chunk 1663
URLs, and image URLs, and creates a compressed document containing this information. The compressed document is added to the state.

Chunk 1664
Finally, the function updates the state with the compressed document, link URLs, and image URLs, and returns the updated state.

Chunk 1665
The execute function is called within the FetchNode class in the project to fetch HTML content from specified URLs. Depending on the input keys and sources, the function uses different methods to fetch and process the HTML content. The fetched

Chunk 1666
the HTML content. The fetched content is then stored in a compressed document and added to the state along with metadata such as source URLs, links, and images.

Chunk 1667
Note:
- Developers using the ChromiumLoader class should ensure that the required backend package is installed to avoid ImportError.
- Proper exception handling should be implemented to manage errors effectively during the scraping process.

Chunk 1668
Output Example:
{
"output_key": [
{
"page_content": "Title: Example, Body:  
Hello World!",
"metadata": {"source": "local_dir"}
}
],
"link_urls": ["http://example.com"],
"image_urls": ["http://example.com/image.jpg"]
}

Chunk 1669
ClassDef GenerateAnswerCSVNode

Chunk 1670
GenerateAnswerCSVNode: The function of GenerateAnswerCSVNode is to generate an answer using a language model (LLM) based on the user's input and the content extracted from a webpage. It constructs a prompt from the user's input and the scraped

Chunk 1671
user's input and the scraped content, feeds it to the LLM, and parses the LLM's response to produce an answer.

Chunk 1672
Attributes:
- llm_model: An instance of a language model client, configured for generating answers.
- node_name (str): The unique identifier name for the node, defaulting to "GenerateAnswerNodeCsv".

Chunk 1673
- node_type (str): The type of the node, set to "node" indicating a standard operational node.  
Args:
- llm_model: An instance of the language model client (e.g., ChatOpenAI) used for generating answers.

Chunk 1674
- node_name (str, optional): The unique identifier name for the node. Defaults to "GenerateAnswerNodeCsv".  
Methods:

Chunk 1675
Methods:
- execute(state): Processes the input and document from the state to generate an answer, updating the state with the generated answer under the 'answer' key.  
Code Description:

Chunk 1676
The GenerateAnswerCSVNode class is a subclass of the BaseNode class and is responsible for generating an answer using a language model. It takes the user's input and the scraped content as input, constructs a prompt, queries the language model, and

Chunk 1677
the language model, and parses its response to produce an answer.

Chunk 1678
The __init__ method initializes the GenerateAnswerCSVNode with a language model client and a node name. It calls the superclass's __init__ method to set the node name, node type, input, output, and node configuration attributes. It also initializes

Chunk 1679
It also initializes the llm_model attribute with the language model client and the verbose attribute with the value of the verbose key in the node configuration dictionary.

Chunk 1680
The execute method generates an answer by constructing a prompt from the user's input and the scraped content, querying the language model, and parsing its response. It updates the state with the generated answer under the 'answer' key. The method

Chunk 1681
the 'answer' key. The method expects the state to contain 'user_input' and optionally 'parsed_document' or 'relevant_chunks' within 'keys'. If 'user_input' or 'document' is not found in the state, a KeyError is raised.

Chunk 1682
The method starts by logging the execution of the node. It then interprets the input keys based on the provided input expression and fetches the corresponding data from the state. The user's prompt and the document are extracted from the input data.

Chunk 1683
from the input data.

Chunk 1684
Next, the method initializes an output parser based on the node configuration. It retrieves the format instructions from the output parser.

Chunk 1685
The method then iterates over the document chunks using tqdm to add a progress bar. For each chunk, it constructs a prompt template based on the number of chunks. If there is only one chunk, it uses a template without chunk information. Otherwise,

Chunk 1686
chunk information. Otherwise, it includes the chunk ID in the template. The prompt template includes the user's prompt, the chunk's page content, and the format instructions.

Chunk 1687
The method dynamically names the chains based on their index and adds them to a dictionary. Each chain consists of the prompt template, the language model, and the output parser.

Chunk 1688
If there are multiple chunks, the method creates a map chain using RunnableParallel and invokes it with the user's prompt. It then merges the answers from the chunks using a merge prompt template and a merge chain.

Chunk 1689
Finally, the method updates the state with the generated answer under the 'answer' key and returns the updated state.  
Note: The code relies on the BaseNode class and the JsonOutputParser class, which are not provided in the given code snippet.

Chunk 1690
Output Example:
{
'answer': 'The generated answer'
}  
FunctionDef init(self, input, output, node_config, node_name)  
init: The function of init is to initialize the GenerateAnswerCSVNode with specified input parameters.  
parameters:
- input: str

Chunk 1691
parameters:
- input: str
- output: List[str]
- node_config: Optional[dict] (default is None)
- node_name: str (default is "GenerateAnswerCSV")  
Code Description:

Chunk 1692
The init function initializes the GenerateAnswerCSVNode with the provided input, output, node configuration, and node name. It inherits properties from the parent class and assigns values to self.llm_model and self.verbose based on the node_config

Chunk 1693
based on the node_config dictionary.

Chunk 1694
Note:
- Ensure that the necessary input parameters are provided when initializing the GenerateAnswerCSVNode.
- The node_name parameter defaults to "GenerateAnswerCSV" if not specified during initialization.  
FunctionDef execute(self, state)

Chunk 1695
execute: The function of execute is to generate an answer by constructing a prompt from the user's input and the scraped content, querying the language model, and parsing its response. It then updates the state with the generated answer under the

Chunk 1696
generated answer under the 'answer' key.

Chunk 1697
parameters:
- state (dict): The current state of the graph, expected to contain 'user_input', and optionally 'parsed_document' or 'relevant_chunks' within 'keys'.  
Code Description:

Chunk 1698
The execute function begins by logging the execution of the node. It then determines the necessary input keys by calling the get_input_keys function from the BaseNode object. The function fetches data from the state based on the input keys,

Chunk 1699
based on the input keys, constructs prompts based on the content, and utilizes a language model to generate answers. The generated answers are parsed and stored in the state under the 'answer' key. The function handles single or multiple chunks of

Chunk 1700
single or multiple chunks of data, dynamically naming chains based on their index, and merging answers if multiple chunks are processed. Finally, it updates the state with the generated answer and returns the updated state.

Chunk 1701
The execute function interacts with the get_input_keys function to retrieve the necessary input keys for processing data. It also utilizes JsonOutputParser, PromptTemplate, and RunnableParallel objects to format and process the data accordingly.

Chunk 1702
process the data accordingly. Additionally, it relies on the llm_model object to query the language model for generating answers.

Chunk 1703
Note:
Developers should ensure that the 'user_input' and 'document' keys are present in the state to avoid KeyError exceptions. It is essential to provide the required information in the state for the function to execute successfully.

Chunk 1704
Output Example:
{'answer': 'Generated answer text based on user input and scraped content'}

Chunk 1705
ClassDef GenerateAnswerNode

Chunk 1706
GenerateAnswerNode: This class represents a node in a graph-based workflow that is responsible for generating an answer using a large language model (LLM) based on the user's input and the content extracted from a webpage. It constructs a prompt

Chunk 1707
It constructs a prompt from the user's input and the scraped content, feeds it to the LLM, and parses the LLM's response to produce an answer.

Chunk 1708
Attributes:
- llm_model: An instance of a language model client, configured for generating answers.
- verbose (bool): A flag indicating whether to show print statements during execution.  
Args:

Chunk 1709
Args:
- input (str): Boolean expression defining the input keys needed from the state.
- output (List[str]): List of output keys to be updated in the state.
- node_config (dict): Additional configuration for the node.

Chunk 1710
- node_name (str): The unique identifier name for the node, defaulting to "GenerateAnswer".  
execute:

Chunk 1711
execute:
Generates an answer by constructing a prompt from the user's input and the scraped content, querying the language model, and parsing its response.  
Args:

Chunk 1712
Args:
- state (dict): The current state of the graph. The input keys will be used to fetch the correct data from the state.  
Returns:
- dict: The updated state with the output key containing the generated answer.  
Raises:

Chunk 1713
Raises:
- KeyError: If the input keys are not found in the state, indicating that the necessary information for generating an answer is missing.  
Code Description:

Chunk 1714
The GenerateAnswerNode class is a subclass of the BaseNode class and represents a node in a graph-based workflow. It is responsible for generating an answer using a large language model (LLM) based on the user's input and the content extracted from

Chunk 1715
the content extracted from a webpage.

Chunk 1716
The execute method is responsible for generating an answer. It takes the current state of the graph as input and returns the updated state with the generated answer. The method performs the following steps:

Chunk 1717
1. It retrieves the necessary input data from the state based on the input keys.
2. It initializes an output parser based on the provided schema (if any).
3. It iterates over the chunks of the scraped content and generates prompts for each chunk.

Chunk 1718
4. It dynamically creates chains of operations using prompt templates, the LLM model, and the output parser.
5. If there are multiple chunks, it uses a RunnableParallel object to execute the chains in parallel and merge the answers.

Chunk 1719
6. It updates the state with the generated answer.

Chunk 1720
Note: The GenerateAnswerNode class relies on the BaseNode class for its basic functionality. It also requires an instance of a language model client (llm_model) to generate answers. The verbose attribute controls whether print statements are shown

Chunk 1721
print statements are shown during execution.

Chunk 1722
Output Example:
python
{
"output_key": "Generated answer"
}  
FunctionDef init(self, input, output, node_config, node_name)

Chunk 1723
init: The function of init is to initialize the GenerateAnswerNode object with input parameters and configure the node for generating answers.  
parameters:
- self: The instance of the GenerateAnswerNode object.

Chunk 1724
- input: A string representing the input data for the node.
- output: A list of strings representing the output data from the node.
- node_config: An optional dictionary containing configuration parameters for the node.

Chunk 1725
- node_name: A string representing the name of the node (default value is "GenerateAnswer").  
Code Description:

Chunk 1726
The init function of the GenerateAnswerNode class initializes the node with the provided input, output, configuration, and node name. It first calls the constructor of the parent class using the super() function and passes the node_name, "node",

Chunk 1727
passes the node_name, "node", input, output, 2, and node_config as arguments.

Chunk 1728
The function then assigns the "llm_model" attribute of the node_config dictionary to the llm_model attribute of the GenerateAnswerNode object. If the "llm_model" attribute is an instance of the Ollama class, it sets the format attribute of llm_model

Chunk 1729
format attribute of llm_model to "json".

Chunk 1730
Furthermore, the function sets the "verbose" attribute of the GenerateAnswerNode object based on the "verbose" key in the node_config dictionary. If the "verbose" key is not present, the default value is set to False.

Chunk 1731
Note: It is important to provide the necessary input parameters and configuration when initializing a GenerateAnswerNode object to ensure proper functioning. The function automatically configures the node based on the provided parameters, including

Chunk 1732
parameters, including setting the language model format and verbosity level.

Chunk 1733
FunctionDef execute(self, state)  
execute: The function of execute is to generate an answer by constructing a prompt from the user's input and the scraped content, querying the language model, and parsing its response.  
parameters:

Chunk 1734
parameters:
- state (dict): The current state of the graph. The input keys will be used to fetch the correct data from the state.  
Code Description:

Chunk 1735
The execute function begins by logging the execution of the node. It then determines the necessary input keys by calling the get_input_keys function from the BaseNode object. The input data is fetched from the state based on the input keys, which

Chunk 1736
on the input keys, which include the user's prompt and the scraped content. The function initializes an output parser based on the provided schema or defaults to a standard JsonOutputParser. It then iterates through the chunks of the scraped

Chunk 1737
the chunks of the scraped content, constructing prompts, querying the language model, and parsing the responses. Depending on the number of chunks, it either processes them sequentially or in parallel using RunnableParallel. Finally, the generated

Chunk 1738
Finally, the generated answer is merged if multiple chunks are processed, and the state is updated with the answer.

Chunk 1739
The execute function is crucial for generating answers in the context of the graph-based scraping and language model querying. It interacts with the input keys logic defined in the get_input_keys function to fetch relevant data from the state. By

Chunk 1740
data from the state. By utilizing an output parser and chaining prompts with the language model, it orchestrates the generation and parsing of answers based on user prompts and scraped content.

Chunk 1741
Note:

Chunk 1742
Developers should ensure that the necessary input keys are available in the state to avoid KeyError exceptions during execution. Understanding the flow of data processing and chaining of prompts with the language model is essential for customizing

Chunk 1743
is essential for customizing the answer generation process.

Chunk 1744
Output Example:
{'output': 'Generated answer text based on user prompt and scraped content'}

Chunk 1745
ClassDef GenerateAnswerOmniNode

Chunk 1746
GenerateAnswerOmniNode: The GenerateAnswerOmniNode class is responsible for generating an answer using a large language model (LLM) based on the user's input and the content extracted from a webpage. It constructs a prompt from the user's input and

Chunk 1747
from the user's input and the scraped content, feeds it to the LLM, and parses the LLM's response to produce an answer.

Chunk 1748
Attributes:
- llm_model: An instance of a language model client, configured for generating answers.
- verbose (bool): A flag indicating whether to show print statements during execution.  
Code Description:

Chunk 1749
Code Description:
The __init__ method initializes the GenerateAnswerOmniNode object. It takes the following arguments:
- input: A string representing a boolean expression defining the input keys needed from the state.

Chunk 1750
- output: A list of strings representing the output keys to be updated in the state.
- node_config: An optional dictionary containing additional configuration for the node.

Chunk 1751
- node_name: A string representing the unique identifier name for the node, defaulting to "GenerateAnswerOmni".

Chunk 1752
The execute method generates an answer by constructing a prompt from the user's input and the scraped content, querying the language model, and parsing its response. It takes the following argument:

Chunk 1753
- state: A dictionary representing the current state of the graph. The input keys will be used to fetch the correct data from the state.

Chunk 1754
The method starts by logging the execution of the node. It then interprets the input keys based on the provided input expression and fetches the corresponding data from the state. The user's prompt, scraped content, and image description are

Chunk 1755
and image description are extracted from the input data.

Chunk 1756
Next, the method initializes an output parser based on the node configuration. It retrieves the format instructions from the output parser.

Chunk 1757
A dictionary named chains_dict is created to store the dynamically named chains. The method then iterates over the chunks of the scraped content using tqdm to add a progress bar. For each chunk, it constructs a prompt template based on the number of

Chunk 1758
based on the number of chunks. If there is only one chunk, the prompt template includes the user's question, the chunk's page content, the format instructions, and the image description. The prompt template is then combined with the LLM model and

Chunk 1759
with the LLM model and the output parser to form a chain. The chain is invoked with the user's question as input, and the answer is stored in the answer variable.

Chunk 1760
If there are multiple chunks, the method constructs a different prompt template that includes the chunk's page content, the chunk's ID, and the format instructions. The chain is not invoked in this case.

Chunk 1761
Finally, if there are multiple chains, a merge prompt template is constructed that includes the context (the answer from the chunks) and the user's question. The merge prompt template is combined with the LLM model and the output parser to form a

Chunk 1762
the output parser to form a merge chain. The merge chain is invoked with the context and the user's question as input, and the answer is stored in the answer variable.

Chunk 1763
The method updates the state with the generated answer and returns the updated state.  
Output Example:
{
"answer": "The generated answer"
}  
FunctionDef init(self, input, output, node_config, node_name)

Chunk 1764
init: The function of init is to initialize the GenerateAnswerOmniNode object with input parameters and configure the node based on the provided settings.  
parameters:
- self: The instance of the GenerateAnswerOmniNode class.

Chunk 1765
- input: A string representing the input data for the node.
- output: A list of strings representing the output data from the node.
- node_config: An optional dictionary containing configuration parameters for the node (default is None).

Chunk 1766
- node_name: A string representing the name of the node (default is "GenerateAnswerOmni").  
Code Description:

Chunk 1767
The init function initializes the GenerateAnswerOmniNode object by calling the constructor of its parent class with specific parameters. It assigns the "llm_model" attribute based on the node_config dictionary and sets the "format" attribute to

Chunk 1768
the "format" attribute to "json" if the "llm_model" is an instance of the Ollama class. Additionally, it sets the "verbose" attribute to False if the "verbose" key is not present in the node_config dictionary.

Chunk 1769
The function ensures that the GenerateAnswerOmniNode object is properly configured with the necessary input, output, and node settings for further processing within the scraping graph AI system.

Chunk 1770
Note: It is important to provide the required input parameters and node configuration settings when creating an instance of the GenerateAnswerOmniNode class to ensure proper initialization and functionality of the node within the scraping graph AI

Chunk 1771
within the scraping graph AI system.

Chunk 1772
FunctionDef execute(self, state)  
execute: The function of execute is to generate an answer by constructing a prompt from the user's input and scraped content, querying the language model, and parsing its response.  
parameters:

Chunk 1773
parameters:
- state (dict): The current state of the graph. The input keys will be used to fetch the correct data from the state.  
Code Description:

Chunk 1774
The execute function begins by logging the execution of the node. It then determines the input keys by calling the get_input_keys function from the BaseNode class, which parses the input keys expression to extract relevant keys from the state. The

Chunk 1775
keys from the state. The function proceeds to fetch data from the state based on the input keys and initializes an output parser based on the node's schema configuration. It then iterates through the document chunks, constructs prompts, queries the

Chunk 1776
prompts, queries the language model, and parses the output. Depending on the number of chunks, it either processes them individually or in parallel using RunnableParallel. Finally, it updates the state with the generated answer and returns the

Chunk 1777
answer and returns the updated state.

Chunk 1778
The execute function interacts with the get_input_keys function to determine the necessary state keys for fetching data. It utilizes the JsonOutputParser class for output parsing and interacts with the PromptTemplate, LLM model, and RunnableParallel

Chunk 1779
model, and RunnableParallel for processing prompts and chunks efficiently. The function ensures the necessary information is available in the state to generate an answer effectively.

Chunk 1780
Note:

Chunk 1781
Developers using the execute function should ensure that the input keys in the state align with the node's requirements to avoid KeyError exceptions. Additionally, understanding the flow of data processing and interaction with external components

Chunk 1782
with external components such as the language model is crucial for proper execution.

Chunk 1783
Output Example:
{'output': 'Generated answer text'}

Chunk 1784
ClassDef GenerateAnswerPDFNode

Chunk 1785
GenerateAnswerPDFNode: The function of GenerateAnswerPDFNode is to generate an answer using a language model (LLM) based on the user's input and the content extracted from a webpage. It constructs a prompt from the user's input and the scraped

Chunk 1786
user's input and the scraped content, feeds it to the LLM, and parses the LLM's response to produce an answer.

Chunk 1787
Attributes:
- llm: An instance of a language model client, configured for generating answers.
- node_name (str): The unique identifier name for the node, defaulting to "GenerateAnswerNodePDF".

Chunk 1788
- node_type (str): The type of the node, set to "node" indicating a standard operational node.  
Args:
- llm: An instance of the language model client (e.g., ChatOpenAI) used for generating answers.

Chunk 1789
- node_name (str, optional): The unique identifier name for the node. Defaults to "GenerateAnswerNodePDF".  
Methods:

Chunk 1790
Methods:
- execute(state): Processes the input and document from the state to generate an answer, updating the state with the generated answer under the 'answer' key.  
Code Description:

Chunk 1791
The GenerateAnswerPDFNode class is responsible for generating an answer by constructing a prompt from the user's input and the scraped content, querying the language model, and parsing its response. It inherits from the BaseNode class, which is an

Chunk 1792
BaseNode class, which is an abstract base class for nodes in a graph-based workflow.

Chunk 1793
The constructor (init) initializes the GenerateAnswerPDFNode with a language model client, a node name, and other optional parameters. It calls the constructor of the BaseNode class and sets the llm_model attribute based on the node_config

Chunk 1794
based on the node_config parameter.

Chunk 1795
The execute method takes the current state of the graph as input and generates an answer by constructing a prompt from the user's input and the scraped content. It uses a template to generate the prompt and feeds it to the language model client

Chunk 1796
to the language model client (llm_model) to get the answer. The answer is then parsed using an output parser. The method updates the state with the generated answer under the 'answer' key.

Chunk 1797
The get_input_keys method is a helper method that determines the necessary state keys based on the input specification. It parses the input keys expression and returns a list of input keys required for node operation.

Chunk 1798
The _parse_input_keys method is a private method that parses the input keys expression to extract relevant keys from the state based on logical conditions. It handles operators like AND (&), OR (|), and parentheses to group conditions.

Chunk 1799
The _validate_input_keys method is a private method that validates if the provided input keys meet the minimum length requirement.  
The update_config method updates the node_config dictionary as well as attributes with the same key.  
Note:

Chunk 1800
Note:
- The GenerateAnswerPDFNode class requires a language model client (llm_model) to be provided in the node_config parameter.

Chunk 1801
- The execute method expects the state to contain 'user_input' and optionally 'parsed_document' or 'relevant_chunks' within 'keys'. If these keys are not found in the state, a KeyError is raised.

Chunk 1802
- The GenerateAnswerPDFNode class is designed to be used in a graph-based workflow, where it is connected to other nodes through edges to form a workflow.  
Output Example:
{
'answer': 'The generated answer'
}

Chunk 1803
}  
FunctionDef init(self, input, output, node_config, node_name)  
init: The function of init is to initialize the GenerateAnswerPDFNode with specified input parameters.  
parameters:
- input: str
- output: List[str]

Chunk 1804
- output: List[str]
- node_config: Optional[dict] (default = None)
- node_name: str (default = "GenerateAnswerPDF")  
Code Description:

Chunk 1805
The init function initializes the GenerateAnswerPDFNode with the provided input parameters. It sets the node name, input, output, and node configuration based on the arguments passed during instantiation. Additionally, it assigns the language model

Chunk 1806
it assigns the language model from the node configuration to the llm_model attribute. If the language model is an instance of Ollama, it sets the format to "json". The function also handles the verbosity setting based on the presence of the

Chunk 1807
based on the presence of the "verbose" key in the node configuration.

Chunk 1808
The function further calls the constructor of the parent class with the necessary arguments to set up the node. This ensures that the GenerateAnswerPDFNode is properly initialized with the specified parameters for further processing.

Chunk 1809
Note: Ensure to provide the required input parameters when creating an instance of GenerateAnswerPDFNode to configure the node correctly. The function initializes the node with essential settings and prepares it for generating answers in PDF format

Chunk 1810
answers in PDF format based on the provided input and configuration.

Chunk 1811
FunctionDef execute(self, state)

Chunk 1812
execute: The function of execute is to generate an answer by constructing a prompt from the user's input and the scraped content, querying the language model, and parsing its response. It updates the state with the generated answer under the

Chunk 1813
generated answer under the 'answer' key.

Chunk 1814
parameters:
- state (dict): The current state of the graph, expected to contain 'user_input', and optionally 'parsed_document' or 'relevant_chunks' within 'keys'.  
Code Description:

Chunk 1815
The execute function begins by logging the execution of the node. It then determines the necessary input keys by calling the get_input_keys function from the BaseNode object. The function fetches input data from the state based on the input keys,

Chunk 1816
based on the input keys, constructs prompts based on the input data and format instructions, and invokes the language model and output parser to generate an answer. The function handles single or multiple chunks of data, dynamically naming and

Chunk 1817
data, dynamically naming and processing each chunk, and finally merging the answers if multiple chunks are present. The generated answer is then updated in the state under the 'answer' key.

Chunk 1818
The execute function utilizes the get_input_keys function to fetch required input keys, interacts with the language model, and output parser to process data, and dynamically manages and merges answers from multiple data chunks. It ensures that the

Chunk 1819
chunks. It ensures that the necessary information is present in the state for answer generation and follows a structured workflow to handle different scenarios efficiently.

Chunk 1820
Note:

Chunk 1821
Developers using the execute function should ensure that the state contains the required keys for user input and document information to generate answers successfully. Understanding the flow of data processing and interaction with the language model

Chunk 1822
with the language model and output parser is crucial for utilizing this function effectively.

Chunk 1823
Output Example:
{'answer': 'Generated answer text based on user input and scraped content'}

Chunk 1824
ClassDef GenerateScraperNode  
GenerateScraperNode: Generates a python script for scraping a website using the specified library.  
Attributes:
- llm_model: An instance of a language model client, configured for generating answers.

Chunk 1825
- library (str): The python library to use for scraping the website.
- source (str): The website to scrape.  
Args:
- input (str): Boolean expression defining the input keys needed from the state.

Chunk 1826
- output (List[str]): List of output keys to be updated in the state.
- node_config (dict): Additional configuration for the node.
- library (str): The python library to use for scraping the website.
- website (str): The website to scrape.

Chunk 1827
- node_name (str): The unique identifier name for the node, defaulting to "GenerateScraper".  
Code Description:

Chunk 1828
The GenerateScraperNode class is responsible for generating a python script that scrapes a website using a specified library. It takes the user's prompt and the scraped content as input and generates a python script that extracts the information

Chunk 1829
that extracts the information requested by the user.

Chunk 1830
The class inherits from the BaseNode class, which is an abstract base class for nodes in a graph-based workflow. It provides common functionality for executing nodes in a graph.  
The GenerateScraperNode class has the following attributes:

Chunk 1831
- llm_model: An instance of a language model client that is configured for generating answers.
- library: The python library to use for scraping the website.
- source: The website to scrape.

Chunk 1832
The execute method of the GenerateScraperNode class generates a python script for scraping a website using the specified library. It takes the current state of the graph as input and returns the updated state with the output key containing the

Chunk 1833
the output key containing the generated answer.

Chunk 1834
The method first interprets the input keys based on the provided input expression and fetches the necessary data from the state. It then constructs a prompt template using the fetched data and the specified library, source, and schema instructions.

Chunk 1835
and schema instructions. The prompt template is used to generate an answer using the language model client.

Chunk 1836
The generated answer is then added to the state with the specified output key and returned.

Chunk 1837
Note: The GenerateScraperNode class requires an instance of a language model client (llm_model) and a schema configuration (node_config["schema"]) to be provided in the node configuration.  
Output Example:
{
"output_key": "generated_python_script"

Chunk 1838
}  
FunctionDef init(self, input, output, library, website, node_config, node_name)  
init: The function of init is to initialize the GenerateScraperNode object with specified parameters.  
parameters:
- self: The instance of the class.

Chunk 1839
- input: A string representing the input data.
- output: A list of strings representing the output data.
- library: A string specifying the library to be used.
- website: A string representing the website to be scraped.

Chunk 1840
- node_config: An optional dictionary containing configuration settings for the node (default is None).
- node_name: A string specifying the name of the node (default is "GenerateScraper").  
Code Description:

Chunk 1841
The init function initializes the GenerateScraperNode object by calling the parent class's constructor with specific parameters. It then assigns values to the instance variables llm_model, library, source, and verbose based on the provided

Chunk 1842
verbose based on the provided arguments. The llm_model is extracted from the node_config dictionary, while the verbose flag is set to False if not specified in node_config.

Chunk 1843
Note:
- Ensure that the necessary parameters are provided when creating an instance of GenerateScraperNode.
- The node_config parameter allows for additional customization of the node's behavior.

Chunk 1844
- The verbose flag controls the verbosity of the node's output, defaulting to False if not explicitly set in node_config.  
FunctionDef execute(self, state)

Chunk 1845
execute: The function of execute is to generate a python script for scraping a website using the specified library.  
parameters:
- state (dict): The current state of the graph. The input keys will be used to fetch the correct data from the state.

Chunk 1846
Code Description:

Chunk 1847
The execute function starts by logging the execution of the node. It then retrieves input keys by calling the get_input_keys function from the BaseNode object. The input data is fetched from the state based on the input keys. The function processes

Chunk 1848
keys. The function processes the input data and prepares a template for generating a python script for website scraping. It handles the schema for output parsing and constructs a template based on the provided input data. The function then uses a

Chunk 1849
The function then uses a prompt template to generate an answer by invoking a chain of operations. Finally, the generated answer is added to the state and returned.

Chunk 1850
The execute function interacts with the get_input_keys function to determine the necessary input keys for fetching data from the state. It also utilizes other objects such as JsonOutputParser, PromptTemplate, llm_model, and StrOutputParser to

Chunk 1851
and StrOutputParser to generate the final answer based on the input data and schema instructions.

Chunk 1852
Note:

Chunk 1853
Developers using the execute function should ensure that the input state contains the required keys for processing. Additionally, they should handle any potential KeyError exceptions that may arise if the input keys are not found in the state.

Chunk 1854
Output Example:
{'output': 'Generated python script for website scraping'}

Chunk 1855
ClassDef GetProbableTagsNode  
GetProbableTagsNode: The function of GetProbableTagsNode is to utilize a language model to identify probable HTML tags within a document that are likely to contain information relevant to a user's query.  
attributes:

Chunk 1856
attributes:
- llm_model: An instance of the language model client used for tag predictions.
- input: Boolean expression defining the input keys needed from the state.
- output: List of output keys to be updated in the state.

Chunk 1857
- model_config: Additional configuration for the language model.
- node_name: The unique identifier name for the node, defaulting to "GetProbableTags".  
Code Description:

Chunk 1858
GetProbableTagsNode is a class that extends the BaseNode class and implements a node in a graph-based workflow. It initializes with input parameters and a language model client. The execute method generates a list of probable HTML tags based on user

Chunk 1859
HTML tags based on user input, updates the state with this list, and handles exceptions if necessary. The class provides a structured approach to processing user queries and extracting relevant HTML tags using a language model.

Chunk 1860
This class interacts with the BaseNode class to inherit common functionalities and ensure consistency in the workflow. It encapsulates the logic for generating prompts, processing language model outputs, and updating the state with probable HTML

Chunk 1861
the state with probable HTML tags. By leveraging the language model, GetProbableTagsNode enhances the efficiency of identifying relevant information in web documents based on user queries.

Chunk 1862
Note:

Chunk 1863
Developers using GetProbableTagsNode should ensure that the necessary input keys are available in the state to avoid KeyError exceptions during execution. Additionally, understanding the structure of the language model and its integration within the

Chunk 1864
its integration within the node is crucial for effective tag prediction.

Chunk 1865
Output Example:
{'probable_tags': ['  
', '  
', '  
', '', '']}
FunctionDef init(self, input, output, node_config, node_name)

Chunk 1866
init: The function of init is to initialize the GetProbableTagsNode object with the provided input, output, node configuration, and node name.
parameters:
- input: str
- output: List[str]
- node_config: dict

Chunk 1867
- node_config: dict
- node_name: str (default value: "GetProbableTags")
Code Description:

Chunk 1868
The init function initializes the GetProbableTagsNode object by calling the parent class's constructor with the specified node name, input, output, and other parameters. It then assigns the "llm_model" and "verbose" attributes based on the values

Chunk 1869
based on the values provided in the node_config dictionary.

Chunk 1870
Note:
- The node_name parameter defaults to "GetProbableTags" if not explicitly provided.
- The "llm_model" attribute is assigned from the node_config dictionary.

Chunk 1871
- The "verbose" attribute is set to False if the "verbose" key is not present in the node_config dictionary.  
FunctionDef execute(self, state)

Chunk 1872
execute: The function of execute is to generate a list of probable HTML tags based on the user's input and update the state with this list.
parameters:

Chunk 1873
parameters:
- state (dict): The current state of the graph. The input keys will be used to fetch the correct data types from the state.
Code Description:

Chunk 1874
The execute function starts by logging the execution of the node. It then calls the get_input_keys function to interpret input keys based on the provided input expression and fetches data from the state. The function constructs a prompt template for

Chunk 1875
a prompt template for the language model, submits it, and parses the output to identify probable HTML tags. By executing a chain involving the language model and an output parser, it obtains the probable tags and updates the state with this

Chunk 1876
updates the state with this information.

Chunk 1877
The execute function is crucial for generating probable HTML tags based on user input within the graph structure. It relies on the get_input_keys function to determine the necessary input keys for fetching data from the state. The function follows a

Chunk 1878
state. The function follows a structured process of creating a prompt, invoking the language model, and parsing the output to provide the desired result.

Chunk 1879
Note:

Chunk 1880
Developers using the execute function should ensure that the input keys provided in the state match the required logical conditions for accurate tag predictions. Additionally, any changes to the prompt template or the chain execution should be

Chunk 1881
the chain execution should be carefully considered to maintain the functionality of the node.

Chunk 1882
Output Example:
{'probable_tags': ['', '', '', '']}

Chunk 1883
ClassDef GraphIteratorNode  
GraphIteratorNode: The GraphIteratorNode class is responsible for instantiating and running multiple graph instances in parallel. It creates as many graph instances as the number of elements in the input list.

Chunk 1884
Attributes:
- verbose (bool): A flag indicating whether to show print statements during execution.  
Args:
- input (str): Boolean expression defining the input keys needed from the state.

Chunk 1885
- output (List[str]): List of output keys to be updated in the state.
- node_config (dict): Additional configuration for the node.
- node_name (str): The unique identifier name for the node, defaulting to "GraphIterator".  
execute:

Chunk 1886
The execute method of the GraphIteratorNode class executes the node's logic to instantiate and run multiple graph instances in parallel. It takes the current state of the graph as input and returns the updated state with the output key containing

Chunk 1887
the output key containing the results of the graph instances.

Chunk 1888
Args:  
state (dict): The current state of the graph. The input keys will be used to fetch the correct data from the state.  
Returns:  
dict: The updated state with the output key containing the results of the graph instances.  
Raises:

Chunk 1889
Raises:  
KeyError: If the input keys are not found in the state, indicating that the necessary information for running the graph instances is missing.  
_async_execute:

Chunk 1890
_async_execute:
The _async_execute method of the GraphIteratorNode class asynchronously executes the node's logic with multiple graph instances running in parallel, using a semaphore of some size for concurrency regulation.  
Args:

Chunk 1891
Args:  
state (dict): The current state of the graph.
batchsize (int): The maximum number of concurrent instances allowed.  
Returns:

Chunk 1892
Returns:  
dict: The updated state with the output key containing the results aggregated out of all parallel graph instances.  
Raises:  
KeyError: If the input keys are not found in the state.

Chunk 1893
Note: The GraphIteratorNode class inherits from the BaseNode class.  
Code Description:

Chunk 1894
The GraphIteratorNode class is a subclass of the BaseNode class and is responsible for running multiple graph instances in parallel. It takes a boolean expression defining the input keys needed from the state and a list of output keys to be updated

Chunk 1895
of output keys to be updated in the state. Additionally, it can be configured with a node_config dictionary and a unique identifier name for the node.

Chunk 1896
The execute method of the GraphIteratorNode class first retrieves the batchsize from the node_config dictionary. It then creates an event loop using asyncio and checks if it is already running. If the event loop is running, it uses

Chunk 1897
loop is running, it uses run_until_complete to execute the _async_execute method asynchronously. Otherwise, it uses asyncio.run to execute the _async_execute method.

Chunk 1898
The _async_execute method first interprets the input keys based on the provided input expression and fetches the corresponding data from the state. It then retrieves the graph_instance from the node_config dictionary and assigns a depth level to it.

Chunk 1899
assigns a depth level to it. Next, it iterates over the urls and creates a deepcopy of the graph_instance for each url. It uses a semaphore to limit the number of concurrent tasks and asynchronously runs each graph instance using asyncio.to_thread.

Chunk 1900
using asyncio.to_thread. The results are gathered using tqdm.gather and stored in the state with the output key.

Chunk 1901
Output Example:
```python
graph_iterator_node = GraphIteratorNode(
input="user_prompt & urls",
output=["results"],
node_config={
"graph_instance": smart_scraper_instance,
}
)
state = graph_iterator_node.execute(state)
print(state)

Chunk 1902
Output: {'results': [result1, result2, result3]}

Chunk 1903
```  
FunctionDef init(self, input, output, node_config, node_name)  
init: The function of init is to initialize a GraphIteratorNode object with specified input, output, node configuration, and node name.  
parameters:

Chunk 1904
parameters:
- self: The instance of the class.
- input: A string representing the input of the node.
- output: A list of strings representing the output of the node.
- node_config: An optional dictionary containing node configuration settings.

Chunk 1905
- node_name: A string representing the name of the node.  
Code Description:

Chunk 1906
The init function initializes a GraphIteratorNode object by calling the superclass's constructor with the provided node name, input, output, 2 (as the number of inputs), and node configuration. It then sets the 'verbose' attribute based on the

Chunk 1907
attribute based on the 'verbose' key in the node configuration dictionary. If the 'verbose' key is not present or the node configuration is None, the 'verbose' attribute is set to False.

Chunk 1908
Note:
- The init function is responsible for setting up the initial state of a GraphIteratorNode object.
- The 'verbose' attribute controls the verbosity level of the node, providing additional information during execution if set to True.

Chunk 1909
FunctionDef execute(self, state)  
execute: The function of execute is to execute the node's logic to instantiate and run multiple graph instances in parallel.  
parameters:

Chunk 1910
parameters:
- state (dict): The current state of the graph. The input keys will be used to fetch the correct data from the state.  
Code Description:

Chunk 1911
The execute function initiates the execution of the node's logic by first retrieving the batch size from the node configuration. It then logs the execution details, including the node name and batch size. The function proceeds to handle asynchronous

Chunk 1912
to handle asynchronous execution by checking and obtaining the event loop. Depending on the event loop status, it either runs the asynchronous execution using the existing loop or creates a new one. The core execution logic is delegated to the

Chunk 1913
logic is delegated to the _async_execute function, which manages the parallel execution of multiple graph instances. Upon completion, the function returns the updated state with the aggregated results of the graph instances.

Chunk 1914
The execute function serves as the entry point for orchestrating the concurrent execution of graph instances within the specified batch size limit. By leveraging asyncio, it ensures efficient handling of parallel tasks, enhancing the overall

Chunk 1915
tasks, enhancing the overall performance of the graph processing workflow.

Chunk 1916
Note:

Chunk 1917
Developers utilizing the execute function should ensure that the necessary input keys are present in the state to prevent KeyError exceptions. Additionally, adjusting the batch size parameter can optimize concurrency levels based on system resources

Chunk 1918
based on system resources and performance requirements.

Chunk 1919
Output Example:
{'output': [result1, result2, result3]}  
FunctionDef _async_execute(self, state, batchsize)

Chunk 1920
_async_execute: The function of _async_execute is to asynchronously execute the node's logic with multiple graph instances running in parallel, using a semaphore for concurrency regulation.  
parameters:

Chunk 1921
parameters:
- state (dict): The current state of the graph.
- batchsize (int): The maximum number of concurrent instances allowed.  
Code Description:

Chunk 1922
The _async_execute function is designed to execute the node's logic asynchronously with multiple graph instances running in parallel. It starts by interpreting input keys based on the provided input expression and fetching data from the state based

Chunk 1923
data from the state based on these keys. The function then assigns a depth level to the graph instance and sets the user prompt. It creates a semaphore to limit the number of concurrent tasks and runs each graph instance in a separate thread. The

Chunk 1924
in a separate thread. The results from all parallel graph instances are gathered, and the updated state with the aggregated output is returned.

Chunk 1925
This function utilizes asyncio to handle asynchronous operations efficiently. It ensures that the graph instances run concurrently within the specified batch size limit, enhancing performance by leveraging parallel processing. By using semaphores,

Chunk 1926
By using semaphores, it regulates the concurrency level, preventing resource exhaustion and optimizing the execution of multiple tasks simultaneously.

Chunk 1927
The _async_execute function is a crucial component of the GraphIteratorNode, enabling the execution of multiple graph instances concurrently. It plays a vital role in processing data efficiently and aggregating results from parallel executions,

Chunk 1928
from parallel executions, contributing to the overall performance of the graph processing workflow.

Chunk 1929
Note:

Chunk 1930
Developers using this function should ensure that the input keys are correctly specified in the state to avoid KeyError exceptions. Additionally, they should consider adjusting the batch size parameter based on system resources and performance

Chunk 1931
resources and performance requirements to achieve optimal concurrency levels.

Chunk 1932
Output Example:
{'output': [result1, result2, result3]}  
FunctionDef _async_run(graph)  
_async_run: The function of _async_run is to execute a graph operation asynchronously.  
parameters:

Chunk 1933
parameters:
- graph: Represents the graph object on which the operation will be performed.  
Code Description:

Chunk 1934
The _async_run function is an asynchronous function that takes a graph object as a parameter. Within the function, it uses a semaphore to control access to a shared resource and then executes the graph operation asynchronously using

Chunk 1935
asynchronously using asyncio.to_thread to run the graph.

Chunk 1936
Note:
Ensure that the graph object passed to the function is valid and contains the necessary data for the operation.  
Output Example:
A possible return value from the _async_run function after executing the graph operation.

Chunk 1937
ClassDef ImageToTextNode  
ImageToTextNode: The function of ImageToTextNode is to retrieve images from a list of URLs and return a description of the images using an image-to-text model.  
Attributes:

Chunk 1938
Attributes:
- llm_model: An instance of the language model client used for image-to-text conversion.
- verbose (bool): A flag indicating whether to show print statements during execution.  
Code Description:

Chunk 1939
The ImageToTextNode class is a subclass of the BaseNode class and is responsible for retrieving images from a list of URLs and generating text descriptions of the images using an image-to-text model. It has an execute method that takes the current

Chunk 1940
method that takes the current state of the graph as input and returns the updated state with the extracted text from the images.

Chunk 1941
The constructor (init) method initializes the ImageToTextNode object with the following parameters:
- input: A string representing a boolean expression defining the input keys needed from the state.

Chunk 1942
- output: A list of strings representing the output keys to be updated in the state.
- node_config: An optional dictionary representing additional configuration for the node.

Chunk 1943
- node_name: A string representing the unique identifier name for the node, defaulting to "ImageToText".

Chunk 1944
The constructor calls the super() method to initialize the BaseNode superclass with the node_name, "node" as the node_type, input, output, 1 as the min_input_len, and node_config.

Chunk 1945
The execute method takes the state dictionary as input and retrieves the list of URLs from the state. It then iterates over the URLs, retrieves the text description of each image using the llm_model, and appends it to the img_desc list. Finally, it

Chunk 1946
img_desc list. Finally, it updates the state with the img_desc list using the output key.

Chunk 1947
Note: The ImageToTextNode class relies on the BaseNode class for its functionality.  
Output Example:
{
"img_desc": [
"Description of image 1",
"Description of image 2",
"Description of image 3"
]
}

Chunk 1948
]
}  
FunctionDef init(self, input, output, node_config, node_name)  
init: The function of init is to initialize the ImageToTextNode object with the provided parameters.  
parameters:
- self: The instance of the class.

Chunk 1949
- input: A string representing the input data.
- output: A list of strings representing the output data.
- node_config: An optional dictionary containing configuration settings for the node.
- node_name: A string representing the name of the node.

Chunk 1950
Code Description:

Chunk 1951
The init function initializes the ImageToTextNode object by calling the superclass's constructor with the provided parameters. It then assigns values to the instance variables llm_model, verbose, and max_images based on the values provided in the

Chunk 1952
on the values provided in the node_config dictionary. If the node_config dictionary is not provided or does not contain certain keys, default values are used.

Chunk 1953
Note:
- Ensure that the necessary parameters are provided when initializing the ImageToTextNode object to avoid any errors.

Chunk 1954
- If specific configuration settings are required, provide them in the node_config dictionary to customize the behavior of the node.  
FunctionDef execute(self, state)

Chunk 1955
execute: The function of execute is to generate text from an image using an image-to-text model and update the state with the extracted text.  
parameters:

Chunk 1956
parameters:
- state (dict): The current state of the graph. The input keys will be used to fetch the correct data types from the state.  
Code Description:

Chunk 1957
The execute function retrieves a list of URLs from the state, processes the images using an image-to-text model, and returns the extracted text. If the number of images to process is less than 1, the function skips the conversion. It handles

Chunk 1958
the conversion. It handles exceptions related to incompatible image formats or model failures gracefully. The updated state includes the extracted text associated with the input key.

Chunk 1959
The function relies on the get_input_keys method from the BaseNode class to determine the necessary input keys for fetching data from the state. It interacts with the llm_model to run the image-to-text conversion. The execute function is a crucial

Chunk 1960
execute function is a crucial part of the image-to-text node's functionality within the project.

Chunk 1961
Note:
Developers should ensure that the input keys provided in the state match the expected format to retrieve the necessary data for image processing.  
Output Example:
{'extracted_text': ['Text extracted from the image']}

Chunk 1962
ClassDef MergeAnswersNode  
MergeAnswersNode: The MergeAnswersNode class is responsible for merging the answers from multiple graph instances into a single answer.  
Attributes:

Chunk 1963
Attributes:
- llm_model: An instance of a language model client, configured for generating answers.
- verbose (bool): A flag indicating whether to show print statements during execution.  
Args:

Chunk 1964
Args:
- input (str): Boolean expression defining the input keys needed from the state.
- output (List[str]): List of output keys to be updated in the state.
- node_config (dict): Additional configuration for the node.

Chunk 1965
- node_name (str): The unique identifier name for the node, defaulting to "MergeAnswers".  
execute:

Chunk 1966
execute:
The execute method of the MergeAnswersNode class merges the answers from multiple graph instances into a single answer. It takes the current state of the graph as input and returns the updated state with the generated answer.  
Parameters:

Chunk 1967
Parameters:
- state (dict): The current state of the graph. The input keys will be used to fetch the correct data from the state.  
Returns:
- dict: The updated state with the output key containing the generated answer.  
Raises:

Chunk 1968
Raises:
- KeyError: If the input keys are not found in the state, indicating that the necessary information for generating an answer is missing.  
Code Description:

Chunk 1969
The MergeAnswersNode class inherits from the BaseNode class and overrides its execute method. It initializes the llm_model and verbose attributes based on the node_config parameter. The execute method first logs the execution of the node. It then

Chunk 1970
of the node. It then interprets the input keys based on the provided input expression and fetches the corresponding data from the state. The user_prompt and answers are extracted from the input_data. The answers are merged into a single string, with

Chunk 1971
into a single string, with each answer prefixed by the website number. The output_parser is initialized based on the node_config schema, if provided, or with a default JsonOutputParser. The format_instructions are obtained from the output_parser. A

Chunk 1972
from the output_parser. A template_merge string is defined with placeholders for the format_instructions, user_prompt, and website_content. A PromptTemplate is created with the template_merge and the necessary input variables and partial variables.

Chunk 1973
and partial variables. The merge_chain is defined as the prompt_template followed by the llm_model and the output_parser. The merge_chain is invoked with the user_prompt as input, and the generated answer is obtained. Finally, the state is updated

Chunk 1974
Finally, the state is updated with the generated answer and returned.

Chunk 1975
The MergeAnswersNode class is called by the following objects in the project:
- scrapegraphai\graphs\csv_scraper_multi_graph.py/CSVScraperMultiGraph/_create_graph
- scrapegraphai\graphs\json_scraper_multi_graph.py/JSONScraperMultiGraph/_create_graph

Chunk 1976
- scrapegraphai\graphs\pdf_scraper_multi_graph.py/PdfScraperMultiGraph/_create_graph
- scrapegraphai\graphs\smart_scraper_multi_graph.py/SmartScraperMultiGraph/_create_graph

Chunk 1977
- scrapegraphai\graphs\xml_scraper_multi_graph.py/XMLScraperMultiGraph/_create_graph  
Note:
- The MergeAnswersNode class requires the llm_model and schema to be provided in the node_config parameter.

Chunk 1978
- The input expression should be a boolean expression defining the required input keys from the state.
- The output key containing the generated answer will be updated in the state.

Chunk 1979
- The MergeAnswersNode class is designed to be used within a graph-based workflow for web scraping and searching.  
FunctionDef init(self, input, output, node_config, node_name)

Chunk 1980
init: The function of init is to initialize the MergeAnswersNode object with the provided input parameters.  
parameters:
- self: The instance of the MergeAnswersNode class.
- input: A string representing the input data.

Chunk 1981
- output: A list of strings representing the output data.
- node_config: An optional dictionary containing configuration parameters for the node (default is None).

Chunk 1982
- node_name: A string representing the name of the node (default is "MergeAnswers").  
Code Description:

Chunk 1983
The init function initializes the MergeAnswersNode object by calling the superclass's constructor with the node_name, "node", input, output, 2, and node_config parameters. It then assigns the value of the "llm_model" key from the node_config

Chunk 1984
key from the node_config dictionary to the self.llm_model attribute. Additionally, it sets the self.verbose attribute to False if node_config is None, otherwise, it retrieves the value of the "verbose" key from the node_config dictionary with a

Chunk 1985
node_config dictionary with a default value of False.

Chunk 1986
Note:
- Ensure that the node_config dictionary contains the "llm_model" key to avoid potential KeyError when accessing self.llm_model.
- The verbose attribute controls the verbosity of the node and can be set in the node_config dictionary.

Chunk 1987
FunctionDef execute(self, state)  
execute: The function of execute is to merge answers from multiple graph instances into a single answer.  
parameters:

Chunk 1988
parameters:
- state (dict): The current state of the graph. The input keys will be used to fetch the correct data from the state.  
Code Description:

Chunk 1989
The execute function begins by logging the execution of the node. It then determines the input keys by calling the get_input_keys function from the BaseNode object. Subsequently, it fetches the necessary data from the state based on the input keys.

Chunk 1990
based on the input keys. The function merges the answers into a single string and initializes an output parser based on the node's configuration. It constructs a template for merging the website content and user prompt, then invokes a merge chain

Chunk 1991
then invokes a merge chain involving a prompt template, an LLM model, and the output parser to generate the final answer. Finally, it updates the state with the generated answer and returns the updated state.

Chunk 1992
The execute function relies on the get_input_keys function from the BaseNode object to determine the necessary input keys for fetching data from the state. It also interacts with a JsonOutputParser object and a PromptTemplate object to format and

Chunk 1993
object to format and merge the answers effectively.

Chunk 1994
Note:
Developers using the execute function should ensure that the input keys provided in the state match the required data structure for successful answer generation.  
Output Example:

Chunk 1995
Output Example:
{'output_key': 'Merged answer generated from multiple graph instances'}

Chunk 1996
ClassDef MergeGeneratedScriptsNode  
MergeGeneratedScriptsNode: The function of MergeGeneratedScriptsNode is to merge scripts generated for different URLs into a single script.  
Attributes:

Chunk 1997
Attributes:
- llm_model: An instance of a language model client, configured for generating answers.
- verbose (bool): A flag indicating whether to show print statements during execution.  
Code Description:

Chunk 1998
Code Description:
The MergeGeneratedScriptsNode class is responsible for merging scripts generated for different URLs into a single script. It inherits from the BaseNode class, which is an abstract base class for nodes in a graph-based workflow.

Chunk 1999
The constructor method (init) initializes the MergeGeneratedScriptsNode object with the following parameters:
- input: A string representing a boolean expression defining the input keys needed from the state.

Chunk 2000
- output: A list of strings representing the output keys to be updated in the state.
- node_config: An optional dictionary containing additional configuration for the node.

Chunk 2001
- node_name: A string representing the unique identifier name for the node, defaulting to "MergeGeneratedScripts".

Chunk 2002
The execute method executes the node's logic to merge the answers from multiple graph instances into a single answer. It takes the current state of the graph as input and returns the updated state with the output key containing the generated answer.

Chunk 2003
the generated answer. The method performs the following steps:

Chunk 2004
1. Logs the execution of the node.
2. Interprets the input keys based on the provided input expression.
3. Fetches data from the state based on the input keys.
4. Merges the scripts into one string.

Chunk 2005
5. Invokes a prompt template to generate the merged script using the llm_model.
6. Updates the state with the generated answer.

Chunk 2006
Note: The code contains commented out sections that are not currently being used. These sections are related to output parsing and formatting instructions.  
Output Example:
{
"merged_script": "The merged script output"
}

Chunk 2007
}  
FunctionDef init(self, input, output, node_config, node_name)  
init: The function of init is to initialize the MergeGeneratedScriptsNode object with the provided input, output, node configuration, and node name.  
parameters:
- input: str

Chunk 2008
parameters:
- input: str
- output: List[str]
- node_config: Optional[dict] (default = None)
- node_name: str (default = "MergeGeneratedScripts")  
Code Description:

Chunk 2009
In this function, the MergeGeneratedScriptsNode object is initialized by calling the superclass's constructor with the node name, "node", input, output, a depth of 2, and the node configuration. The function then assigns the "llm_model" value from

Chunk 2010
the "llm_model" value from the node configuration to the "llm_model" attribute of the object. Additionally, it sets the "verbose" attribute based on the "verbose" key in the node configuration, defaulting to False if the key is not present.

Chunk 2011
Note:
- Ensure that the "llm_model" key is present in the node configuration to avoid any KeyError when initializing the object.
- If the "verbose" key is not provided in the node configuration, the "verbose" attribute will default to False.

Chunk 2012
FunctionDef execute(self, state)  
execute: The function of execute is to merge answers from multiple graph instances into a single answer.  
parameters:

Chunk 2013
parameters:
- state (dict): The current state of the graph. The input keys will be used to fetch the correct data from the state.  
Code Description:

Chunk 2014
The execute function begins by logging the execution of the node. It then retrieves input keys from the state using the get_input_keys method. Subsequently, it fetches data based on the input keys, merges the scripts into a single string, and

Chunk 2015
into a single string, and generates a template for merging the scripts. The function then invokes a chain of operations involving a PromptTemplate, an LLM model, and a StrOutputParser to generate an answer based on the user prompt and scripts.

Chunk 2016
the user prompt and scripts. Finally, it updates the state with the generated answer and returns the updated state.

Chunk 2017
The execute function interacts with the get_input_keys method from the BaseNode class to determine the necessary input keys for fetching data from the state. It also utilizes a PromptTemplate, an LLM model, and a StrOutputParser to process the user

Chunk 2018
to process the user prompt and scripts and generate a final answer.

Chunk 2019
Note:
Developers using the execute function should ensure that the input keys provided in the state are accurate to avoid KeyError exceptions when fetching data.  
Output Example:

Chunk 2020
Output Example:
{'output_key': 'Merged answer generated from multiple graph instances'}

Chunk 2021
ClassDef ParseNode  
ParseNode: A node responsible for parsing HTML content from a document and splitting it into chunks for further processing.  
Attributes:
- verbose (bool): A flag indicating whether to show print statements during execution.

Chunk 2022
Code Description:

Chunk 2023
The ParseNode class is a subclass of the BaseNode class and is used in the web scraping workflow to parse HTML content from a document. It enhances the scraping workflow by allowing for targeted extraction of content, thereby optimizing the

Chunk 2024
thereby optimizing the processing of large HTML documents.

Chunk 2025
The ParseNode class has the following attributes:
- verbose: A boolean flag indicating whether to show print statements during execution.

Chunk 2026
The ParseNode class also has an execute method that executes the node's logic to parse the HTML document content and split it into chunks. It takes the following argument:

Chunk 2027
- state (dict): The current state of the graph. The input keys will be used to fetch the correct data from the state.  
The execute method performs the following steps:
1. Logs the execution of the node.

Chunk 2028
2. Interprets the input keys based on the provided input expression.
3. Fetches data from the state based on the input keys.
4. Parses the document content and splits it into chunks based on the configuration.

Chunk 2029
5. Updates the state with the output key containing the parsed content chunks.
6. Returns the updated state.  
Output Example:
```
state = {
'url': 'https://example.com',
'doc': 'Example content',
'parsed_doc': ['Example', 'content']
}

Chunk 2030
parse_node = ParseNode(input='doc', output=['parsed_doc'])
updated_state = parse_node.execute(state)

print(updated_state)

Output: {'url': 'https://example.com', 'doc': 'Example content', 'parsed_doc': ['Example', 'content']}

Chunk 2031
```  
FunctionDef init(self, input, output, node_config, node_name)  
init: The function of init is to initialize the ParseNode object with input parameters.  
parameters:
- self: The instance of the class.

Chunk 2032
- input: A string representing the input data for the node.
- output: A list of strings representing the output data from the node.
- node_config: An optional dictionary containing configuration settings for the node (default is None).

Chunk 2033
- node_name: A string representing the name of the node (default is "Parse").  
Code Description:

Chunk 2034
The init function initializes the ParseNode object by calling the superclass's constructor with specific parameters. It sets the verbose attribute based on the "verbose" key in the node_config dictionary (default is False if node_config is None). It

Chunk 2035
if node_config is None). It also sets the parse_html attribute based on the "parse_html" key in the node_config dictionary (default is True if node_config is None).

Chunk 2036
Note:
- The node_name parameter allows customizing the name of the node during initialization.
- The node_config parameter can be used to provide additional configuration settings, such as verbosity and HTML parsing options.

Chunk 2037
FunctionDef execute(self, state)  
execute: The function of execute is to execute the node's logic to parse the HTML document content and split it into chunks.
parameters:

Chunk 2038
parameters:
- state (dict): The current state of the graph. The input keys will be used to fetch the correct data from the state.  
Code Description:

Chunk 2039
The execute function begins by logging the execution of the node. It then determines the input keys by calling the get_input_keys function from the BaseNode object. After fetching the input data based on the input keys, the function proceeds to

Chunk 2040
the function proceeds to parse the HTML document content and split it into chunks. The parsed content is stored in the 'chunks' variable based on the configuration settings. Finally, the updated state containing the parsed content chunks is

Chunk 2041
the parsed content chunks is returned.

Chunk 2042
The execute function relies on the get_input_keys method to determine the necessary input keys for fetching data from the state. It also utilizes the Html2TextTransformer class to transform HTML documents into text for chunking. Additionally, the

Chunk 2043
chunking. Additionally, the function interacts with the 'chunk' method to split the content into manageable chunks based on the specified chunk size.

Chunk 2044
Note: Developers using this function should ensure that the input keys provided in the state match the required data for parsing the content. It's important to handle any KeyError exceptions that may arise if the input keys are not found in the

Chunk 2045
keys are not found in the state.

Chunk 2046
Output Example:
{'output_key': ['chunk1', 'chunk2', ...]}

Chunk 2047
ClassDef RAGNode

Chunk 2048
RAGNode: The RAGNode class is responsible for compressing input tokens and storing the document in a vector database for retrieval. It is a key component in implementing the Retrieval-Augmented Generation (RAG) technique for web scraping. This class

Chunk 2049
for web scraping. This class allows for the scraping of large documents without exceeding the token limit of the language model.

Chunk 2050
Attributes:
- llm_model: An instance of a language model client, configured for generating answers.
- embedder_model: An instance of an embedding model client, configured for generating embeddings.

Chunk 2051
- verbose (bool): A flag indicating whether to show print statements during execution.  
Args:
- input (str): A boolean expression defining the input keys needed from the state.
- output (List[str]): A list of output keys to be updated in the state.

Chunk 2052
- node_config (dict): Additional configuration for the node.
- node_name (str): The unique identifier name for the node, defaulting to "RAG".  
Code Description:

Chunk 2053
The RAGNode class inherits from the BaseNode class and implements the execute method to perform the logic of the RAG technique. The execute method takes the current state of the graph as input and updates it with relevant chunks of the document.

Chunk 2054
The execute method first interprets the input keys based on the provided input expression and fetches the corresponding data from the state. It then processes the document into chunks and stores them in a list. The chunks are represented as

Chunk 2055
The chunks are represented as instances of the Document class, which contain the page content and metadata.

Chunk 2056
Next, the RAGNode checks if an embedder_model is provided. If not, it uses the llm_model as the embedder_model. It then creates an index using the FAISS library, which allows for efficient similarity search and retrieval of vectors. If a cache_path

Chunk 2057
of vectors. If a cache_path is specified in the node_config, the index is saved to the cache directory. Otherwise, a new index is created.

Chunk 2058
After creating the index, the RAGNode sets up a retriever using the index. It also sets up a pipeline of transformers for compressing the tokens and a compressor-retriever for retrieving relevant chunks based on user prompts.

Chunk 2059
The compressed_docs are obtained by invoking the compression_retriever with the user_prompt. The compressed_docs are then stored in the state with the output key.

Chunk 2060
Note: The RAGNode class requires a language model client and an embedding model client to be provided in the node_config. It also expects the input keys to be present in the state.  
Output Example:
{
"relevant_chunks": [
{

Chunk 2061
{
"relevant_chunks": [
{
"page_content": "This is chunk 1",
"metadata": {
"chunk": 1
}
},
{
"page_content": "This is chunk 2",
"metadata": {
"chunk": 2
}
}
]
}  
FunctionDef init(self, input, output, node_config, node_name)

Chunk 2062
init: The function of init is to initialize a RAGNode object with specified input, output, node configuration, and node name.  
parameters:
- input: A string representing the input of the node.

Chunk 2063
- output: A list of strings representing the output of the node.
- node_config: An optional dictionary containing node configuration parameters.
- node_name: A string representing the name of the node (default value is "RAG").  
Code Description:

Chunk 2064
In the init function, the RAGNode object is initialized by calling the superclass's constructor with the provided node_name, "node", input, output, 2, and node_config parameters. Subsequently, the function assigns values to the following attributes:

Chunk 2065
- llm_model: Extracted from the node_config dictionary.
- embedder_model: Extracted from the node_config dictionary, with a default value of None.

Chunk 2066
- verbose: Set to False if node_config is None, otherwise extracted from the node_config dictionary with a default value of False.
- cache_path: Extracted from the node_config dictionary with a default value of False.

Chunk 2067
Note: It is important to ensure that the necessary parameters are provided when initializing a RAGNode object to avoid any unexpected behavior.  
FunctionDef execute(self, state)

Chunk 2068
execute: The function of execute is to implement the logic for Retrieval-Augmented Generation (RAG) by updating the state with relevant document chunks based on the input keys provided.  
parameters:

Chunk 2069
parameters:
- state (dict): The current state of the graph. The input keys will be used to fetch the correct data from the state.  
Code Description:

Chunk 2070
The execute function starts by logging the execution of the node. It then interprets the input keys using the get_input_keys method to fetch data from the state. The function processes the input data, chunking the document and creating Document

Chunk 2071
and creating Document objects with metadata. Depending on the cache_path configuration, it either saves or loads indexes using FAISS for efficient retrieval. The function sets up a retrieval pipeline with filters for redundancy and relevance,

Chunk 2072
for redundancy and relevance, compresses the tokens, and updates the state with the compressed documents.

Chunk 2073
The execute function demonstrates a structured approach to implementing RAG, utilizing FAISS for indexing, embedding models for processing, and a compression pipeline for document retrieval and compression.  
Note:

Chunk 2074
Note:
Developers using the execute function should ensure that the input keys provided in the state are accurate and correspond to the required data for RAG implementation.  
Output Example:

Chunk 2075
Output Example:
{'output_key': ['compressed_chunk1', 'compressed_chunk2', ...]}

Chunk 2076
ClassDef RobotsNode  
RobotsNode: A node responsible for checking if a website is scrapeable or not based on the robots.txt file.  
Attributes:
- llm_model: An instance of the language model client used for checking scrapeability.

Chunk 2077
- force_scraping (bool): A flag indicating whether scraping should be enforced even if disallowed by robots.txt.
- verbose (bool): A flag indicating whether to show print statements during execution.  
Code Description:

Chunk 2078
The RobotsNode class is a node in a graph-based workflow that is responsible for determining if a website is scrapeable or not based on the robots.txt file. It uses a language model to determine if the website allows scraping of the provided path.

Chunk 2079
The RobotsNode class acts as a starting point in many scraping workflows, preparing the state with the necessary HTML content for further processing by subsequent nodes in the graph.  
The RobotsNode class has the following attributes:

Chunk 2080
- llm_model: An instance of the language model client used for checking scrapeability.
- force_scraping: A flag indicating whether scraping should be enforced even if disallowed by robots.txt. It defaults to False.

Chunk 2081
- verbose: A flag indicating whether to show print statements during execution. It defaults to False.

Chunk 2082
The RobotsNode class also has an execute method that checks if a website is scrapeable based on the robots.txt file and updates the state with the scrapeability status. The method constructs a prompt for the language model, submits it, and parses

Chunk 2083
model, submits it, and parses the output to determine if scraping is allowed. It takes the following parameter:

Chunk 2084
- state: A dictionary representing the current state of the graph.  
The execute method returns the updated state with the output key containing the scrapeability status.

Chunk 2085
Note: The RobotsNode class inherits from the BaseNode class, which is an abstract base class for nodes in a graph-based workflow.  
Output Example:
{
"is_scrapable": "yes"
}  
FunctionDef init(self, input, output, node_config, node_name)

Chunk 2086
init: The function of init is to initialize the RobotsNode object with input parameters and set specific attributes based on the provided node_config.  
parameters:
- self: The instance of the class.

Chunk 2087
- input: A string representing the input for the node.
- output: A list of strings representing the output for the node.
- node_config: An optional dictionary containing configuration parameters for the node. Default is None.

Chunk 2088
- node_name: A string representing the name of the node. Default is "RobotNode".  
Code Description:

Chunk 2089
The init function initializes the RobotsNode object by calling the parent class's constructor with specific parameters. It then sets the "llm_model" attribute of the object based on the value in the node_config dictionary. Additionally, it

Chunk 2090
dictionary. Additionally, it determines the values of "force_scraping" and "verbose" attributes based on the presence of corresponding keys in the node_config dictionary.

Chunk 2091
Note:
- Make sure to provide the required input and output parameters when initializing a RobotsNode object.

Chunk 2092
- If node_config is provided, ensure that it contains the necessary keys such as "llm_model", "force_scraping", and "verbose" to avoid any attribute errors.  
FunctionDef execute(self, state)

Chunk 2093
execute: The function of execute is to check if a website is scrapeable based on the robots.txt file, update the state with the scrapeability status, and handle the scraping process accordingly.  
parameters:

Chunk 2094
parameters:
- state (dict): The current state of the graph. The input keys will be used to fetch the necessary information for checking scrapeability.  
Code Description:

Chunk 2095
The execute function begins by logging the execution of the node and then proceeds to interpret the input keys based on the provided input expression by calling the get_input_keys function. It fetches data from the state based on the input keys and

Chunk 2096
based on the input keys and constructs a prompt template for the language model. The function then loads the robots.txt file of the website, determines the scraping agent, and invokes the language model to check if scraping is allowed. Depending on

Chunk 2097
is allowed. Depending on the result, it updates the state with the scrapeability status and handles scenarios where scraping is not allowed or enforced.

Chunk 2098
The execute function is crucial for determining the scrapeability of a website based on the robots.txt file and ensuring that scraping operations are compliant with the website's policies. It interacts with the get_input_keys function to fetch the

Chunk 2099
function to fetch the necessary data from the state and utilizes external components such as the AsyncChromiumLoader, PromptTemplate, and output_parser to facilitate the scraping evaluation process.

Chunk 2100
Note:

Chunk 2101
Developers utilizing the execute function should ensure that the input keys provided in the state align with the requirements for checking scrapeability. Additionally, they should handle exceptions such as missing input keys, unavailable language

Chunk 2102
keys, unavailable language models, and non-scrapeable websites as per the defined logic in the function.

Chunk 2103
Output Example:
{'output': 'yes'}

Chunk 2104
ClassDef SearchInternetNode

Chunk 2105
SearchInternetNode: The SearchInternetNode class is responsible for generating a search query based on the user's input and searching the internet for relevant information. It constructs a prompt for the language model, submits it, and processes the

Chunk 2106
submits it, and processes the output to generate a search query. The class then uses the search query to find relevant information on the internet and updates the state with the generated answer.

Chunk 2107
Attributes:
- llm_model: An instance of the language model client used for generating search queries.
- verbose (bool): A flag indicating whether to show print statements during execution.  
Args:

Chunk 2108
Args:
- input (str): Boolean expression defining the input keys needed from the state.
- output (List[str]): List of output keys to be updated in the state.
- node_config (dict): Additional configuration for the node.

Chunk 2109
- node_name (str): The unique identifier name for the node, defaulting to "SearchInternet".  
execute:

Chunk 2110
execute:
The execute method generates an answer by constructing a prompt from the user's input and the scraped content, querying the language model, and parsing its response. It then updates the state with the generated answer.  
Args:

Chunk 2111
Args:
- state (dict): The current state of the graph. The input keys will be used to fetch the correct data types from the state.  
Returns:
- dict: The updated state with the output key containing the generated answer.  
Raises:

Chunk 2112
Raises:
- KeyError: If the input keys are not found in the state, indicating that the necessary information for generating the answer is missing.  
Code Description:

Chunk 2113
The SearchInternetNode class is a subclass of the BaseNode class and inherits its attributes and methods. It overrides the execute method to implement the specific logic for generating a search query and updating the state with the answer.

Chunk 2114
The init method initializes the SearchInternetNode object by calling the super().init() method from the BaseNode class. It sets the llm_model attribute to the llm_model provided in the node_config dictionary. It also sets the verbose attribute to

Chunk 2115
sets the verbose attribute to False if node_config is None, otherwise it retrieves the value from the node_config dictionary. The search_engine and max_results attributes are set to the values provided in the node_config dictionary, with default

Chunk 2116
dictionary, with default values of "google" and 3, respectively.

Chunk 2117
The execute method starts by logging the execution of the node. It then retrieves the input keys from the state using the get_input_keys method. The input data is fetched from the state based on the input keys.

Chunk 2118
A search prompt template is defined using a PromptTemplate object, which includes the user's prompt. The search prompt is then passed to the llm_model to generate a search query. The output_parser is used to parse the response from the llm_model and

Chunk 2119
from the llm_model and extract the search query.

Chunk 2120
The search query is logged, and the search_on_web function is called to search the internet using the query. The search_on_web function returns the search results as a list of URLs.

Chunk 2121
If no search results are found, a ValueError is raised. Otherwise, the state is updated with the search results using the output key specified in the constructor.  
Finally, the updated state is returned.  
Note:

Chunk 2122
Note:
- The SearchInternetNode class requires a language model client (llm_model) to generate search queries.
- The search_engine attribute determines the search engine to use (default is "google").

Chunk 2123
- The max_results attribute determines the maximum number of search results to retrieve (default is 3).  
Output Example:
{
"search_results": [
"https://www.example.com/result1",
"https://www.example.com/result2",
"https://www.example.com/result3"
]

Chunk 2124
]
}  
FunctionDef init(self, input, output, node_config, node_name)  
init: The function of init is to initialize the SearchInternetNode object with specific parameters.  
parameters:
- self: The instance of the class.

Chunk 2125
- input: A string representing the input data.
- output: A list of strings representing the output data.
- node_config: An optional dictionary containing configuration settings for the node (default is None).

Chunk 2126
- node_name: A string representing the name of the node (default is "SearchInternet").  
Code Description:

Chunk 2127
In the init function, the SearchInternetNode object is initialized by calling the superclass's constructor with the provided parameters. The function sets the attributes llm_model, verbose, search_engine, and max_results based on the values provided

Chunk 2128
based on the values provided in the node_config dictionary. If node_config is None, verbose is set to False by default, search_engine is set to "google" by default, and max_results is set to 3 by default.

Chunk 2129
Note:
- Ensure that the necessary parameters are provided when initializing a SearchInternetNode object to avoid errors.

Chunk 2130
- If specific configuration settings are required, provide them in the node_config dictionary to customize the behavior of the node.  
FunctionDef execute(self, state)

Chunk 2131
execute: The function of execute is to generate an answer by constructing a prompt from the user's input and scraped content, querying the language model, and parsing its response. It then updates the state with the generated answer.  
parameters:

Chunk 2132
parameters:
- state (dict): The current state of the graph. The input keys will be used to fetch the correct data types from the state.  
Code Description:

Chunk 2133
The execute function begins by logging the execution of the node. It retrieves input keys from the state using the get_input_keys function. The user's prompt is extracted from the input data. A search prompt template is constructed based on the user

Chunk 2134
constructed based on the user prompt. The function then executes a chain involving the language model and an output parser to obtain a search query. This query is used to search the web using the search_on_web function. If no results are found, a

Chunk 2135
If no results are found, a ValueError is raised. Finally, the state is updated with the generated answer.

Chunk 2136
The execute function interacts with the get_input_keys function to determine the necessary input keys from the state. It also calls the search_on_web function to perform the web search based on the generated query. This function is a crucial part of

Chunk 2137
function is a crucial part of the SearchInternetNode's functionality within the project, enabling the node to generate answers based on user prompts and web searches.

Chunk 2138
Note:

Chunk 2139
Developers should ensure that the input keys provided in the state match the logical conditions specified to obtain the desired state keys. Additionally, valid search engine options ('Google', 'DuckDuckGo', or 'Bing') should be provided when calling

Chunk 2140
be provided when calling the search_on_web function.

Chunk 2141
Output Example:
{'output': ['http://example.com', 'http://example.org', ...]}

Chunk 2142
ClassDef SearchLinkNode  
SearchLinkNode: A node that filters out relevant links in the webpage content for the user prompt.  
Attributes:
- llm_model: An instance of the language model client used for generating answers.

Chunk 2143
- verbose (bool): A flag indicating whether to show print statements during execution.  
Code Description:

Chunk 2144
The SearchLinkNode class is a node in a graph-based workflow that is designed to filter out relevant links in the webpage content based on a user prompt. It expects to receive already scraped links on the webpage, so it is recommended to use this

Chunk 2145
it is recommended to use this node after the FetchNode.

Chunk 2146
The class inherits from the BaseNode class and overrides its execute method. The execute method filters out relevant links from the webpage content that are relevant to the user prompt. It also ensures that all links are navigable. The filtered

Chunk 2147
are navigable. The filtered links are then added to the state as the output key.

Chunk 2148
The execute method takes a state dictionary as input and returns an updated state dictionary. It raises a KeyError if the input keys are not found in the state, indicating that the necessary information for generating the answer is missing.

Chunk 2149
The class has two attributes:
- llm_model: An instance of the language model client used for generating answers. This attribute is set through the node_config dictionary passed to the constructor.

Chunk 2150
- verbose: A boolean flag indicating whether to show print statements during execution. This attribute is set to False by default, but can be overridden through the node_config dictionary.  
The class constructor takes the following arguments:

Chunk 2151
- input: A string representing a boolean expression defining the input keys needed from the state.
- output: A list of strings representing the output keys to be updated in the state.

Chunk 2152
- node_config: An optional dictionary representing additional configuration for the node.
- node_name: A string representing the unique identifier name for the node. It defaults to "GenerateLinks".

Chunk 2153
The SearchLinkNode class is typically used in a graph-based workflow, where it can be connected to other nodes such as FetchNode, ParseNode, RAGNode, GenerateAnswerNode, GraphIteratorNode, and MergeAnswersNode. The SearchLinkNode receives the user

Chunk 2154
receives the user prompt and relevant chunks of parsed content as input, and it filters out the relevant links based on the user prompt. The filtered links can then be used for further processing or analysis in the workflow.

Chunk 2155
Note: It is important to ensure that the necessary input keys are present in the state before executing the SearchLinkNode. The node_config dictionary should contain the llm_model instance for generating answers. The verbose flag can be used to

Chunk 2156
verbose flag can be used to control the verbosity of the execution.

Chunk 2157
Output Example:
{
"relevant_links": [
"https://example.com/link1",
"https://example.com/link2",
"https://example.com/link3"
]
}  
FunctionDef init(self, input, output, node_config, node_name)

Chunk 2158
init: The function of init is to initialize the SearchLinkNode object with input, output, node configuration, and node name.  
parameters:
- input: A string representing the input for the node.

Chunk 2159
- output: A list of strings representing the output for the node.
- node_config: An optional dictionary containing node configuration settings.
- node_name: A string representing the name of the node, default value is "GenerateLinks".

Chunk 2160
Code Description:

Chunk 2161
In this function, the SearchLinkNode object is initialized by calling the superclass's constructor with the provided parameters. It then assigns the "llm_model" value from the node_config dictionary to the self.llm_model attribute. Additionally, it

Chunk 2162
attribute. Additionally, it sets the self.verbose attribute to False if the "verbose" key is not present in the node_config dictionary, otherwise, it takes the value from the "verbose" key.

Chunk 2163
Note:
- Ensure that the "llm_model" key is present in the node_config dictionary to avoid errors when initializing the SearchLinkNode object.

Chunk 2164
- If the "verbose" key is not provided in the node_config dictionary, the self.verbose attribute will default to False.  
FunctionDef execute(self, state)

Chunk 2165
execute: The function of execute is to filter out relevant links from a webpage based on a user prompt, ensuring navigability, and updating the state with the list of relevant links.  
parameters:

Chunk 2166
parameters:
- state (dict): The current state of the graph. The input keys will be used to fetch the correct data types from the state.  
Code Description:

Chunk 2167
The execute function begins by logging the execution of the node. It then interprets input keys using the get_input_keys function to extract user prompt and parsed content chunks from the state. The function defines a prompt template for identifying

Chunk 2168
template for identifying relevant links and iterates through parsed content chunks to generate relevant links using a merge chain of operations. The relevant links are then added to the state under the output key, updating the state with the list of

Chunk 2169
the state with the list of relevant links.

Chunk 2170
The execute function utilizes the get_input_keys function from the BaseNode to determine the necessary input keys for extracting data from the state. It also interacts with the llm_model and JsonOutputParser objects to process and parse the content

Chunk 2171
process and parse the content chunks and generate relevant links.

Chunk 2172
Note:

Chunk 2173
Developers should ensure that the input keys provided in the state match the expected format to avoid KeyError exceptions. Additionally, the function relies on external objects such as llm_model and JsonOutputParser for processing content and

Chunk 2174
for processing content and generating output.

Chunk 2175
Output Example:
{'output': ['link1', 'link2', 'link3', ...]}

Chunk 2176
ClassDef SearchLinksWithContext

Chunk 2177
SearchLinksWithContext: The function of SearchLinksWithContext is to generate a search query based on the user's input and search the internet for relevant information. It constructs a prompt for the language model, submits it, and processes the

Chunk 2178
submits it, and processes the output to generate a search query. It then uses the search query to find relevant information on the internet and updates the state with the generated answer.

Chunk 2179
Attributes:
- llm_model: An instance of the language model client used for generating search queries.
- verbose (bool): A flag indicating whether to show print statements during execution.  
Code Description:

Chunk 2180
The SearchLinksWithContext class is a subclass of the BaseNode class. It represents a node in a graph-based workflow that performs the task of generating search queries and searching the internet for relevant information. The class has an init

Chunk 2181
The class has an init method that initializes the attributes of the node, such as the input, output, node_config, and node_name. It also calls the init method of the BaseNode class to initialize the inherited attributes.

Chunk 2182
The class has an execute method that takes the current state of the graph as input and returns the updated state after executing the node's logic. The execute method first logs the start of the execution. It then interprets the input keys based on

Chunk 2183
the input keys based on the provided input expression and fetches the corresponding data from the state. The input data consists of the user's prompt and the scraped content.

Chunk 2184
The execute method uses a prompt template to construct a prompt for the language model. The template includes the user's question, the content of the current chunk (if there are multiple chunks), and the output instructions. The prompt template is

Chunk 2185
The prompt template is instantiated with the necessary input variables and partial variables. The execute method then iterates over the chunks of the scraped content and generates a prompt for each chunk. It submits the prompt to the language model

Chunk 2186
prompt to the language model and processes the output using an output parser. The generated URLs are stored in the result list.

Chunk 2187
Finally, the execute method updates the state with the generated URLs and returns the updated state.  
Note:
- The SearchLinksWithContext class extends the BaseNode class, which is an abstract base class for nodes in a graph-based workflow.

Chunk 2188
- The execute method uses a prompt template to construct a prompt for the language model and an output parser to process the model's response.
- The execute method updates the state with the generated URLs.  
Output Example:
{
"urls": [

Chunk 2189
Output Example:
{
"urls": [
"https://example.com/link1",
"https://example.com/link2",
"https://example.com/link3"
]
}  
FunctionDef init(self, input, output, node_config, node_name)

Chunk 2190
init: The function of init is to initialize the SearchLinksWithContext object with the provided input, output, node configuration, and node name.  
parameters:
- input: A string representing the input for the node.

Chunk 2191
- output: A list of strings representing the output of the node.
- node_config: An optional dictionary containing node configuration parameters. Defaults to None.

Chunk 2192
- node_name: A string representing the name of the node. Defaults to "GenerateAnswer".  
Code Description:

Chunk 2193
The init function initializes the SearchLinksWithContext object by calling the parent class's constructor with the node name, type, input, output, priority, and node configuration. It then assigns the "llm_model" value from the node configuration to

Chunk 2194
the node configuration to the "llm_model" attribute of the object. Additionally, it sets the "verbose" attribute based on the "verbose" key in the node configuration, defaulting to False if not provided.

Chunk 2195
Note:
- Ensure that the necessary input, output, and node configuration parameters are provided when initializing the SearchLinksWithContext object.

Chunk 2196
- The "llm_model" attribute must be present in the node configuration dictionary to avoid any errors during initialization.  
FunctionDef execute(self, state)

Chunk 2197
execute: The function of execute is to generate an answer by constructing a prompt from the user's input and the scraped content, querying the language model, and parsing its response.
parameters:

Chunk 2198
parameters:
- state (dict): The current state of the graph. The input keys will be used to fetch the correct data from the state.  
Code Description:

Chunk 2199
The execute function starts by logging the execution of the current node. It then calls the get_input_keys function to determine the necessary input keys based on the input specification. The function proceeds to fetch data from the state based on

Chunk 2200
data from the state based on the input keys and constructs prompts for processing. Depending on the number of chunks in the input data, different prompt templates are used to guide the language model in generating answers. The prompts are fed into

Chunk 2201
The prompts are fed into the language model, and the output is parsed using an output parser. The generated URLs are stored in the state under the key "urls" before being returned.

Chunk 2202
The execute function relies on the get_input_keys method from the BaseNode class to determine the required input keys for processing. It also interacts with the CommaSeparatedListOutputParser class, PromptTemplate class, and the language model to

Chunk 2203
and the language model to generate and parse responses effectively.

Chunk 2204
Note:

Chunk 2205
Developers using the execute function should ensure that the state provided contains the necessary input keys for processing. Additionally, they should be familiar with the structure of the input data to handle single or multiple chunks

Chunk 2206
single or multiple chunks appropriately.

Chunk 2207
Output Example:
{'urls': ['url1', 'url2', 'url3']}

Chunk 2208
ClassDef TextToSpeechNode  
TextToSpeechNode: The TextToSpeechNode class is responsible for converting text to speech using a specified text-to-speech model.  
Attributes:
- tts_model: An instance of the text-to-speech model client.

Chunk 2209
- verbose (bool): A flag indicating whether to show print statements during execution.  
Code Description:

Chunk 2210
The TextToSpeechNode class inherits from the BaseNode class and overrides its execute method. When executed, the node converts text to speech using the specified text-to-speech model. The input keys are fetched from the state based on the input

Chunk 2211
the state based on the input expression, and the necessary information for generating the audio is extracted. The text to be translated is obtained from the input data, and the text-to-speech model is used to generate the audio. The updated state is

Chunk 2212
audio. The updated state is then returned with the output key containing the audio.

Chunk 2213
Note:
- The TextToSpeechNode class requires the input keys to be present in the state. If any of the input keys are not found in the state, a KeyError is raised.
- The TextToSpeechNode class logs the execution of the node using the logger.

Chunk 2214
Output Example:
{
"output_key": "audio"
}  
FunctionDef init(self, input, output, node_config, node_name)  
init: The function of init is to initialize the TextToSpeechNode object with the provided input, output, node configuration, and node name.

Chunk 2215
parameters:
- self: The instance of the class.
- input: A string representing the input data for the node.
- output: A list of strings representing the output data from the node.

Chunk 2216
- node_config: An optional dictionary containing configuration settings for the node.
- node_name: A string representing the name of the node.  
Code Description:

Chunk 2217
In the init function of the TextToSpeechNode class, the function initializes the object by calling the superclass's constructor with the provided node_name, input, output, 1 (indicating the node type), and node_config. It then assigns the value of

Chunk 2218
It then assigns the value of the "tts_model" key from the node_config dictionary to the self.tts_model attribute. Additionally, it sets the self.verbose attribute to False if the "verbose" key is not present in the node_config dictionary, otherwise,

Chunk 2219
dictionary, otherwise, it takes the value of the "verbose" key.

Chunk 2220
Note:
- Ensure that the "tts_model" key is present in the node_config dictionary to avoid any KeyError when initializing the TextToSpeechNode object.

Chunk 2221
- If the "verbose" key is not provided in the node_config dictionary, the self.verbose attribute will default to False.  
FunctionDef execute(self, state)

Chunk 2222
execute: The function of execute is to convert text to speech using the specified text-to-speech model.  
parameters:
- state (dict): The current state of the graph. The input keys will be used to fetch the correct data types from the state.

Chunk 2223
Code Description:

Chunk 2224
The execute function first logs the execution of the node. It then calls the get_input_keys function from the BaseNode to determine the necessary input keys based on the input specification. After fetching the required data from the state, it

Chunk 2225
data from the state, it extracts the text to translate and generates audio using the text-to-speech model. Finally, it updates the state with the audio output and returns the updated state.

Chunk 2226
The execute function is crucial for the TextToSpeechNode as it handles the conversion of text to speech based on the provided input text. It relies on the get_input_keys function to fetch the required input keys from the state, ensuring the

Chunk 2227
from the state, ensuring the availability of necessary information for audio generation.

Chunk 2228
Note:
Developers using the execute function should ensure that the input keys provided in the state contain the required text for speech generation. Any missing input keys will result in a KeyError being raised.  
Output Example:

Chunk 2229
Output Example:
{'output_key': 'audio_file'}

Chunk 2230
FunctionDef _load_config(config_location)

Chunk 2231
_load_config: The function of _load_config is to load a configuration file, set default values if necessary, generate an anonymous ID if not present, and write the configuration back to the file if needed.  
parameters:

Chunk 2232
parameters:
- config_location: A string representing the location of the configuration file.  
Code Description:

Chunk 2233
The _load_config function first creates a ConfigParser object to handle the configuration. It then attempts to open the specified configuration file. If successful, it reads the file into the config object. If an exception occurs during the file

Chunk 2234
occurs during the file reading process, a default "DEFAULT" section is created in the config object.

Chunk 2235
Next, the function checks if the "DEFAULT" section exists in the config. If not, it creates one.

Chunk 2236
Subsequently, the function checks if the "anonymous_id" key is present in the "DEFAULT" section of the config. If not, it generates a new UUID (Universally Unique Identifier) as the value for "anonymous_id".

Chunk 2237
If the "anonymous_id" was generated or was missing, the function attempts to write the updated configuration back to the file.  
Finally, the function returns the ConfigParser object containing the loaded or updated configuration.  
Note:

Chunk 2238
Note:
- This function handles the loading, updating, and writing of configuration files, ensuring the presence of a default section and an anonymous ID if needed.

Chunk 2239
- It is important to handle exceptions properly when working with file operations to prevent unexpected errors.  
Output Example:
A ConfigParser object containing the loaded or updated configuration settings.

Chunk 2240
FunctionDef _check_config_and_environ_for_telemetry_flag(telemetry_default, config_obj)

Chunk 2241
_check_config_and_environ_for_telemetry_flag: The function of _check_config_and_environ_for_telemetry_flag is to determine the telemetry flag status by checking the configuration object and environment variables.  
parameters:

Chunk 2242
parameters:
- telemetry_default: A boolean representing the default telemetry status.
- config_obj: An instance of configparser.ConfigParser containing configuration settings.  
Code Description:

Chunk 2243
The function first sets the telemetry_enabled variable to the default telemetry status. It then checks if the "telemetry_enabled" key exists in the DEFAULT section of the config_obj. If found, it attempts to parse the value as a boolean and updates

Chunk 2244
as a boolean and updates the telemetry_enabled variable accordingly. If the "SCRAPEGRAPHAI_TELEMETRY_ENABLED" environment variable is set, the function updates the "telemetry_enabled" key in the DEFAULT section of config_obj with the environment

Chunk 2245
with the environment variable value. It then tries to parse this updated value as a boolean and updates the telemetry_enabled variable. Finally, the function returns the telemetry_enabled status.

Chunk 2246
Note:
- This function helps in dynamically setting the telemetry flag based on configuration and environment variables.
- It handles cases where the telemetry flag is specified in the configuration file or as an environment variable.

Chunk 2247
Output Example:
True  
FunctionDef disable_telemetry  
disable_telemetry: The function of disable_telemetry is to set the global variable g_telemetry_enabled to False.
parameters: This Function does not take any parameters.

Chunk 2248
Code Description: This function, disable_telemetry, is responsible for disabling telemetry by setting the global variable g_telemetry_enabled to False. This means that telemetry functionality will be turned off when this function is called. It is a

Chunk 2249
function is called. It is a simple function that does not require any input parameters.

Chunk 2250
In the project, this function is called to disable telemetry functionality, ensuring that telemetry data is not collected or transmitted. This can be useful in scenarios where telemetry is not needed or should be turned off for any reason.

Chunk 2251
Note: Developers can call this function to disable telemetry in the project.  
FunctionDef is_telemetry_enabled

Chunk 2252
is_telemetry_enabled: The function of is_telemetry_enabled is to check if telemetry is enabled and return a boolean value accordingly.  
parameters:
- No parameters are passed to this function.  
Code Description:

Chunk 2253
The is_telemetry_enabled function checks the global variable g_telemetry_enabled to determine if telemetry is enabled. If telemetry is enabled, it increments the call_counter and checks if the call_counter exceeds the MAX_COUNT_SESSION. If the

Chunk 2254
the MAX_COUNT_SESSION. If the call_counter is within the limit, the function returns True, indicating that telemetry is enabled. Otherwise, it returns False. If telemetry is not enabled, the function directly returns False.

Chunk 2255
This function is utilized in the log_event function to determine whether telemetry should be sent when logging an event. It is also used in the wrapped_fn function to log function usage if telemetry is enabled.  
Note:

Chunk 2256
Note:
- Ensure that the global variable g_telemetry_enabled is properly set based on the desired telemetry configuration.
- Make sure to handle the telemetry data responsibly and in compliance with privacy regulations.  
Output Example:
True

Chunk 2257
Output Example:
True  
FunctionDef _send_event_json(event_json)  
_send_event_json: The function of _send_event_json is to send telemetry event data in JSON format to a specified URL with necessary headers.  
parameters:

Chunk 2258
parameters:
- event_json: A dictionary containing the telemetry event data to be sent.  
Code Description:

Chunk 2259
The _send_event_json function first creates headers with necessary information such as content type, authorization using an API key, and user-agent information. It then attempts to convert the event_json dictionary into a JSON string and encodes it.

Chunk 2260
a JSON string and encodes it. A request object is created with the specified URL, data, and headers. The function then opens the request URL with a timeout limit, reads the response, and checks if the response code is not 200, in which case it

Chunk 2261
is not 200, in which case it raises a RuntimeError with the response content. If an exception occurs during the process, it logs a debug message indicating the failure to send telemetry data. Otherwise, it logs a debug message confirming the

Chunk 2262
debug message confirming the successful sending of telemetry data along with the data that was sent.

Chunk 2263
In the project, this function is called by the send_event_json function in the same module when telemetry tracking is enabled. The send_event_json function creates a new thread to execute _send_event_json with the provided event_json data. If an

Chunk 2264
event_json data. If an exception occurs during the thread creation or execution, a debug message is logged indicating the failure to send telemetry data in a thread.

Chunk 2265
Note:
- Ensure that the API_KEY, STR_VERSION, TRACK_URL, and TIMEOUT variables are properly defined and accessible within the scope of the _send_event_json function for successful execution.

Chunk 2266
- Handle any potential exceptions that may occur during the execution of this function to prevent unexpected behavior in the telemetry tracking process.  
FunctionDef send_event_json(event_json)

Chunk 2267
send_event_json: The function of send_event_json is to send telemetry event data in JSON format to a specified URL with necessary headers.
parameters:
- event_json: A dictionary containing the telemetry event data to be sent.
Code Description:

Chunk 2268
The send_event_json function checks if telemetry tracking is enabled. If enabled, it creates a new thread to execute the _send_event_json function with the provided event_json data. If any exceptions occur during the thread creation or execution, a

Chunk 2269
creation or execution, a debug message is logged to indicate the failure to send telemetry data in a thread.

Chunk 2270
This function is called by the log_event function in the same module when telemetry tracking is enabled. The log_event function prepares the event data in JSON format and calls send_event_json to send the telemetry data.
Note:

Chunk 2271
Note:
- Ensure that the necessary variables like API_KEY, STR_VERSION, TRACK_URL, and TIMEOUT are correctly defined and accessible within the scope of the _send_event_json function for successful execution.

Chunk 2272
- Handle any potential exceptions that may arise during the execution of this function to maintain the integrity of the telemetry tracking process.  
FunctionDef log_event(event, properties)

Chunk 2273
log_event: The function of log_event is to log a specific event with associated properties if telemetry tracking is enabled.  
parameters:
- event: A string representing the event to be logged.

Chunk 2274
- properties: A dictionary containing additional properties related to the event.  
Code Description:

Chunk 2275
The log_event function first checks if telemetry tracking is enabled by calling the is_telemetry_enabled function. If telemetry is enabled, it constructs a JSON object containing the API key, the event name, and a combination of base properties and

Chunk 2276
of base properties and additional properties provided. This JSON object is then passed to the send_event_json function for further processing and sending.

Chunk 2277
This function is crucial for logging events with telemetry data, ensuring that relevant information is captured and sent for analysis when telemetry tracking is active.  
Note:

Chunk 2278
Note:
- Ensure that telemetry is properly configured and enabled to capture and send event data.
- Handle any exceptions that may arise during the event logging process to maintain the integrity of telemetry tracking.

Chunk 2279
FunctionDef log_graph_execution(graph_name, llm_model, embedder_model, source_type, execution_time, error_node, total_tokens)

Chunk 2280
log_graph_execution: The function of log_graph_execution is to log the execution of a graph with specific properties related to the graph, such as the graph name, models used, execution time, error node, and total tokens.  
parameters:

Chunk 2281
parameters:
- graph_name: A string representing the name of the graph being executed.
- llm_model: A string indicating the language model used in the graph execution.

Chunk 2282
- embedder_model: A string specifying the embedder model utilized in the graph execution.
- source_type: A string denoting the type of data source for the graph execution.

Chunk 2283
- execution_time: A float value representing the time taken for the graph execution.
- error_node: An optional string indicating the node where an error occurred during execution.

Chunk 2284
- total_tokens: An optional integer representing the total tokens used during the graph execution.  
Code Description:

Chunk 2285
The log_graph_execution function creates a dictionary of properties based on the input parameters provided. These properties include the graph name, language model, embedder model, source type, execution time, error node (if any), and total tokens

Chunk 2286
(if any), and total tokens (if available). Subsequently, the function calls the log_event function from the telemetry module to log the 'graph_execution' event along with the constructed properties.

Chunk 2287
Within the context of the project, log_graph_execution is called during the execution of a graph in the BaseGraph class. When an error occurs during node execution, log_graph_execution is invoked to log the details of the graph execution, including

Chunk 2288
graph execution, including the error node, execution time, and other relevant information. This function ensures that essential data regarding graph execution is captured for telemetry tracking and analysis.

Chunk 2289
Note:
- Ensure that the necessary parameters are provided accurately to log relevant information about the graph execution.

Chunk 2290
- Handle any exceptions that may arise during the graph execution logging process to maintain the integrity of telemetry tracking and error reporting.  
FunctionDef capture_function_usage(call_fn)

Chunk 2291
capture_function_usage: The function of capture_function_usage is to capture the usage of a given function for telemetry purposes.  
parameters:
- call_fn: A Callable type parameter representing the function to be monitored for usage.

Chunk 2292
Code Description:

Chunk 2293
The capture_function_usage function takes a function as input and returns a wrapped function. The wrapped function executes the original function and then logs an event for telemetry purposes if telemetry is enabled. It captures the name of the

Chunk 2294
It captures the name of the function being called and sends it as part of the telemetry event.

Chunk 2295
Note:
- This function relies on the is_telemetry_enabled() function to determine if telemetry is enabled.
- Any exceptions that occur during the telemetry event logging process are caught and logged using the logger.debug method.  
Output Example:

Chunk 2296
Output Example:
A wrapped function that executes the original function and logs telemetry data if telemetry is enabled.  
FunctionDef wrapped_fn

Chunk 2297
FunctionDef wrapped_fn  
wrapped_fn: The function of wrapped_fn is to call a specified function and log its usage if telemetry tracking is enabled.  
parameters:
- args: Represents the positional arguments passed to the function.

Chunk 2298
- *kwargs: Indicates the keyword arguments passed to the function.  
Code Description:

Chunk 2299
The wrapped_fn function attempts to execute the call_fn function with the provided arguments and keyword arguments. Upon completion, it checks if telemetry tracking is enabled by calling the is_telemetry_enabled function. If telemetry is enabled, it

Chunk 2300
If telemetry is enabled, it retrieves the name of the called function and logs an event with the function name under the "function_usage" category. Any encountered exceptions during the telemetry logging process are captured and logged for debugging

Chunk 2301
and logged for debugging purposes.

Chunk 2302
This function plays a crucial role in capturing and logging function usage data when telemetry is active, providing insights into the usage patterns of specific functions within the application.  
Note:

Chunk 2303
Note:
- Ensure that telemetry is properly configured and enabled to capture function usage data accurately.
- Handle any exceptions that may occur during the telemetry logging process to maintain the integrity of the telemetry data.

Chunk 2304
- Utilize the telemetry data responsibly and in compliance with relevant privacy regulations.  
Output Example:
No specific output example provided as it depends on the function being called and the telemetry configuration.

Chunk 2305
FunctionDef cleanup_html(html_content, base_url)  
cleanup_html: The function of cleanup_html is to process HTML content by removing unnecessary tags, minifying the HTML, and extracting the title and body content.  
parameters:

Chunk 2306
parameters:
- html_content (str): The HTML content to be processed.
- base_url (str): The base URL used for joining relative URLs found in the HTML content.  
Code Description:

Chunk 2307
The cleanup_html function takes HTML content and a base URL as input. It then extracts the title, removes unnecessary tags like scripts and styles, extracts links and images, and minifies the body content. If no body content is found, it raises a

Chunk 2308
content is found, it raises a ValueError. The function is designed to prepare HTML content for environments where bandwidth usage needs to be minimized.

Chunk 2309
In the calling object FetchNode, the cleanup_html function is used to process HTML content fetched from different sources such as local files or web URLs. The extracted title, minified body content, links, and images are then stored in a compressed

Chunk 2310
then stored in a compressed document for further processing within the node.

Chunk 2311
Note:
- Ensure that the headless flag is appropriately set in the graph configuration to handle cases where no HTML body content is found.
- The function relies on the BeautifulSoup library for HTML parsing and processing.  
Output Example:

Chunk 2312
Output Example:
'Title: Example, Body:  
Hello World!, Links: ['http://example.com'], Images: ['http://example.com/image.jpg']'

Chunk 2313
FunctionDef convert_to_csv(data, filename, position)  
convert_to_csv: The function of convert_to_csv is to convert a dictionary into a CSV file and save it at a specified location.  
parameters:

Chunk 2314
parameters:
- data (dict): The data to be converted into CSV format.
- filename (str): The name of the output CSV file, without the '.csv' extension.

Chunk 2315
- position (str, optional): The file path where the CSV should be saved. Defaults to the directory of the caller script if not provided.  
Code Description:

Chunk 2316
The convert_to_csv function takes a dictionary data, a filename for the output CSV file, and an optional position parameter to specify the file path for saving the CSV file. If the filename contains ".csv", the function removes the extension. If the

Chunk 2317
removes the extension. If the position is not provided, it defaults to the directory of the caller script. The function then converts the dictionary into a DataFrame, saves it as a CSV file at the specified location, and handles potential errors

Chunk 2318
and handles potential errors like FileNotFoundError, PermissionError, TypeError, and other exceptions.

Chunk 2319
This function is designed to be used in scenarios where there is a need to convert dictionary data into a CSV file for storage or further processing. It provides flexibility by allowing the user to specify the output file name and location, while

Chunk 2320
file name and location, while also handling common file-related errors that may occur during the process.

Chunk 2321
Note:
- Ensure that the data parameter is a dictionary, as the function raises a TypeError if it is not.

Chunk 2322
- Make sure to handle the potential exceptions raised by the function, such as FileNotFoundError and PermissionError, to ensure robust error handling in your code.  
Output Example:

Chunk 2323
Output Example:
No output is returned by the function, as it directly saves the converted data into a CSV file at the specified location.

Chunk 2324
FunctionDef convert_to_json(data, filename, position)  
convert_to_json: The function of convert_to_json is to convert a dictionary to a JSON file and save it at a specified location.  
parameters:

Chunk 2325
parameters:
- data (dict): The data to be converted into JSON format.
- filename (str): The name of the output JSON file, without the '.json' extension.

Chunk 2326
- position (str, optional): The file path where the JSON file should be saved. Defaults to the directory of the caller script if not provided.  
Code Description:

Chunk 2327
The convert_to_json function takes a dictionary data, a filename filename, and an optional position position. It converts the dictionary into a JSON file and saves it at the specified location. If the position is not provided, it saves the file in

Chunk 2328
it saves the file in the directory of the caller script. The function ensures the directory exists before writing the file and attempts to create it if it doesn't. It raises errors for invalid filename extensions, non-existing directories, and lack

Chunk 2329
directories, and lack of write permissions.

Chunk 2330
Note:
This function is designed to handle the conversion of dictionary data to JSON format and provides flexibility in specifying the output file location. It includes error handling for common issues related to file writing operations.

Chunk 2331
Output Example:
None

Chunk 2332
FunctionDef _get_library_root_logger  
_get_library_root_logger: The function of _get_library_root_logger is to retrieve the root logger for the library.  
Parameters:
- None  
Code Description:

Chunk 2333
The _get_library_root_logger function returns the root logger for the library by using the getLogger method from the logging module. This function is called by various other functions within the logging module of the project, such as

Chunk 2334
of the project, such as _set_library_root_logger, get_verbosity, set_verbosity, set_handler, unset_handler, set_propagation, unset_propagation, set_formatting, and unset_formatting. When called, it ensures that the root logger is obtained for

Chunk 2335
root logger is obtained for further logging operations in the project.

Chunk 2336
Note:
- This function does not take any parameters and solely focuses on retrieving the root logger for the library.
- It is essential to call this function before performing any logging operations to ensure the logger is properly set up.

Chunk 2337
Output Example:
python
<Logger root (DEBUG)>  
FunctionDef _set_library_root_logger  
_set_library_root_logger: The function of _set_library_root_logger is to set up the root logger for the library.  
Parameters:
- None  
Code Description:

Chunk 2338
The _set_library_root_logger function initializes the root logger for the library by creating a default handler and configuring it with the appropriate settings. It ensures that the default handler is only set once by utilizing a semaphore to

Chunk 2339
by utilizing a semaphore to control access. The function also retrieves the library's root logger using the _get_library_root_logger function and adds the default handler to it. Additionally, it sets the logging level and disables propagation to

Chunk 2340
and disables propagation to parent loggers for the library root logger.

Chunk 2341
This function is crucial for establishing the foundational logging configuration for the library and should be called before any logging operations to guarantee proper setup.  
Note:

Chunk 2342
Note:
- This function does not accept any parameters and focuses on configuring the root logger for the library.
- It employs a semaphore to prevent multiple initializations of the default handler.

Chunk 2343
- The function relies on the _get_library_root_logger function to obtain the library's root logger.  
Output Example:
python
<Logger root (DEBUG)>  
FunctionDef get_logger(name)

Chunk 2344
get_logger: The function of get_logger is to retrieve a logger with the specified name or the default library name if no name is provided.  
Parameters:
- name: Optional[str] (default is None) - The name of the logger to retrieve.

Chunk 2345
Code Description:

Chunk 2346
The get_logger function is responsible for obtaining a logger based on the provided name. If no name is specified, it returns a logger with the default library name. The function first calls the _set_library_root_logger function to set up the root

Chunk 2347
function to set up the root logger for the library. It then retrieves the logger using the getLogger method from the logging module, passing the provided name or the default library name if no name is given. Finally, it returns the logger for

Chunk 2348
it returns the logger for further logging operations.

Chunk 2349
This function plays a crucial role in initializing and obtaining loggers within the library, ensuring proper logging functionality throughout the codebase.  
Note:

Chunk 2350
Note:
- If no name is provided, the function retrieves a logger with the default library name.
- It relies on the _set_library_root_logger function to set up the root logger for the library.  
Output Example:
python
<Logger root (DEBUG)>

Chunk 2351
<Logger root (DEBUG)>  
FunctionDef get_verbosity  
get_verbosity: The function of get_verbosity is to set the verbosity level for logging operations by retrieving the effective level of the library's root logger.  
Parameters:
- None

Chunk 2352
Parameters:
- None  
Code Description:

Chunk 2353
The get_verbosity function first calls the _set_library_root_logger function to ensure the root logger is properly set up for the library. It then retrieves the effective logging level by calling the _get_library_root_logger function and accessing

Chunk 2354
function and accessing the getEffectiveLevel method. This function plays a crucial role in determining the verbosity level for logging activities within the project.

Chunk 2355
Note:
- This function does not require any input parameters and focuses on obtaining the verbosity level for logging.
- It is essential to call _set_library_root_logger before invoking get_verbosity to establish the necessary logging configuration.

Chunk 2356
- The function relies on _get_library_root_logger to access the root logger and retrieve the effective logging level.  
Output Example:
python
20  
FunctionDef set_verbosity(verbosity)

Chunk 2357
set_verbosity: The function of set_verbosity is to set the logging level for the library's root logger to the specified verbosity level.  
Parameters:
- verbosity: An integer representing the logging level to be set.  
Code Description:

Chunk 2358
The set_verbosity function first calls the _set_library_root_logger function to initialize the root logger for the library. It then retrieves the library's root logger using the _get_library_root_logger function and sets its logging level to the

Chunk 2359
sets its logging level to the specified verbosity level provided as the input parameter. By setting the verbosity level, developers can control the amount of logging output generated by the library.

Chunk 2360
This function is essential for managing the verbosity of logging messages within the library and should be used to adjust the level of detail in the log output based on the desired debugging or informational needs.  
Note:

Chunk 2361
Note:
- Ensure to call this function with the appropriate verbosity level to control the amount of logging information generated.

Chunk 2362
- It is recommended to set the verbosity level before performing any logging operations to establish the desired logging configuration.  
FunctionDef set_verbosity_debug

Chunk 2363
set_verbosity_debug: The function of set_verbosity_debug is to set the logging level to DEBUG for the library's root logger.  
Parameters:
- None  
Code Description:

Chunk 2364
The set_verbosity_debug function is a wrapper function that internally calls the set_verbosity function from the logging module with the logging level set to DEBUG. By invoking this function, developers can easily configure the library's logging

Chunk 2365
the library's logging system to output debug-level messages. This function simplifies the process of setting the verbosity level to DEBUG for debugging purposes.

Chunk 2366
Note:
- Ensure to call this function when debugging or troubleshooting to enable detailed logging information at the DEBUG level.  
FunctionDef set_verbosity_info

Chunk 2367
set_verbosity_info: The function of set_verbosity_info is to set the logging level to INFO for the library's root logger.  
Parameters:
- None  
Code Description:

Chunk 2368
The set_verbosity_info function sets the logging level of the library's root logger to INFO. By calling this function, developers can ensure that the logging output includes informational messages for debugging and monitoring purposes. This function

Chunk 2369
purposes. This function is typically used to adjust the verbosity of logging messages within the library.

Chunk 2370
When the set_verbosity_info function is called, it internally invokes the set_verbosity function to set the logging level to INFO. This ensures that the library generates log messages at the INFO level, providing detailed information about the

Chunk 2371
information about the library's operations.

Chunk 2372
In the project's hierarchy, the set_verbosity_info function is called within the initialization of an AbstractGraph object. Specifically, it is used to configure the logging verbosity based on the 'verbose' parameter provided in the configuration.

Chunk 2373
in the configuration. If the 'verbose' parameter is set to True, set_verbosity_info is called to enable detailed logging information. Conversely, if 'verbose' is False, set_verbosity_warning is invoked to set the logging level to WARNING.

Chunk 2374
Note:
- Ensure to call set_verbosity_info when detailed logging information is required.
- The function is primarily used to adjust the verbosity level of logging messages within the library.  
FunctionDef set_verbosity_warning

Chunk 2375
set_verbosity_warning: The function of set_verbosity_warning is to set the logging level to WARNING for the library's root logger.  
Parameters:
- None  
Code Description:

Chunk 2376
Code Description:
The set_verbosity_warning function sets the logging level of the library's root logger to the WARNING level. By calling this function, developers can ensure that warning messages are appropriately handled in the logging output.

Chunk 2377
This function is called within the initialization process of an AbstractGraph object in the project. Depending on the verbosity configuration provided in the object's settings, either set_verbosity_info or set_verbosity_warning is invoked to control

Chunk 2378
is invoked to control the amount of logging information generated during the execution of the graph-related operations.

Chunk 2379
Note:
- It is crucial to set the appropriate verbosity level based on the desired amount of logging information needed.

Chunk 2380
- Developers should ensure that the logging configuration aligns with the debugging and informational requirements of the project.  
FunctionDef set_verbosity_error

Chunk 2381
set_verbosity_error: The function of set_verbosity_error is to set the logging level to error (logging.ERROR).  
Parameters:
- This function does not take any parameters.  
Code Description:

Chunk 2382
The set_verbosity_error function is responsible for setting the logging level to error (logging.ERROR). It achieves this by calling the set_verbosity function with the logging level set to logging.ERROR. By setting the logging level to error,

Chunk 2383
the logging level to error, developers can ensure that only error-level log messages are displayed, helping to focus on critical issues during debugging or monitoring processes.

Chunk 2384
Note:
- This function does not require any input parameters as it specifically sets the logging level to error.
- It is recommended to use set_verbosity_error when the focus is on capturing and handling error-level log messages.

Chunk 2385
FunctionDef set_verbosity_fatal  
set_verbosity_fatal: The function of set_verbosity_fatal is to set the logging level to FATAL, indicating the highest severity level for logging messages.  
Parameters:

Chunk 2386
Parameters:
- This function does not take any parameters.  
Code Description:

Chunk 2387
The set_verbosity_fatal function is a wrapper function that calls the set_verbosity function from the logging module with the logging level set to FATAL. By setting the logging level to FATAL, only messages of the highest severity will be logged.

Chunk 2388
severity will be logged. This function helps in controlling the verbosity of logging messages and is useful for scenarios where only critical errors need to be captured in the log output.

Chunk 2389
Note:
- Ensure to call set_verbosity_fatal when only fatal errors need to be logged.
- Setting the logging level to FATAL can help in focusing on critical issues and ignoring less severe log messages.  
FunctionDef set_handler(handler)

Chunk 2390
set_handler: The function of set_handler is to set a logging handler for the library's root logger.  
Parameters:
- handler: A logging handler to be added to the root logger.  
Code Description:

Chunk 2391
The set_handler function first ensures the library's root logger is set up by calling the _set_library_root_logger function. It then adds the provided handler to the root logger for logging operations. An assertion checks that the handler is not

Chunk 2392
that the handler is not None before adding it to the logger.

Chunk 2393
This function plays a crucial role in configuring the logging behavior for the library by allowing developers to set custom handlers for logging output. By adding a handler to the root logger, all log messages will pass through this handler for

Chunk 2394
pass through this handler for processing.

Chunk 2395
Note:
- It is essential to provide a valid logging handler as a parameter to set_handler.
- The function relies on the _set_library_root_logger function to initialize the root logger before adding the handler.

Chunk 2396
- After calling set_handler, the specified handler will be responsible for processing log messages in the library.  
FunctionDef set_default_handler

Chunk 2397
set_default_handler: The function of set_default_handler is to set a default logging handler for the library's root logger.  
Parameters:
- None  
Code Description:

Chunk 2398
The set_default_handler function calls the set_handler function with the default handler (_default_handler) as a parameter. This ensures that the library's root logger is configured with a default logging handler for processing log messages.

Chunk 2399
By invoking set_default_handler, developers can easily set up the default logging behavior for the library without the need to manually specify a handler each time. This function simplifies the process of initializing logging settings by providing a

Chunk 2400
settings by providing a predefined default handler.

Chunk 2401
Note:
- This function relies on the set_handler function to set the default logging handler for the library's root logger.

Chunk 2402
- Developers can customize the default logging behavior by modifying the _default_handler before calling set_default_handler.  
FunctionDef unset_handler(handler)

Chunk 2403
unset_handler: The function of unset_handler is to remove a specified handler from the library's root logger.  
Parameters:
- handler: A logging handler that needs to be removed from the root logger.  
Code Description:

Chunk 2404
The unset_handler function first ensures the library's root logger is set up by calling the _set_library_root_logger function. It then asserts that the provided handler is not None. Finally, it removes the specified handler from the library's root

Chunk 2405
from the library's root logger using the removeHandler method.

Chunk 2406
This function plays a crucial role in managing the handlers attached to the root logger, allowing for dynamic configuration of logging behavior within the library.  
Note:

Chunk 2407
Note:
- It is essential to provide a valid handler as a parameter to remove it successfully from the root logger.

Chunk 2408
- The function relies on the _set_library_root_logger function to guarantee the root logger is properly initialized before handler removal.  
FunctionDef unset_default_handler

Chunk 2409
unset_default_handler: The function of unset_default_handler is to remove the default handler from the library's root logger.  
Parameters:
- None  
Code Description:

Chunk 2410
- None  
Code Description:
The unset_default_handler function calls the unset_handler function with the default handler (_default_handler) as a parameter. This ensures that the default handler is removed from the root logger of the library.

Chunk 2411
By invoking unset_handler with the default handler, this function facilitates the management of logging behavior within the library by allowing the removal of the default handler when necessary.  
Note:

Chunk 2412
Note:
- This function does not require any parameters to be passed explicitly, as it internally handles the removal of the default handler.  
FunctionDef set_propagation

Chunk 2413
FunctionDef set_propagation  
set_propagation: The function of set_propagation is to enable the propagation of log messages to parent loggers.  
Parameters:
- None  
Code Description:

Chunk 2414
The set_propagation function sets the propagate attribute of the root logger for the library to True. This allows log messages to be passed up to ancestor loggers if propagation is enabled for those loggers. This function is crucial for ensuring

Chunk 2415
is crucial for ensuring that log messages are appropriately propagated through the logging hierarchy within the project.

Chunk 2416
Note:
- This function does not require any parameters and focuses solely on enabling log message propagation.
- It is essential to call this function when configuring logging behavior to control how log messages are handled throughout the project.

Chunk 2417
FunctionDef unset_propagation  
unset_propagation: The function of unset_propagation is to stop the propagation of log messages to parent loggers.  
Parameters:
- None  
Code Description:

Chunk 2418
The unset_propagation function sets the propagate attribute of the root logger for the library to False. This action prevents log messages from being passed up to ancestor loggers. By calling this function, the propagation of log messages is halted

Chunk 2419
of log messages is halted at the root logger level, ensuring that log messages are not duplicated or sent to higher-level loggers.

Chunk 2420
Note:
- It is important to call unset_propagation when there is a need to isolate log messages at the root logger level and prevent them from being propagated to parent loggers.  
FunctionDef set_formatting

Chunk 2421
FunctionDef set_formatting  
set_formatting: The function of set_formatting is to set formatting for all handlers bound to the root logger.  
Parameters:
- None  
Code Description:

Chunk 2422
The set_formatting function creates a custom logging formatter that includes the log level, filename, line number, timestamp, and log message. It then iterates through all handlers attached to the root logger obtained from the

Chunk 2423
root logger obtained from the _get_library_root_logger function and sets the custom formatter for each handler.

Chunk 2424
This function is crucial for ensuring consistent and informative log messages across the project. By setting a specific format for log messages, developers can easily identify the origin of each log entry and the context in which it was generated.

Chunk 2425
Note:
- It is recommended to call this function early in the project initialization to establish the desired log message format for all logging operations.

Chunk 2426
- Any changes to the log message format should be done by modifying the formatter string within the set_formatting function.  
FunctionDef unset_formatting

Chunk 2427
unset_formatting: The function of unset_formatting is to remove the formatting set for the handlers of the library's root logger.  
Parameters:
- None  
Code Description:

Chunk 2428
The unset_formatting function iterates through the handlers of the library's root logger obtained using the _get_library_root_logger function. It then removes the formatting set for each handler by calling the setFormatter method with a value of

Chunk 2429
method with a value of None. This function plays a crucial role in resetting the formatting of the logger's handlers, ensuring that log messages are output without any specific formatting.

Chunk 2430
Note:
- This function does not require any parameters to be passed.
- It is essential to call this function when there is a need to remove formatting from the handlers of the root logger in the logging process.  
FunctionDef warning_once(self)

Chunk 2431
warning_once: The function of warning_once is to emit warning logs with the same message only once.
parameters:
- args: variable length argument list
- *kwargs: variable length keyword argument list

Chunk 2432
Code Description: The warning_once function is designed to emit warning logs with the same message only once. It achieves this by calling the warning function with the provided arguments and keyword arguments. This function is useful in scenarios

Chunk 2433
is useful in scenarios where you want to ensure that a specific warning message is logged only once, even if the warning condition is encountered multiple times.

Chunk 2434
Note: It is important to note that this function relies on the warning function to actually log the warning message. Make sure that the warning function is properly implemented and configured to handle the warning messages as intended.

Chunk 2435
FunctionDef parse_expression(expression, state)  
parse_expression: The function of parse_expression is to parse a complex boolean expression involving state keys and return a list of state keys that match the expression.  
parameters:

Chunk 2436
parameters:
- expression (str): The boolean expression to parse.
- state (dict): Dictionary of state keys used to evaluate the expression.  
Code Description:

Chunk 2437
The parse_expression function evaluates a boolean expression containing state keys based on provided boolean logic. It checks for syntax errors such as empty expressions, unbalanced parentheses, incorrect adjacency of operators, and invalid operator

Chunk 2438
and invalid operator usage. The function then returns a list of state keys that match the boolean expression, ensuring each key appears only once.

Chunk 2439
Note:
- The function raises a ValueError if the expression is empty, contains adjacent state keys without operators, has invalid operator usage, unbalanced parentheses, or if no state keys match the expression.

Chunk 2440
- The function handles complex boolean expressions with parentheses and multiple operators.
- It ensures that each state key appears only once in the final result.  
Output Example:
['user_input', 'relevant_chunks', 'parsed_document', 'document']

Chunk 2441
FunctionDef evaluate_simple_expression(exp)

Chunk 2442
evaluate_simple_expression: The function of evaluate_simple_expression is to process a simple expression by splitting it based on logical operators and checking if the elements are present in a given state.  
parameters:

Chunk 2443
parameters:
- exp: A string representing a simple expression to be evaluated.  
Code Description:

Chunk 2444
The evaluate_simple_expression function takes a simple expression as input and splits it by the OR operator. It then processes each segment by splitting it further by the AND operator. The function checks if all elements in an AND segment are

Chunk 2445
in an AND segment are present in the state. If they are, it returns the elements that match the state. If no match is found, an empty list is returned.

Chunk 2446
In the calling object evaluate_expression, the function is used to evaluate complex expressions by recursively processing sub-expressions enclosed in parentheses. The evaluate_simple_expression function is called to evaluate each sub-expression and

Chunk 2447
each sub-expression and replace it with the result, which is then joined with the OR operator for further processing.

Chunk 2448
Note:
- This function assumes that the state variable is defined and contains the necessary elements for evaluation.
- The function is designed to handle simple expressions with OR and AND operators.  
Output Example:

Chunk 2449
Output Example:
If the state is {'A', 'B', 'C'} and the input expression is 'A&B|C', the function would return ['A', 'B'] as both 'A' and 'B' are present in the state.  
FunctionDef evaluate_expression(expression)

Chunk 2450
evaluate_expression: The function of evaluate_expression is to process complex expressions by recursively evaluating sub-expressions enclosed in parentheses.  
parameters:
- expression: A string representing a complex expression to be evaluated.

Chunk 2451
Code Description:

Chunk 2452
The evaluate_expression function iterates through the input expression to identify and evaluate sub-expressions enclosed in parentheses. It replaces the evaluated sub-expressions with a placeholder and then calls the evaluate_simple_expression

Chunk 2453
evaluate_simple_expression function to process each sub-expression. The results are then joined with the OR operator for further processing. The function returns the final evaluation result of the complex expression.

Chunk 2454
In the context of the project structure, evaluate_expression relies on the evaluate_simple_expression function to handle simple expressions within the complex expression. By recursively calling evaluate_simple_expression, evaluate_expression

Chunk 2455
evaluate_expression effectively breaks down and evaluates complex logical expressions.

Chunk 2456
Note:
- This function assumes that the evaluate_simple_expression function is correctly implemented and handles simple expressions with OR and AND operators.

Chunk 2457
- It is important to ensure that the input expression is well-formed with balanced parentheses for proper evaluation.  
Output Example:

Chunk 2458
Output Example:
If the input expression is '((A&B)|C)', and the state contains {'A', 'B', 'C'}, the function would return ['A', 'B', 'C'] as all elements are present in the state for evaluation.

Chunk 2459
FunctionDef prettify_exec_info(complete_result)  
prettify_exec_info: The function of prettify_exec_info is to transform the execution information of a graph into a DataFrame for enhanced visualization.  
parameters:

Chunk 2460
parameters:
- complete_result (list[dict]): The complete execution information of the graph.  
Code Description:

Chunk 2461
The prettify_exec_info function takes a list of dictionaries containing the execution information of a graph as input. It then converts this information into a pandas DataFrame, organizing the data for better readability and analysis. The resulting

Chunk 2462
and analysis. The resulting DataFrame includes columns for 'node' and 'status', showing the execution results for each node in the graph.

Chunk 2463
This function is a useful tool for visualizing and analyzing the execution information of a graph, providing a structured format that simplifies the interpretation of the data.  
Relationship with Callers:

Chunk 2464
The prettify_exec_info function can be called by various scripts within the project to process and present the execution information of graphs in a more organized manner. For example, scripts related to CSV scraping, JSON scraping, and text scraping

Chunk 2465
scraping, and text scraping may utilize this function to enhance the visualization of graph execution details.

Chunk 2466
Note:
It is essential to ensure that the input to the prettify_exec_info function is in the expected format (list of dictionaries) to avoid any errors during the transformation process.  
Output Example:

Chunk 2467
Output Example:
A DataFrame with columns 'node' and 'status' showing the execution results for each node:
node   status
0   A     success
1   B     failure

Chunk 2468
ClassDef ProxyBrokerCriteria  
ProxyBrokerCriteria: The function of ProxyBrokerCriteria is to define the criteria for selecting proxy servers.  
attributes:
- anonymous: bool
- countryset: Set[str]
- secure: bool
- timeout: float

Chunk 2469
- timeout: float
- search_outside_if_empty: bool

Chunk 2470
This class is utilized in the Proxy class within the ProxySettings module to define the criteria for selecting proxy servers. By defining these criteria, the ProxyBrokerCriteria class allows for the customization of proxy server selection based on

Chunk 2471
server selection based on specific requirements such as anonymity, country location, security, timeout, and search behavior.

Chunk 2472
Note:
Developers can utilize the ProxyBrokerCriteria class to set specific criteria for selecting proxy servers, enabling more precise control over the proxy server selection process within the application.  
ClassDef ProxySettings

Chunk 2473
ClassDef ProxySettings  
ProxySettings: The function of ProxySettings is to define the structure of proxy settings including server, bypass, username, and password.  
attributes:
- server: Represents the proxy server address.

Chunk 2474
- bypass: Specifies the addresses that should be bypassed.
- username: Indicates the username for proxy authentication.
- password: Represents the password for proxy authentication.  
Note:

Chunk 2475
Note:
Developers can use the ProxySettings class to define and manage proxy settings within their applications. Ensure that the required attributes such as the server address are provided when working with instances of this class.  
ClassDef Proxy

Chunk 2476
ClassDef Proxy  
Proxy: The function of Proxy is to provide proxy server information.  
attributes:
- criteria: ProxyBrokerCriteria  
Code Description:

Chunk 2477
The Proxy class represents proxy server information and includes an attribute called criteria, which is an instance of the ProxyBrokerCriteria class. ProxyBrokerCriteria defines the criteria for selecting proxy servers based on attributes such as

Chunk 2478
based on attributes such as anonymity, country location, security, timeout, and search behavior. By utilizing ProxyBrokerCriteria within the Proxy class, developers can customize the selection of proxy servers based on specific requirements.

Chunk 2479
Note:

Chunk 2480
Developers can use the Proxy class to define and manage proxy server information within their applications. By setting criteria using ProxyBrokerCriteria, users can tailor the selection of proxy servers to meet their specific needs effectively.

Chunk 2481
FunctionDef search_proxy_servers(anonymous, countryset, secure, timeout, max_shape, search_outside_if_empty)

Chunk 2482
search_proxy_servers: The function of search_proxy_servers is to search for proxy servers that match specified criteria and return a list of URLs.  
parameters:
- anonymous: whether proxy servers should have minimum level-1 anonymity.

Chunk 2483
- countryset: admissible proxy servers locations.
- secure: whether proxy servers should support HTTP or HTTPS.
- timeout: The maximum timeout for proxy responses.
- max_shape: The maximum number of proxy servers to return.

Chunk 2484
- search_outside_if_empty: whether countryset should be extended if empty.  
Code Description:

Chunk 2485
The search_proxy_servers function searches for proxy servers based on the provided criteria such as anonymity level, country locations, security support, timeout, and maximum number of servers to return. It utilizes the FreeProxy class to create a

Chunk 2486
FreeProxy class to create a proxy broker with the specified criteria. The function then internally calls a nested function search_all to search for proxy servers, handle exceptions, and return a list of proxy server URLs that meet the criteria. If

Chunk 2487
that meet the criteria. If no suitable proxy servers are found, it raises a FreeProxyException.

Chunk 2488
The function _search_proxy in proxy_rotation.py calls search_proxy_servers to find a proxy server that matches the specified criteria and returns a 'playwright' compliant proxy configuration.

Chunk 2489
The test functions in test_proxy_rotation.py validate the functionality of search_proxy_servers by testing successful retrieval of proxy servers and handling of exceptions.  
Note:

Chunk 2490
Note:
Ensure the necessary criteria are provided to search for proxy servers effectively.  
Output Example:
[
"http://103.10.63.135:8080",
"http://113.20.31.250:8080",
]  
FunctionDef search_all(proxybroker, k, search_outside)

Chunk 2491
search_all: The function of search_all is to search for a specified number of working proxy servers using a given FreeProxy object.  
parameters:
- proxybroker: Represents the FreeProxy object used to retrieve the proxy list.

Chunk 2492
- k: An integer indicating the number of proxy servers to search for.
- search_outside: A boolean value to determine whether to search for proxy servers outside the current list.  
Code Description:

Chunk 2493
The function starts by obtaining a list of proxy candidates from the FreeProxy object and shuffling them randomly. It then iterates through the candidate list, checking each proxy server's validity by attempting a connection. If a working proxy

Chunk 2494
If a working proxy server is found, it is added to the set of positive servers. If the required number of positive servers is reached, the function returns the list of positive servers. If not enough servers are found and the search_outside flag is

Chunk 2495
the search_outside flag is set to True, the function recursively calls itself to search for additional servers. If no positive servers are found at the end of the process, an exception is raised.

Chunk 2496
Note:
- The function utilizes the FreeProxy object to manage and check proxy servers.
- It handles exceptions related to failed requests and missing proxy servers.  
Output Example:
['http://123.456.789.1', 'http://987.654.321.0', ...]

Chunk 2497
FunctionDef _parse_proxy(proxy)  
_parse_proxy: The function of _parse_proxy is to parse a proxy configuration with a known server and return a 'playwright' compliant proxy configuration.  
parameters:
- proxy: The proxy configuration to parse.

Chunk 2498
Code Description:

Chunk 2499
The _parse_proxy function takes a ProxySettings object as input, validates the presence of the "server" attribute in the proxy configuration, checks for the presence of both "username" and "password" attributes together, and constructs a new

Chunk 2500
and constructs a new dictionary with the parsed proxy information. If the proxy configuration includes a "bypass" attribute, it is also included in the parsed output. The function ensures that the "username" and "password" attributes are provided in

Chunk 2501
attributes are provided in pairs or not at all to maintain consistency in the proxy configuration. Finally, the function returns the parsed proxy configuration in a 'playwright' compliant format.

Chunk 2502
This function is called by the parse_or_search_proxy function to handle the parsing of proxy configurations based on specific criteria or server addresses.  
Note:

Chunk 2503
Note:
Developers using this function should ensure that the proxy configuration provided includes the necessary attributes and follows the expected format to avoid assertion errors.  
Output Example:
{
"server": "192.168.1.1:8080",

Chunk 2504
"server": "192.168.1.1:8080",
"username": "user",
"password": "pass",
"bypass": "*.local"
}  
FunctionDef _search_proxy(proxy)  
_search_proxy: The function of _search_proxy is to search for a proxy server matching the specified broker criteria.

Chunk 2505
parameters:
- proxy: The proxy configuration to search for.  
Code Description:

Chunk 2506
The _search_proxy function removes the "max_shape" parameter from the criteria, searches for proxy servers based on the modified criteria, and returns a 'playwright' compliant proxy configuration. It internally calls the search_proxy_servers

Chunk 2507
the search_proxy_servers function to find a suitable proxy server based on the provided criteria.

Chunk 2508
This function is utilized within the parse_or_search_proxy function to either parse an existing proxy configuration or search for a new one based on the specified criteria. By calling _search_proxy, developers can efficiently find a proxy server

Chunk 2509
find a proxy server that meets the desired criteria.

Chunk 2510
Note:
Developers should ensure that the necessary proxy configuration is provided in the proxy parameter to search for a suitable proxy server effectively.  
Output Example:
{
"server": ""
}  
FunctionDef is_ipv4_address(address)

Chunk 2511
is_ipv4_address: The function of is_ipv4_address is to check if a given address conforms to an IPv4 address.  
parameters:
- address: A string representing the address to be checked.  
Code Description:

Chunk 2512
The is_ipv4_address function attempts to create an IPv4Address object from the provided address. If successful, it returns True, indicating that the address is a valid IPv4 address. If an AddressValueError is raised during the creation of the

Chunk 2513
during the creation of the IPv4Address object, the function returns False.

Chunk 2514
This function is called within the parse_or_search_proxy function in the proxy_rotation.py file. In parse_or_search_proxy, is_ipv4_address is used to determine if the proxy server address provided in the proxy configuration is an IPv4 address. If

Chunk 2515
is an IPv4 address. If the address is an IPv4 address, the function proceeds to parse the proxy configuration. Otherwise, if the address is set to 'broker', the function searches for a proxy server based on the provided criteria.

Chunk 2516
Note:
- Ensure that the address parameter is a valid string representing an IP address.
- Handle exceptions if needed when using this function.  
Output Example:
- is_ipv4_address("192.168.1.1") => True

Chunk 2517
- is_ipv4_address("999.999.999.999") => False  
FunctionDef parse_or_search_proxy(proxy)

Chunk 2518
parse_or_search_proxy: The function of parse_or_search_proxy is to parse a proxy configuration or search for a new one matching the specified broker criteria.  
parameters:
- proxy: The proxy configuration to parse or search for.  
Code Description:

Chunk 2519
The parse_or_search_proxy function takes a Proxy object as input and is responsible for parsing the proxy configuration or searching for a new one based on the provided criteria. It begins by asserting the presence of the "server" attribute in the

Chunk 2520
the "server" attribute in the proxy configuration. If the server address is an IPv4 address, the function calls the _parse_proxy function to parse the proxy configuration. Otherwise, if the server address is set to 'broker', the function calls the

Chunk 2521
the function calls the _search_proxy function to search for a proxy server based on the provided criteria.

Chunk 2522
The function returns a 'playwright' compliant proxy configuration, which includes the server address that matches the criteria.

Chunk 2523
This function is called in various parts of the project, such as the ChromiumLoader class in chromium.py, where it is used to parse or search for a proxy configuration based on the provided criteria. It is also called in the test cases in

Chunk 2524
called in the test cases in test_proxy_rotation.py to verify the successful parsing or searching of proxy configurations.

Chunk 2525
Note:
Developers using this function should ensure that the necessary proxy configuration is provided in the proxy parameter to parse or search for a suitable proxy server effectively.  
Output Example:
If the proxy configuration is as follows:

Chunk 2526
python
proxy = {
"server": "broker",
"criteria": {
"anonymous": True,
"countryset": {"US"},
"secure": True,
"timeout": 10.0,
},
}
The expected output would be:
python
{
"server": "<proxy-server-address>"
}

Chunk 2527
FunctionDef search_on_web(query, search_engine, max_results)

Chunk 2528
search_on_web: The function of search_on_web is to search the web for a given query using specified search engine options and return a list of URLs as strings that are the search results.  
parameters:

Chunk 2529
parameters:
- query (str): The search query to find on the internet.
- search_engine (str, optional): Specifies the search engine to use, options include 'Google', 'DuckDuckGo', or 'Bing'. Default is 'Google'.

Chunk 2530
- max_results (int, optional): The maximum number of search results to return.  
Code Description:

Chunk 2531
The search_on_web function allows switching between Google, DuckDuckGo, and Bing to perform internet searches. It takes a query, search engine choice, and maximum number of results as input parameters. Depending on the search engine specified, it

Chunk 2532
search engine specified, it fetches search results from the respective search engines and returns a list of URLs as strings. If an invalid search engine is provided, a ValueError is raised.

Chunk 2533
In the calling object SearchInternetNode/execute, the search_on_web function is used to generate a search query based on the user's prompt. It queries the language model, fetches the search results, and updates the state with the generated answer.

Chunk 2534
Note:
- Ensure to provide a valid search engine option ('Google', 'DuckDuckGo', or 'Bing') when calling the function.
- The function may raise a ValueError if an invalid search engine is specified or if no results are found for the search query.

Chunk 2535
Output Example:
['http://example.com', 'http://example.org', ...]

Chunk 2536
FunctionDef save_audio_from_bytes(byte_response, output_path)  
save_audio_from_bytes: The function of save_audio_from_bytes is to save the byte response as an audio file to the specified path.  
parameters:

Chunk 2537
parameters:
- byte_response (bytes): The byte array containing audio data.
- output_path (Union[str, Path]): The destination file path where the audio file will be saved.  
Code Description:

Chunk 2538
The save_audio_from_bytes function takes a byte response containing audio data and an output path where the audio file will be saved. It first checks if the output path is an instance of Path, and if not, converts it to a Path object. Then, it

Chunk 2539
it to a Path object. Then, it writes the byte response to the specified output path as an audio file in binary mode.

Chunk 2540
This function is called in the SpeechGraph class within the run method. In this context, the function is used to save the audio generated from text to a specified output path. If no audio is generated, a ValueError is raised. The function ensures

Chunk 2541
raised. The function ensures that the audio is saved to the output path provided in the configuration settings.

Chunk 2542
Note:
- Ensure that the byte response contains valid audio data.
- The output path should be a valid file path where the audio file will be saved.

Chunk 2543
FunctionDef srcfile_import(modpath, modname)  
srcfile_import: The function of srcfile_import is to import a Python module from its source file.  
parameters:
- modpath: The absolute path of the source file.
- modname: The module name in the scope.

Chunk 2544
Code Description:

Chunk 2545
The srcfile_import function takes in the absolute path of a source file and the module name, then imports the module from the source file. It utilizes importlib.util to handle the import process. The function first creates a spec from the file

Chunk 2546
creates a spec from the file location, checks if the spec and loader are available, creates a module from the spec, adds the module to the global scope, and finally executes the module. If any issues occur during the import process, such as missing

Chunk 2547
process, such as missing spec or loader, the function raises an ImportError.

Chunk 2548
This function is called in the test cases of the project to test its functionality in different scenarios:

Chunk 2549
1. test_srcfile_import_success: Tests the successful import of a module from a source file and checks if the module and its function are accessible.

Chunk 2550
2. test_srcfile_import_missing_spec: Tests the case where the source file does not exist, expecting a FileNotFoundError to be raised.

Chunk 2551
3. test_srcfile_import_missing_spec_loader: Tests the scenario where the loader is missing for the module in the source file, ensuring that an ImportError is raised with the appropriate message.  
Note:

Chunk 2552
Note:
Developers using this function should ensure that the source file exists and contains the necessary module to be imported. Any issues with the import process will result in an ImportError being raised.  
Output Example:

Chunk 2553
Output Example:
The imported module from the source file.  
FunctionDef dynamic_import(modname, message)  
dynamic_import: The function of dynamic_import is to import a Python module at runtime.  
parameters:
- modname: The module name in the scope.

Chunk 2554
- message: The display message in case of an error.  
Code Description:

Chunk 2555
The dynamic_import function allows importing a Python module at runtime. If the specified module is not found in the sys.modules, it attempts to import the module using importlib. If an ImportError occurs during the import process, the function

Chunk 2556
import process, the function raises an ImportError with a custom message. This function helps in dynamically importing modules based on runtime conditions.

Chunk 2557
In the project, the dynamic_import function is utilized in the ChromiumLoader class within the ChromiumLoader/init method. It is used to dynamically import the specified backend library required for the ChromiumLoader. By dynamically importing the

Chunk 2558
By dynamically importing the backend library, the ChromiumLoader class can adapt to different backend configurations based on the user's choice. This enhances the flexibility and extensibility of the ChromiumLoader class by allowing the use of

Chunk 2559
class by allowing the use of different web driver backend libraries.

Chunk 2560
Note:

Chunk 2561
Developers can use dynamic_import to import modules dynamically at runtime, providing flexibility in module loading based on runtime conditions. It is essential to handle ImportError exceptions appropriately when using this function to manage import

Chunk 2562
function to manage import failures gracefully.

Chunk 2563
FunctionDef truncate_text_tokens(text, model, encoding_name)  
truncate_text_tokens: The function of truncate_text_tokens is to split a given text into chunks that are within the token limit of a specified language model.  
parameters:

Chunk 2564
parameters:
- text (str): The input text to be truncated.
- model (str): The name of the language model to determine the maximum token limit.
- encoding_name (str): The encoding strategy used to encode the text before truncation.  
Code Description:

Chunk 2565
The function first obtains the encoding strategy based on the provided encoding name. It then calculates the maximum number of tokens allowed for the specified model. The input text is encoded using the chosen strategy. Subsequently, the encoded

Chunk 2566
Subsequently, the encoded text is divided into chunks of size less than the calculated maximum tokens. Finally, the chunks are decoded back to text format, and a list of these text chunks is returned.

Chunk 2567
Note:
Ensure that the model name provided is accurate and matches the predefined models_tokens dictionary.
The encoding strategy specified must be supported by the token encoding module.  
Output Example:
["This is a sample text", "for truncation."]

Chunk 2568
FunctionDef sample_json  
sample_json: The function of sample_json is to read the sample JSON file.  
parameters: This Function does not take any parameters.

Chunk 2569
Code Description: The sample_json Function reads a sample JSON file located at "inputs/example.json" relative to the current file path. It opens the file, reads its content, and returns the text stored in the file.

Chunk 2570
In the project, the sample_json Function is called by the test_scraping_pipeline Function in the "test_scraping_pipeline" file. The test_scraping_pipeline Function tests the scraping pipeline by creating a JSONScraperGraph object with the

Chunk 2571
object with the sample_json as the data source. It then runs the scraping process and asserts the result against expected titles.

Chunk 2572
Note: Ensure that the "example.json" file exists in the "inputs" directory relative to the location of the sample_json file.  
Output Example:
json
{
"data": "Sample data",
"value": 123
}  
FunctionDef graph_config(request)

Chunk 2573
graph_config: The function of graph_config is to load graph configuration.
parameters:
- request: Represents the request parameter.

Chunk 2574
Code Description: The graph_config function is responsible for loading the graph configuration based on the provided request parameter. It simply returns the request parameter passed to it.

Chunk 2575
In the project, the graph_config function is utilized in the test_scraping_pipeline function located in the test_scraping_pipeline file under the graphs directory. In this context, the graph_config function is used to configure a JSONScraperGraph

Chunk 2576
configure a JSONScraperGraph object by providing the configuration obtained from the request parameter. This configuration is then used in the scraping pipeline test to validate the expected titles extracted from the sample JSON data.

Chunk 2577
Note: It's essential to ensure that the request parameter passed to the graph_config function contains the necessary configuration details for the JSONScraperGraph object to function correctly.  
Output Example:

Chunk 2578
Output Example:
If the request parameter contains the following configuration:
{
"key1": "value1",
"key2": "value2"
}  
The graph_config function will return:
{
"key1": "value1",
"key2": "value2"
}

Chunk 2579
"key2": "value2"
}  
FunctionDef test_scraping_pipeline(sample_json, graph_config)  
test_scraping_pipeline: The function of test_scraping_pipeline is to test the scraping pipeline.  
parameters:

Chunk 2580
parameters:
- sample_json: Represents the sample JSON data used in the scraping pipeline.
- graph_config: Contains the configuration parameters for the scraping pipeline.  
Code Description:

Chunk 2581
The test_scraping_pipeline function is designed to validate the functionality of the scraping pipeline by creating a JSONScraperGraph object. It takes in two parameters: sample_json, which is the sample JSON data to be scraped, and graph_config,

Chunk 2582
be scraped, and graph_config, which holds the configuration details for the scraping process.

Chunk 2583
Within the function, an expected list of titles is defined, and a JSONScraperGraph instance named smart_scraper_graph is created with the provided sample_json and graph_config. The run method is then called on the smart_scraper_graph object to

Chunk 2584
smart_scraper_graph object to execute the scraping pipeline.

Chunk 2585
The function includes assertions to verify the correctness of the scraping process. It checks if the result is not None, if it is a list, and if the sorted result matches the sorted expected_titles list.

Chunk 2586
The test_scraping_pipeline function ensures that the scraping pipeline operates as expected and extracts the titles accurately from the sample JSON data.

Chunk 2587
Note: Ensure that the sample_json and graph_config parameters are correctly provided to test the scraping pipeline functionality. The expected_titles list should be updated according to the expected output from the scraping process.

Chunk 2588
FunctionDef sample_text  
sample_text: The function of sample_text is to read and return the content of a text file.  
parameters: This Function does not take any parameters.

Chunk 2589
Code Description: The sample_text Function reads the content of a text file named "plain_html_example.txt" located in the "inputs" directory. It then returns the text content of the file. The file path is constructed dynamically based on the current

Chunk 2590
based on the current directory of the script.

Chunk 2591
In the calling script "test_scraping_pipeline", the sample_text Function is used to provide the source text for the SmartScraperGraph object. The text content is used as input for the scraping pipeline to extract relevant information based on the

Chunk 2592
information based on the provided configuration.

Chunk 2593
Note: Ensure that the "plain_html_example.txt" file exists in the specified directory to avoid any file not found errors.  
Output Example:
If the content of "plain_html_example.txt" is:
This is a sample text file for testing purposes.

Chunk 2594
The return value of the sample_text Function would be:
This is a sample text file for testing purposes.  
FunctionDef graph_config  
graph_config: The function of graph_config is to provide configuration settings for the graph fixture.

Chunk 2595
parameters: The parameters of this Function.
- No parameters are required for this function.

Chunk 2596
Code Description: The graph_config function returns a dictionary containing configuration settings for two models: "llm" and "embeddings". Each model has specific attributes such as the model name, temperature, format, and base URL.

Chunk 2597
When called by the test_scraping_pipeline function in the test_scraping_pipeline module, the graph_config function provides the necessary configuration for the SmartScraperGraph object to initialize and run the scraping pipeline successfully. The

Chunk 2598
pipeline successfully. The graph_config dictionary is passed as a parameter to the SmartScraperGraph object to configure the scraping process.

Chunk 2599
Note: Developers can modify the configuration settings in the graph_config function according to their specific requirements for the scraping pipeline.  
Output Example:
{
"llm": {
"model": "ollama/llama3",
"temperature": 0,
"format": "json",

Chunk 2600
"format": "json",
"base_url": "http://localhost:11434",
},
"embeddings": {
"model": "ollama/nomic-embed-text",
"temperature": 0,
"base_url": "http://localhost:11434",
}
}  
FunctionDef test_scraping_pipeline(sample_text, graph_config)

Chunk 2601
test_scraping_pipeline: The function of test_scraping_pipeline is to test the SmartScraperGraph scraping pipeline.  
parameters:
- sample_text: Represents the sample text used as a data source for the scraping pipeline.

Chunk 2602
- graph_config: Contains the configuration settings for the SmartScraperGraph object.  
Code Description:

Chunk 2603
The test_scraping_pipeline function initializes a SmartScraperGraph object with a specified prompt, sample text from the input file, and configuration settings. It then runs the scraping pipeline to extract relevant information based on the provided

Chunk 2604
based on the provided configuration. The function includes assertions to validate the structure of the result, ensuring it is a dictionary and contains the key "news".

Chunk 2605
The sample_text function is called to read the content of a text file, which serves as the source data for the SmartScraperGraph object. The graph_config function provides the necessary configuration settings for the SmartScraperGraph

Chunk 2606
for the SmartScraperGraph initialization, enabling the scraping pipeline to function correctly.

Chunk 2607
Note:
- Ensure that the input text file exists in the specified directory to avoid any file not found errors.

Chunk 2608
- Developers can customize the configuration settings in the graph_config function according to their specific requirements for the scraping pipeline.

Chunk 2609
FunctionDef sample_text  
sample_text: The function of sample_text is to read a text file and return its content as a string.  
parameters: This Function does not take any parameters.

Chunk 2610
Code Description: The sample_text function reads a text file named "plain_html_example.txt" located in the "inputs" directory. It then returns the content of the file as a string. The file path is constructed dynamically based on the current

Chunk 2611
based on the current directory of the script.

Chunk 2612
In the calling script "test_scraping_pipeline" in the "scrape_plain_text_mistral_test.py" module, the sample_text function is used to provide the source text for a SmartScraperGraph object. The content of the text file is used as input for the

Chunk 2613
file is used as input for the scraping pipeline to extract relevant information.

Chunk 2614
Note: Ensure that the "plain_html_example.txt" file exists in the specified location to avoid any file not found errors when calling the sample_text function.  
Output Example:
If the content of "plain_html_example.txt" is:

Chunk 2615
This is a sample text file for testing purposes.  
The output of the sample_text function will be:
"This is a sample text file for testing purposes."  
FunctionDef graph_config

Chunk 2616
FunctionDef graph_config  
graph_config: The function of graph_config is to provide configuration settings for the graph fixture.  
parameters:
- No parameters are required for this function.  
Code Description:

Chunk 2617
Code Description:
The graph_config function returns a dictionary containing configuration settings for two models: "llm" and "embeddings". Each model has specific attributes such as the model name, temperature, format, and base URL.

Chunk 2618
This function is called by the test_scraping_pipeline function in the test_scraping_pipeline.py file. In the test_scraping_pipeline function, the graph_config function is used to provide configuration settings for the SmartScraperGraph object.

Chunk 2619
Note:
- Ensure that the configuration settings provided by this function align with the requirements of the SmartScraperGraph object.

Chunk 2620
- Any changes to the configuration settings should be reflected in both the graph_config function and the usage in the test_scraping_pipeline function.  
Output Example:
{
"llm": {
"model": "ollama/mistral",
"temperature": 0,
"format": "json",

Chunk 2621
"format": "json",
"base_url": "http://localhost:11434"
},
"embeddings": {
"model": "ollama/nomic-embed-text",
"temperature": 0,
"base_url": "http://localhost:11434"
}
}  
FunctionDef test_scraping_pipeline(sample_text, graph_config)

Chunk 2622
test_scraping_pipeline: The function of test_scraping_pipeline is to test the SmartScraperGraph scraping pipeline.  
parameters:
- sample_text: The sample text used as a data source for the SmartScraperGraph.

Chunk 2623
- graph_config: The configuration settings for the SmartScraperGraph.  
Code Description:

Chunk 2624
The test_scraping_pipeline function initiates a SmartScraperGraph object with a specified prompt, sample text, and graph configuration. It then executes the scraping pipeline by calling the run method on the SmartScraperGraph object. The function

Chunk 2625
object. The function includes assertions to validate the result of the scraping process, ensuring that the result is a dictionary and contains a specific key ("news").

Chunk 2626
The sample_text function is utilized to provide the source text for the SmartScraperGraph object, while the graph_config function supplies the necessary configuration settings for the graph. These functions work together to set up the environment

Chunk 2627
to set up the environment for the scraping pipeline and ensure its proper execution.

Chunk 2628
Note:
- Ensure that the sample text file exists in the specified location to avoid file not found errors when running the test_scraping_pipeline function.

Chunk 2629
- Any modifications to the graph configuration should be reflected in the graph_config function to maintain consistency in the scraping pipeline setup.

Chunk 2630
FunctionDef sample_xml  
sample_xml: The function of sample_xml is to read and return the content of a specified XML file.  
parameters: This Function does not take any parameters.

Chunk 2631
Code Description: The sample_xml function reads the content of an XML file named "books.xml" located in the "inputs" directory relative to the current script's path. It then returns the text content of the file.

Chunk 2632
In the project, the sample_xml function is called by the test_scraping_pipeline function in the test_scraping_pipeline module. The test_scraping_pipeline function utilizes the sample_xml function to provide XML content for scraping purposes in a

Chunk 2633
for scraping purposes in a scraping pipeline.

Chunk 2634
Note: Ensure that the "books.xml" file exists in the "inputs" directory relative to the script's path for the sample_xml function to read the file successfully.  
Output Example:
"""  
Author Name
Book Title
Genre  
Another Author
Another Title

Chunk 2635
Another Author
Another Title
Another Genre  
"""  
FunctionDef graph_config  
graph_config: The function of graph_config is to provide configuration settings for the graph.  
parameters:
- No parameters are required for this function.

Chunk 2636
Code Description:
The graph_config function returns a dictionary containing configuration settings for two models: "llm" and "embeddings". Each model has specific attributes such as the model name, temperature, format, and base URL.

Chunk 2637
The "llm" model configuration includes:
- Model: "ollama/mistral"
- Temperature: 0
- Format: "json"
- Base URL: "http://localhost:11434"  
The "embeddings" model configuration includes:
- Model: "ollama/nomic-embed-text"
- Temperature: 0

Chunk 2638
- Temperature: 0
- Base URL: "http://localhost:11434"  
This function is used to provide the necessary configuration details for running a scraping pipeline.  
Note:

Chunk 2639
Note:
- The function does not take any parameters and returns a dictionary with specific model configurations.
- The configuration settings can be customized based on the requirements of the scraping pipeline.  
Output Example:
{
"llm": {

Chunk 2640
Output Example:
{
"llm": {
"model": "ollama/mistral",
"temperature": 0,
"format": "json",
"base_url": "http://localhost:11434",
},
"embeddings": {
"model": "ollama/nomic-embed-text",
"temperature": 0,
"base_url": "http://localhost:11434",
}
}

Chunk 2641
}
}  
FunctionDef test_scraping_pipeline(sample_xml, graph_config)

Chunk 2642
test_scraping_pipeline: The function of test_scraping_pipeline is to initiate the scraping pipeline process by creating an XMLScraperGraph instance with provided sample XML and graph configuration, then running the graph to extract information.

Chunk 2643
parameters:
- sample_xml (str): The sample XML content to be used in the scraping process.
- graph_config (dict): Configuration settings for the scraping graph.  
Code Description:

Chunk 2644
The test_scraping_pipeline function serves as the entry point for the scraping pipeline process. It creates an instance of the XMLScraperGraph class with a specified prompt, sample XML content, and graph configuration. The XMLScraperGraph instance

Chunk 2645
The XMLScraperGraph instance is then executed, and the result is asserted to ensure it is not None.

Chunk 2646
Within the function, the XMLScraperGraph instance is created with a prompt to list authors, titles, and genres of books, the provided sample XML content, and the graph configuration. The run method of the XMLScraperGraph is called to execute the

Chunk 2647
is called to execute the scraping process, and the result is stored.

Chunk 2648
The function asserts that the result is not None, indicating a successful extraction of information from the XML file based on the provided prompt and configuration.

Chunk 2649
The test_scraping_pipeline function relies on the sample_xml function to obtain the XML content and the graph_config function to provide the necessary configuration settings for the scraping graph.

Chunk 2650
Note: Ensure that the sample XML content and graph configuration are appropriately set before calling the test_scraping_pipeline function to run the scraping pipeline successfully.

Chunk 2651
FunctionDef graph_config  
graph_config: The function of graph_config is to provide configuration settings for different components of a graph.  
parameters:
- No parameters are passed to this function.  
Code Description:

Chunk 2652
The graph_config function returns a dictionary containing configuration settings for different components of a graph. It includes settings for "llm" and "embeddings" models, such as model name, temperature, format, base URL, and library.

Chunk 2653
base URL, and library. Additionally, it specifies the library used for the graph.

Chunk 2654
Note:
- Ensure that the configuration settings returned by graph_config are correctly formatted and contain all the necessary information for the graph components.

Chunk 2655
- Make sure to update the configuration settings in graph_config as needed to reflect any changes in the graph requirements.  
Output Example:
{
"llm": {
"model": "ollama/mistral",
"temperature": 0,
"format": "json",

Chunk 2656
"format": "json",
"base_url": "http://localhost:11434",
"library": "beautifulsoup"
},
"embeddings": {
"model": "ollama/nomic-embed-text",
"temperature": 0,
"base_url": "http://localhost:11434"
},
"library": "beautifulsoup"
}

Chunk 2657
}  
FunctionDef test_script_creator_graph(graph_config)  
test_script_creator_graph: The function of test_script_creator_graph is to test the ScriptCreatorGraph by creating a smart scraper graph with the provided graph configuration.  
parameters:

Chunk 2658
parameters:
- graph_config: A dictionary containing configuration settings for different components of the graph.  
Code Description:

Chunk 2659
The test_script_creator_graph function initializes a ScriptCreatorGraph instance with a specific prompt, source, and the graph configuration provided as input. The ScriptCreatorGraph is responsible for creating a smart scraper graph based on the

Chunk 2660
scraper graph based on the given configuration. Once the graph is created, the function executes the graph and checks if a result is produced. If no result is generated, an assertion error is raised to indicate a failure in executing the

Chunk 2661
a failure in executing the ScriptCreatorGraph.

Chunk 2662
The graph_config function is called to retrieve the configuration settings required for the ScriptCreatorGraph. These settings include information about the language model (llm), embeddings model, temperature, format, base URL, and library to be

Chunk 2663
base URL, and library to be used in the graph. The configuration settings ensure that the ScriptCreatorGraph is customized according to the specified parameters.

Chunk 2664
Overall, the test_script_creator_graph function serves as a validation mechanism to ensure that the ScriptCreatorGraph can successfully create and execute a smart scraper graph with the provided configuration.  
Note:

Chunk 2665
Note:
- It is essential to review and update the configuration settings in the graph_config function to match the requirements of the ScriptCreatorGraph.

Chunk 2666
- Any changes in the graph components or behavior should be reflected in the configuration settings to maintain the functionality of the ScriptCreatorGraph.

Chunk 2667
FunctionDef graph_config  
graph_config: The function of graph_config is to provide configuration settings for different models used in the scraping pipeline.  
parameters:
- No parameters are passed to this function.  
Code Description:

Chunk 2668
The graph_config function returns a dictionary containing configurations for two models: "llm" and "embeddings". For the "llm" model, it includes the model name, ernie_client_id, ernie_client_secret, and temperature settings. The "embeddings" model

Chunk 2669
The "embeddings" model configuration consists of the model name, temperature, and base_url.

Chunk 2670
The graph_config function is utilized in the test_scraping_pipeline function within the smart_scraper_ernie_test.py file. In the test_scraping_pipeline function, the SmartScraperGraph is initialized with specific prompt, source, and the

Chunk 2671
prompt, source, and the configuration obtained from the graph_config function. The scraping pipeline is then executed, and the result is asserted to ensure its existence.

Chunk 2672
Note:
It is essential to ensure that the configuration returned by the graph_config function aligns with the requirements of the scraping pipeline to achieve the desired results.  
Output Example:
{
"llm": {
"model": "ernie-bot-turbo",

Chunk 2673
"model": "ernie-bot-turbo",
"ernie_client_id": "",
"ernie_client_secret": "",
"temperature": 0.1
},
"embeddings": {
"model": "ollama/nomic-embed-text",
"temperature": 0,
"base_url": "http://localhost:11434",
}
}

Chunk 2674
}
}  
FunctionDef test_scraping_pipeline(graph_config)

Chunk 2675
test_scraping_pipeline: The function of test_scraping_pipeline is to initiate the scraping pipeline by setting up a SmartScraperGraph with specific configurations and running the pipeline to obtain results.  
parameters:

Chunk 2676
parameters:
- graph_config: A dictionary containing configuration settings for different models used in the scraping pipeline.  
Code Description:

Chunk 2677
The test_scraping_pipeline function initializes a SmartScraperGraph object with a predefined prompt, source URL, and the configuration obtained from the graph_config function. The SmartScraperGraph is then executed using the run method to start the

Chunk 2678
the run method to start the scraping process. Finally, the function asserts that the result is not None to ensure the pipeline execution was successful.

Chunk 2679
The graph_config function, which provides the configuration settings, is called within the test_scraping_pipeline function to retrieve the necessary configurations for the scraping pipeline. By utilizing the configuration settings, the

Chunk 2680
configuration settings, the test_scraping_pipeline function sets up the SmartScraperGraph with the required parameters to scrape data effectively.

Chunk 2681
Note:

Chunk 2682
It is crucial to ensure that the graph_config function returns the correct configuration settings for the models "llm" and "embeddings" to enable the test_scraping_pipeline function to run the scraping pipeline smoothly and obtain the desired

Chunk 2683
and obtain the desired results.

Chunk 2684
FunctionDef test_get_execution_info(graph_config)  
test_get_execution_info: The function of test_get_execution_info is to retrieve the execution information of a SmartScraperGraph object.  
parameters:

Chunk 2685
parameters:
- graph_config: A dictionary containing configuration settings for the SmartScraperGraph.  
Code Description:

Chunk 2686
The test_get_execution_info function initializes a SmartScraperGraph object with a specified prompt, data source, and configuration settings provided in the graph_config dictionary. It then executes the graph using the run method. After execution,

Chunk 2687
run method. After execution, the function retrieves the execution information using the get_execution_info method of the SmartScraperGraph object. Finally, it asserts that the retrieved execution information is not None, ensuring that the graph

Chunk 2688
None, ensuring that the graph execution was successful.

Chunk 2689
Note:
It is essential to ensure that the graph_config parameter is correctly formatted and contains the necessary configuration settings for the SmartScraperGraph object to execute successfully.

Chunk 2690
FunctionDef graph_config  
graph_config: The function of graph_config is to provide configuration settings for the graph.  
parameters:
- No parameters are passed to this function.  
Code Description:

Chunk 2691
The graph_config function returns a dictionary containing configuration settings for two models: "llm" and "embeddings". For the "llm" model, the configuration includes the model name, temperature, format, and base URL. Similarly, for the

Chunk 2692
base URL. Similarly, for the "embeddings" model, the configuration includes the model name, temperature, and base URL.

Chunk 2693
This function is called by the test_scraping_pipeline function in the smart_scraper_ollama_test.py file. In the test_scraping_pipeline function, the graph_config function is used to provide configuration settings for the SmartScraperGraph object,

Chunk 2694
the SmartScraperGraph object, which is then used to run a scraping pipeline.

Chunk 2695
Note:
- The graph_config function does not accept any parameters and returns a dictionary with specific keys and values for configuration settings.

Chunk 2696
- Ensure that the configuration settings provided by the graph_config function align with the requirements of the SmartScraperGraph object in the calling function.  
Output Example:
python
{
"llm": {
"model": "ollama/mistral",
"temperature": 0,

Chunk 2697
"temperature": 0,
"format": "json",
"base_url": "http://localhost:11434",
},
"embeddings": {
"model": "ollama/nomic-embed-text",
"temperature": 0,
"base_url": "http://localhost:11434",
}
}  
FunctionDef test_scraping_pipeline(graph_config)

Chunk 2698
test_scraping_pipeline: The function of test_scraping_pipeline is to initiate the scraping pipeline by setting up a SmartScraperGraph with a specified prompt, data source, and configuration settings, and then running the scraping process.

Chunk 2699
parameters:
- graph_config: A dictionary containing configuration settings for the scraping pipeline.  
Code Description:

Chunk 2700
The test_scraping_pipeline function begins by creating a SmartScraperGraph object with a prompt requesting news with descriptions and a specified data source URL. The configuration settings for the graph are provided by the graph_config dictionary

Chunk 2701
the graph_config dictionary passed as a parameter to the function. Once the SmartScraperGraph is set up, the scraping process is executed by calling the run method on the graph object. Finally, an assertion is made to ensure that the result of the

Chunk 2702
ensure that the result of the scraping process is not None, indicating a successful execution of the pipeline.

Chunk 2703
The test_scraping_pipeline function relies on the SmartScraperGraph class and the graph_config function to configure and execute the scraping pipeline effectively.  
Note:

Chunk 2704
Note:
- Ensure that the graph_config dictionary passed to the function aligns with the required configuration settings for the SmartScraperGraph object.

Chunk 2705
- The function asserts that the result of the scraping process is not None, serving as a basic validation check for the pipeline execution.  
FunctionDef test_get_execution_info(graph_config)

Chunk 2706
test_get_execution_info: The function of test_get_execution_info is to retrieve the execution information of a SmartScraperGraph object.  
parameters:
- graph_config: A dictionary containing configuration settings for the SmartScraperGraph.

Chunk 2707
Code Description:

Chunk 2708
The test_get_execution_info function initializes a SmartScraperGraph object with a specified prompt, data source, and configuration settings provided in the graph_config dictionary. It then executes the graph using the run method. After execution,

Chunk 2709
run method. After execution, the function retrieves the execution information using the get_execution_info method of the SmartScraperGraph object. Finally, it asserts that the retrieved execution information is not None, ensuring that the graph

Chunk 2710
None, ensuring that the graph execution was successful.

Chunk 2711
Note:

Chunk 2712
It is essential to ensure that the graph_config parameter is correctly formatted to provide the necessary configuration settings for the SmartScraperGraph object. Additionally, the assert statement at the end of the function validates the execution

Chunk 2713
validates the execution information, helping to verify the functionality of the SmartScraperGraph object.

Chunk 2714
FunctionDef graph_config  
graph_config: The function of graph_config is to provide configuration settings for a graph.  
parameters:
- No parameters are passed to this function explicitly.  
Code Description:

Chunk 2715
The graph_config function retrieves the OpenAI API key from the environment variables and returns a dictionary containing configuration settings for the graph. The configuration includes the API key, the model to be used (set to "gpt-3.5-turbo" by

Chunk 2716
(set to "gpt-3.5-turbo" by default), verbosity setting (True), and headless mode setting (False).

Chunk 2717
In the calling object test_scraping_pipeline, the graph_config function is passed as a parameter to the SmartScraperGraph constructor to provide configuration settings for the scraping process. The SmartScraperGraph instance is then used to run the

Chunk 2718
is then used to run the scraping pipeline, ensuring that the configuration from graph_config is utilized during the scraping operation.

Chunk 2719
Note:

Chunk 2720
Developers using this function should ensure that the OPENAI_APIKEY environment variable is properly set to allow the function to retrieve the API key. Additionally, they can modify the default model, verbosity, and headless settings in the returned

Chunk 2721
settings in the returned dictionary based on their specific requirements.

Chunk 2722
Output Example:
{
"llm": {
"api_key": "XXXXXXXXXXXXXXXXXXXXXXXXX",
"model": "gpt-3.5-turbo"
},
"verbose": True,
"headless": False
}  
FunctionDef test_scraping_pipeline(graph_config)

Chunk 2723
test_scraping_pipeline: The function of test_scraping_pipeline is to initiate the scraping pipeline.  
parameters:
- graph_config: A function that provides configuration settings for the scraping graph.  
Code Description:

Chunk 2724
The test_scraping_pipeline function initializes a SmartScraperGraph instance by passing a prompt, data source, and configuration settings obtained from the graph_config function. The SmartScraperGraph instance then executes the scraping process, and

Chunk 2725
the scraping process, and the result is validated to ensure it is a dictionary.

Chunk 2726
The graph_config function retrieves the OpenAI API key from the environment variables and constructs a dictionary containing configuration settings such as the API key, model type, verbosity, and headless mode. This configuration is crucial for

Chunk 2727
configuration is crucial for customizing the behavior of the scraping process.

Chunk 2728
By utilizing the graph_config function within the test_scraping_pipeline, developers can easily manage and adjust the configuration settings for the scraping pipeline according to their requirements. The assert statements validate the output of the

Chunk 2729
validate the output of the scraping process, ensuring that the result is a dictionary and not None.

Chunk 2730
Note:

Chunk 2731
Developers should ensure that the OPENAI_APIKEY environment variable is correctly set to enable the graph_config function to retrieve the API key. Additionally, they can modify the default configuration settings provided by the graph_config function

Chunk 2732
by the graph_config function to tailor the scraping process based on their specific needs.

Chunk 2733
FunctionDef test_get_execution_info(graph_config)  
test_get_execution_info: The function of test_get_execution_info is to retrieve the execution information of a SmartScraperGraph object.  
parameters:

Chunk 2734
parameters:
- graph_config: A configuration object containing settings for the SmartScraperGraph.  
Code Description:

Chunk 2735
The test_get_execution_info function initializes a SmartScraperGraph object with a specific prompt, data source, and configuration. It then executes the graph using the run method. After execution, it retrieves the execution information using the

Chunk 2736
information using the get_execution_info method of the SmartScraperGraph object. Finally, it asserts that the retrieved execution information is not None.

Chunk 2737
Note:
- Ensure that the graph_config parameter is properly configured before calling this function.
- This function is designed for testing the retrieval of execution information from a SmartScraperGraph object.

Chunk 2738
FunctionDef test_fetch_html(mocker)  
test_fetch_html: The function of test_fetch_html is to simulate fetching HTML content from a specified URL and testing the extraction of relevant information such as title, links, and images.  
parameters:

Chunk 2739
parameters:
- mocker: A mocker object used for mocking classes and functions.  
Code Description:

Chunk 2740
The test_fetch_html function creates a mock loader class to simulate fetching HTML content. It then sets up a mock loader to return a Document object containing the specified HTML content. The function initializes a FetchNode object with input,

Chunk 2741
FetchNode object with input, output, and node configuration parameters. It executes the FetchNode to fetch HTML content from a specified URL and checks if the expected content is present in the fetched document.

Chunk 2742
The test_fetch_html function is essential for testing the functionality of the FetchNode class in fetching and processing HTML content from different sources.

Chunk 2743
Note: The test_fetch_html function relies on the mocker object to mock the ChromiumLoader class for fetching HTML content. It also asserts the presence of specific content in the fetched document to ensure the correct operation of the FetchNode.

Chunk 2744
Output Example:
{
"doc": [
{

Chunk 2745
"page_content": "Title: ScrapeGraph AI, Body: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec euismod, nunc et feugiat ultricies, metus nisl consectetur eros, in luctus diam elit id nunc. Links:

Chunk 2746
diam elit id nunc. Links: [https://github.com/VinciGit00/Scrapegraph-ai], Images: [https://raw.githubusercontent.com/VinciGit00/Scrapegraph-ai/main/docs/assets/scrapegraphai_logo.png]"

Chunk 2747
}
],
"links": ["https://github.com/VinciGit00/Scrapegraph-ai"],
"images": ["https://raw.githubusercontent.com/VinciGit00/Scrapegraph-ai/main/docs/assets/scrapegraphai_logo.png"]
}  
FunctionDef test_fetch_json

Chunk 2748
FunctionDef test_fetch_json  
test_fetch_json: The function of test_fetch_json is to fetch JSON data, process it, and update the state with the processed content.  
parameters:
- No parameters are passed explicitly to the test_fetch_json function.

Chunk 2749
Code Description:

Chunk 2750
The test_fetch_json function initializes a FetchNode object with input as "json" and output as a list containing "doc". It then executes the node by passing a dictionary with a key "json" pointing to a JSON file path. The function asserts that the

Chunk 2751
The function asserts that the result is not None after executing the node. The FetchNode class is responsible for fetching HTML content from a specified URL or JSON file, processing the content, and updating the state with the processed information.

Chunk 2752
the processed information. It handles different types of input data such as JSON, XML, CSV, and PDF, and performs operations accordingly to fetch and process the HTML content. The processed content is then stored in the state with appropriate output

Chunk 2753
state with appropriate output keys like "doc", "links", and "images".

Chunk 2754
The test_fetch_json function demonstrates the usage of the FetchNode class to fetch JSON data and process it, showcasing how nodes can be utilized in a scraping workflow to extract and manipulate data from various sources.  
Note:

Chunk 2755
Note:
- Ensure that the JSON file path provided in the test data dictionary is correct to avoid any file loading issues.

Chunk 2756
- The assert statement checks if the result is not None, indicating a successful execution of the FetchNode and updating of the state with processed content.  
FunctionDef test_fetch_xml

Chunk 2757
FunctionDef test_fetch_xml  
test_fetch_xml: The function of test_fetch_xml is to fetch XML content from a specified URL, process it, and update the state with the extracted information.  
Parameters:
- None  
Code Description:

Chunk 2758
The test_fetch_xml function initializes a FetchNode object with input as "xml" and output as a list containing "doc". It then executes the node by fetching XML content from the specified URL provided in the state. The fetched content is processed to

Chunk 2759
content is processed to extract relevant information such as title, body, links, and images. Finally, the function asserts that the result is not None, ensuring that the content was successfully fetched and processed.

Chunk 2760
This function demonstrates the usage of the FetchNode class to handle XML content fetching and processing within a scraping workflow. It showcases how the FetchNode interacts with the state of the graph to update it with the extracted information.

Chunk 2761
Note:

Chunk 2762
Developers can utilize this function as a reference for fetching and processing XML content using the FetchNode class in their scraping workflows. The assert statement ensures that the fetched content is valid and not empty, providing a basic

Chunk 2763
not empty, providing a basic validation mechanism for the functionality of the FetchNode in handling XML data.

Chunk 2764
FunctionDef test_fetch_csv  
test_fetch_csv: The function of test_fetch_csv is to fetch a CSV file, execute the FetchNode to process the content, and assert that the result is not None.  
Parameters:
- None  
Code Description:

Chunk 2765
The test_fetch_csv function creates an instance of the FetchNode class with input as "csv" and output as ["doc"]. It then executes the node by providing a dictionary with the CSV file path under the key "csv". The function asserts that the result of

Chunk 2766
asserts that the result of the execution is not None, ensuring that the FetchNode processes the CSV file correctly and updates the state with the fetched content.

Chunk 2767
The FetchNode class is responsible for fetching HTML content from a specified URL or file and updating the state with the processed content. It handles different types of input data such as JSON, XML, CSV, and PDF, extracting relevant information

Chunk 2768
relevant information like title, body, links, and images. The class relies on other components like ChromiumLoader, cleanup_html, PyPDFLoader, and Document to perform its operations effectively.

Chunk 2769
When test_fetch_csv is called, it tests the functionality of the FetchNode specifically for CSV input, validating that the node can fetch and process CSV data correctly within the scraping workflow.  
Note:

Chunk 2770
Developers can use test_fetch_csv to verify the correct behavior of the FetchNode when dealing with CSV files. It serves as a test case to ensure that the node processes CSV input as expected and updates the state accurately with the extracted

Chunk 2771
accurately with the extracted content.

Chunk 2772
FunctionDef test_fetch_txt  
test_fetch_txt: The function of test_fetch_txt is to fetch HTML content from a specified URL and update the state with this content.  
parameters:
- No parameters are passed explicitly to the test_fetch_txt function.

Chunk 2773
Code Description:

Chunk 2774
The test_fetch_txt function creates an instance of the FetchNode class, which is responsible for fetching HTML content from a specified URL. It defines the input as "txt" and the output as a list containing "doc", "links", and "images". The function

Chunk 2775
and "images". The function then reads a sample text file, executes the FetchNode instance with the text content, and asserts that the result is not None. This test ensures that the FetchNode can successfully fetch and process HTML content.

Chunk 2776
The FetchNode class, which the test_fetch_txt function utilizes, is a crucial component in scraping workflows. It fetches HTML content, processes it to extract relevant information such as title, body, links, and images, and updates the state with

Chunk 2777
and updates the state with this processed content. The class handles various input types (e.g., JSON, XML, CSV, PDF) and utilizes different methods to fetch and process HTML content based on the input type. Additionally, the FetchNode class relies

Chunk 2778
the FetchNode class relies on other classes and functions like ChromiumLoader, cleanup_html, PyPDFLoader, and Document to perform its operations effectively.

Chunk 2779
Note:

Chunk 2780
Developers can use the test_fetch_txt function to verify that the FetchNode class can successfully fetch HTML content and update the state with the processed information. This test ensures the proper functioning of the FetchNode in scraping

Chunk 2781
of the FetchNode in scraping workflows.

Chunk 2782
FunctionDef mock_llm_model  
FunctionDef robots_node(mock_llm_model)  
robots_node: The function of robots_node is to create a RobotsNode object for checking if a website is scrapeable based on the robots.txt file.  
parameters:

Chunk 2783
parameters:
- mock_llm_model: A mock model used for testing purposes.  
Code Description:

Chunk 2784
The robots_node function initializes a RobotsNode object with specific configurations. It takes a mock_llm_model as a parameter to set up the language model for checking scrapeability. The function defines the input keys as "url" and the output keys

Chunk 2785
as "url" and the output keys as ["is_scrapable"]. Additionally, it configures the node with a mock language model and sets the headless mode to False.

Chunk 2786
In the project, the robots_node function is utilized in the test_robots_node_scrapable test case to simulate the behavior of the RobotsNode class. The test case sets up a state with a URL, mocks the AsyncChromiumLoader to return fake robots.txt

Chunk 2787
to return fake robots.txt content, executes the robots_node function, and asserts the expected output state with the scrapeability status.

Chunk 2788
Note:
The robots_node function is crucial for creating a RobotsNode instance with predefined configurations for checking website scrapeability based on the robots.txt file.  
Output Example:
{
"is_scrapable": "yes"
}

Chunk 2789
{
"is_scrapable": "yes"
}  
FunctionDef test_robots_node_scrapable(robots_node)  
test_robots_node_scrapable: The function of test_robots_node_scrapable is to test the scrapeability of a website based on the robots.txt file content.  
parameters:

Chunk 2790
parameters:
- robots_node: Represents the RobotsNode object used for checking website scrapeability.  
Code Description:

Chunk 2791
The test_robots_node_scrapable function sets up a state with a specific URL, mocks the AsyncChromiumLoader to simulate the return of fake robots.txt content. It then executes the robots_node function with the provided state and checks the output

Chunk 2792
state and checks the output state to verify the scrapeability status of the website.

Chunk 2793
The function interacts with the robots_node object, which is responsible for creating a RobotsNode instance with predefined configurations for checking website scrapeability based on the robots.txt file content.  
Note:

Chunk 2794
Note:
This function plays a crucial role in verifying the functionality of the RobotsNode class in determining the scrapeability of a website based on the robots.txt file.  
Output Example:
{
"is_scrapable": "yes"
}

Chunk 2795
{
"is_scrapable": "yes"
}  
FunctionDef test_robots_node_not_scrapable(robots_node)  
test_robots_node_not_scrapable: The function of test_robots_node_not_scrapable is to test the behavior of a robots node when it is not scrapable.  
parameters:

Chunk 2796
parameters:
- robots_node: The robots node object to be tested.  
Code Description:

Chunk 2797
The test_robots_node_not_scrapable function sets up a state with a specific URL, mocks the behavior of AsyncChromiumLoader to return fake robots.txt content, sets the LLM response to "no", and then executes the robots node. The test expects a

Chunk 2798
node. The test expects a ValueError to be raised because force_scraping is set to False by default.

Chunk 2799
Note:
- This function is used to verify the handling of a non-scrapable robots node.
- It utilizes mocking techniques to simulate specific behaviors for testing purposes.  
Output Example:

Chunk 2800
Output Example:
A ValueError is raised during the execution of the robots node due to the default setting of force_scraping being False.  
FunctionDef test_robots_node_force_scrapable(robots_node)

Chunk 2801
test_robots_node_force_scrapable: The function of test_robots_node_force_scrapable is to test the behavior of a robots node when force scraping is set to True.  
parameters:
- robots_node: The robots node object being tested.  
Code Description:

Chunk 2802
The test function initializes a state dictionary with a specific URL. It then mocks the behavior of the AsyncChromiumLoader to return a fake robots.txt content. The LLM response is also mocked to return "no". The force_scraping attribute of the

Chunk 2803
attribute of the robots node is set to True. The function then executes the node with the given state. Finally, it checks whether the state has been updated correctly and asserts the expected results.

Chunk 2804
Note:
- This function is specifically designed for testing the behavior of a robots node under certain conditions.
- It utilizes mocking to simulate the behavior of external dependencies and control the test environment.  
Output Example:

Chunk 2805
Output Example:
result_state = {"is_scrapable": "no"}
result = ("is_scrapable", "no")

Chunk 2806
ClassDef TestSearchInternetNode  
TestSearchInternetNode: The function of TestSearchInternetNode is to test the functionality of the SearchInternetNode class for executing search queries on the internet.  
attributes:

Chunk 2807
attributes:
- graph_config: A dictionary containing configuration settings for the graph.
- llm_model: An instance of the Ollama class initialized with the llm configuration.

Chunk 2808
- search_node: An instance of the SearchInternetNode class with specific input, output, and node configuration settings.  
Code Description:

Chunk 2809
The TestSearchInternetNode class is a unit test class that inherits from unittest.TestCase. It is designed to test the execution of the SearchInternetNode class, which performs internet searches based on the provided input and configuration

Chunk 2810
input and configuration settings. In the setUp method, the graph configuration is defined, the llm_model is initialized, and the search_node is instantiated with the necessary parameters. The test_execute_search_node method sets the initial state

Chunk 2811
method sets the initial state and expected output, executes the search_node, and asserts that the result matches the expected output.

Chunk 2812
Note:
- This class is specifically created for testing the functionality of the SearchInternetNode class and should not be used for other purposes.

Chunk 2813
- It is important to ensure that the expected output in the test_execute_search_node method is updated if the search results change to maintain accurate testing.  
FunctionDef setUp(self)

Chunk 2814
FunctionDef setUp(self)  
setUp: The function of setUp is to configure the graph, define the model, and initialize the SearchInternetNode with specific parameters.  
Parameters:
- self: The instance of the class.  
Code Description:

Chunk 2815
The setUp function configures the graph by setting parameters such as the language model, search engine, maximum results, and verbosity. It then defines the Ollama model using the provided configuration parameters. Next, it initializes the

Chunk 2816
Next, it initializes the SearchInternetNode with input, output, and node configuration parameters, including the language model, search engine, maximum results, and verbosity settings.

Chunk 2817
The setUp function plays a crucial role in setting up the necessary components for the test environment related to searching the internet within the graph.  
Note:

Chunk 2818
Note:
- Ensure that the graph configuration parameters are correctly set to achieve the desired behavior.
- The setUp function is essential for preparing the environment before running tests related to internet searching functionality.

Chunk 2819
FunctionDef test_execute_search_node(self)  
test_execute_search_node: The function of test_execute_search_node is to test the execution of a search node by comparing the actual output with the expected output.  
parameters:

Chunk 2820
parameters:
- self: Represents the instance of the class.  
Code Description:

Chunk 2821
The test_execute_search_node function initializes a state dictionary with a user_input key set to a specific question. It then creates an expected_output dictionary with the user_input key and a list of search_results containing URLs related to the

Chunk 2822
URLs related to the input question. The function executes the search node with the given state and compares the result with the expected_output using the assertEqual method to ensure the correctness of the search results.

Chunk 2823
Note:
- This function is part of a unit test and is used to verify the functionality of a search node in a larger system.
- It is essential to update the expected_output dictionary if the search results change to maintain the accuracy of the test.

Chunk 2824
FunctionDef setup  
setup: The function of setup is to initialize the SearchLinkNode and set up the initial state for testing.  
parameters:
- No parameters are passed explicitly to the setup function.  
Code Description:

Chunk 2825
Code Description:
The setup function performs the following tasks:
1. Defines the configuration for the graph, including the model name, temperature, and streaming settings.
2. Instantiates the Ollama model with the provided configuration.

Chunk 2826
3. Defines the SearchLinkNode with necessary configurations, such as input, output, and node settings.
4. Defines the initial state for the node, including user prompt and parsed content chunks.

Chunk 2827
The setup function returns the initialized SearchLinkNode and the initial state for testing purposes.

Chunk 2828
This function is crucial for preparing the necessary components before testing the functionality of the SearchLinkNode in a controlled environment.

Chunk 2829
Note: It is essential to ensure that the necessary configurations and initial state are correctly set up before executing the SearchLinkNode for testing or further usage.  
Output Example:
python
{
"relevant_links": [
"https://example.com/link1",

Chunk 2830
"https://example.com/link1",
"https://example.com/link2",
"https://example.com/link3"
]
}  
FunctionDef test_search_link_node(setup)  
test_search_link_node: The function of test_search_link_node is to test the execution of the SearchLinkNode.

Chunk 2831
parameters:
- setup: Represents the setup function that initializes the SearchLinkNode and sets up the initial state for testing.  
Code Description:

Chunk 2832
The test_search_link_node function tests the SearchLinkNode's execution by setting up the necessary components and mocking responses. It initializes the SearchLinkNode and the initial state using the setup function. The function then patches the

Chunk 2833
The function then patches the execute method to prevent actual network calls and returns a mock response containing relevant links. It asserts that the result is not None, checks for the presence of "relevant_links" in the result, verifies the type

Chunk 2834
the result, verifies the type and length of the relevant links, and ensures that the execute method is called once with the initial state.

Chunk 2835
This function is essential for verifying the functionality of the SearchLinkNode in a controlled testing environment, ensuring that it filters out relevant links correctly based on the user prompt and parsed content chunks.

Chunk 2836
Note: It is crucial to have the setup function correctly implemented to provide the necessary configurations and initial state for testing the SearchLinkNode.  
Output Example:
{
"relevant_links": [
"http://example.com"
]
}

Chunk 2837
FunctionDef test_google_search  
test_google_search: The function of test_google_search is to test the search_on_web function with the Google search engine.  
parameters:
- None  
Code Description:

Chunk 2838
The test_google_search function is a unit test that validates the functionality of the search_on_web function specifically with the Google search engine. It initiates a search with a test query and specifies the maximum number of results to be 2.

Chunk 2839
number of results to be 2. The test asserts that the number of results returned by the search_on_web function is equal to 2.

Chunk 2840
In the context of the project, this test ensures that the search_on_web function behaves as expected when using Google as the search engine and retrieving a limited number of search results.  
Note:

Chunk 2841
Note:
- This test function does not accept any parameters as inputs since it is a standalone unit test designed to verify the behavior of the search_on_web function with Google search.  
FunctionDef test_bing_search

Chunk 2842
test_bing_search: The function of test_bing_search is to test the search_on_web function with the Bing search engine.  
parameters:
- None  
Code Description:

Chunk 2843
The test_bing_search function is designed to validate the functionality of the search_on_web function specifically with the Bing search engine. It initiates a search with a test query using Bing as the search engine and requests a single result. The

Chunk 2844
requests a single result. The function then asserts that the search results are not None, ensuring that the search_on_web function successfully retrieves search results from Bing.

Chunk 2845
In the context of the project, this test function serves as a quality assurance measure to confirm that the search_on_web function can interact correctly with the Bing search engine and return valid search results.  
Note:

Chunk 2846
Note:
- This test function does not require any parameters as it is a self-contained validation of the search_on_web function with Bing.

Chunk 2847
- It is essential to run this test to verify the proper functioning of the search_on_web function with the Bing search engine.  
FunctionDef test_invalid_search_engine

Chunk 2848
test_invalid_search_engine: The function of test_invalid_search_engine is to test the search_on_web function with an invalid search engine.  
parameters:
- None  
Code Description:

Chunk 2849
The test_invalid_search_engine function is a test case that verifies the behavior of the search_on_web function when an invalid search engine is provided as input. It uses the pytest library to assert that a ValueError is raised when search_on_web

Chunk 2850
is raised when search_on_web is called with an unsupported search engine option. This test ensures that the search_on_web function correctly handles invalid search engine inputs by expecting a specific exception to be raised.

Chunk 2851
The search_on_web function, which is called within the test, allows searching the web for a given query using specified search engine options such as Google, DuckDuckGo, or Bing. If an unsupported search engine like "Yahoo" is provided, the function

Chunk 2852
is provided, the function should raise a ValueError as defined in its implementation.

Chunk 2853
Note:
- Ensure to provide valid search engine options ('Google', 'DuckDuckGo', or 'Bing') when using the search_on_web function.

Chunk 2854
- The test_invalid_search_engine function serves the purpose of validating the error handling mechanism of the search_on_web function for unsupported search engines.  
FunctionDef test_max_results

Chunk 2855
test_max_results: The function of test_max_results is to test the search_on_web function with different max_results values.  
parameters:
- None  
Code Description:

Chunk 2856
The test_max_results function is used to verify the behavior of the search_on_web function by calling it with different max_results values. It first calls search_on_web with a max_results value of 5 and then with a max_results value of 10 for the

Chunk 2857
value of 10 for the same search query. The function then asserts that the number of search results obtained with max_results=5 is less than or equal to the number of results obtained with max_results=10.

Chunk 2858
The purpose of this test is to ensure that the search_on_web function behaves as expected when returning search results with different maximum result limits. By comparing the number of results obtained with different max_results values, this test

Chunk 2859
max_results values, this test helps validate the functionality and consistency of the search_on_web function.

Chunk 2860
Note:
- This test function does not take any parameters and is solely focused on testing the behavior of the search_on_web function with varying max_results values.

Chunk 2861
FunctionDef test_search_proxy_servers_success

Chunk 2862
test_search_proxy_servers_success: The function of test_search_proxy_servers_success is to validate the successful retrieval of proxy servers that match specified criteria and ensure that the returned servers are of type string.  
parameters:

Chunk 2863
parameters:
- No external parameters are passed to this function.  
Code Description:

Chunk 2864
The test_search_proxy_servers_success function calls the search_proxy_servers function with specific criteria such as minimum anonymity level, country location, security support, timeout, and maximum number of servers to return. It then asserts that

Chunk 2865
return. It then asserts that the returned servers are of type list and each server URL is of type string. This test function ensures that the search_proxy_servers function operates correctly and returns the expected data format.

Chunk 2866
The search_proxy_servers function, located in proxy_rotation.py, is responsible for searching and returning proxy servers based on the provided criteria. It utilizes the FreeProxy class to create a proxy broker and internally calls a nested function

Chunk 2867
calls a nested function to handle the search process. The test function test_search_proxy_servers_success validates the functionality of search_proxy_servers by checking the type of returned servers.

Chunk 2868
Note:

Chunk 2869
Developers should ensure that the search_proxy_servers function returns a list of string URLs for proxy servers that match the specified criteria. This test function is crucial for verifying the correct behavior of the proxy server search

Chunk 2870
of the proxy server search functionality.

Chunk 2871
FunctionDef test_search_proxy_servers_exception  
test_search_proxy_servers_exception: The function of test_search_proxy_servers_exception is to test the handling of exceptions when searching for proxy servers that match specified criteria.

Chunk 2872
parameters:
- No parameters are passed explicitly to the test function.

Chunk 2873
The search_proxy_servers function itself searches for proxy servers based on various criteria such as anonymity level, country locations, security support, timeout, and the maximum number of servers to return. It utilizes the FreeProxy class to

Chunk 2874
the FreeProxy class to create a proxy broker with the specified criteria. The function then internally calls a nested function search_all to search for proxy servers, handle exceptions, and return a list of proxy server URLs that meet the criteria.

Chunk 2875
URLs that meet the criteria. If no suitable proxy servers are found, it raises a FreeProxyException.

Chunk 2876
In the context of the project, the test_search_proxy_servers_exception function is part of the testing suite for the search_proxy_servers function in the proxy_rotation.py module. This test function ensures that the exception handling mechanism in

Chunk 2877
handling mechanism in search_proxy_servers works correctly when no matching proxy servers are found.

Chunk 2878
Note:
Ensure that the search_proxy_servers function is properly handling exceptions when no suitable proxy servers are found based on the specified criteria.  
FunctionDef test_parse_proxy_success

Chunk 2879
test_parse_proxy_success: The function of test_parse_proxy_success is to test the parsing of a proxy configuration and ensure that the parsed proxy matches the original configuration.  
parameters:

Chunk 2880
parameters:
- No parameters are passed explicitly to this test function.  
Code Description:

Chunk 2881
The test_parse_proxy_success function creates a sample proxy configuration with server, username, password, and bypass attributes. It then calls the _parse_proxy function to parse this configuration and assigns the result to parsed_proxy. The

Chunk 2882
result to parsed_proxy. The function asserts that the parsed_proxy is equal to the original proxy configuration, ensuring that the parsing function works correctly and maintains the integrity of the proxy settings.

Chunk 2883
The _parse_proxy function is responsible for parsing proxy configurations by validating the presence of required attributes such as "server" and ensuring that "username" and "password" are provided together or not at all. It constructs a new

Chunk 2884
at all. It constructs a new dictionary with the parsed proxy information and returns it in a 'playwright' compliant format. This test function verifies the functionality of the parsing process by comparing the parsed output with the original proxy

Chunk 2885
with the original proxy configuration.

Chunk 2886
Note:

Chunk 2887
Developers should use this test function to verify that the _parse_proxy function correctly handles the parsing of proxy configurations. Any discrepancies between the parsed output and the original configuration would indicate issues in the parsing

Chunk 2888
issues in the parsing logic.

Chunk 2889
FunctionDef test_parse_proxy_exception  
test_parse_proxy_exception: The function of test_parse_proxy_exception is to test the parsing of a proxy configuration with invalid attributes and verify that the appropriate assertion error is raised.

Chunk 2890
parameters:
- No parameters.  
Code Description:

Chunk 2891
The test_parse_proxy_exception function creates an invalid proxy configuration with missing required attributes ("username" and "password" not provided in pairs) and tests the _parse_proxy function with this invalid configuration using

Chunk 2892
invalid configuration using pytest.raises. It checks that an AssertionError is raised with the expected error message indicating the missing attributes in the proxy configuration.

Chunk 2893
The _parse_proxy function is responsible for parsing a proxy configuration, ensuring the presence of the "server" attribute, validating the "username" and "password" attributes, and constructing a new dictionary with the parsed proxy information.

Chunk 2894
the parsed proxy information. This test function validates the error handling mechanism of _parse_proxy when encountering an invalid proxy configuration.

Chunk 2895
Note:
Developers should use this test case to verify the correct behavior of the _parse_proxy function when handling invalid proxy configurations.  
FunctionDef test_search_proxy_success

Chunk 2896
test_search_proxy_success: The function of test_search_proxy_success is to search for a proxy server based on specific criteria and assert the presence of certain attributes in the found proxy.  
parameters:
- None  
Code Description:

Chunk 2897
The test_search_proxy_success function creates a Proxy object with criteria set to anonymous=True and countryset={"US"}. It then calls the _search_proxy function to find a proxy server based on the provided criteria. The function asserts that the

Chunk 2898
The function asserts that the found proxy is a dictionary and checks if the "server" attribute is present in the found proxy.

Chunk 2899
Note:
Developers can use this test function to verify the functionality of the _search_proxy function in searching for a suitable proxy server based on the specified criteria.  
FunctionDef test_is_ipv4_address

Chunk 2900
test_is_ipv4_address: The function of test_is_ipv4_address is to check if a given address conforms to an IPv4 address.  
parameters:
- address: A string representing the address to be checked.  
Code Description:

Chunk 2901
The test_is_ipv4_address function validates whether a given address is a valid IPv4 address. It asserts the correctness of the is_ipv4_address function by passing different types of addresses and checking the expected outcomes. The function verifies

Chunk 2902
The function verifies if the is_ipv4_address function correctly identifies valid and invalid IPv4 addresses.

Chunk 2903
The is_ipv4_address function is defined in the proxy_rotation.py file and is utilized for validating IPv4 addresses within the context of proxy server configurations. It ensures that the addresses provided in the proxy configuration are in the

Chunk 2904
configuration are in the correct format before further processing. By testing the is_ipv4_address function, the test_is_ipv4_address function contributes to the overall quality assurance of the proxy rotation functionality in the project.

Chunk 2905
Note:
- Ensure that the address parameter is a valid string representing an IP address.
- Handle exceptions if needed when using this function.  
FunctionDef test_parse_or_search_proxy_success

Chunk 2906
test_parse_or_search_proxy_success: The function of test_parse_or_search_proxy_success is to test the successful parsing or searching of proxy configurations.  
parameters:
- No parameters.  
Code Description:

Chunk 2907
The test_parse_or_search_proxy_success function tests the functionality of the parse_or_search_proxy function by creating two different proxy configurations. It first creates a proxy configuration with a server address and asserts that the parsed

Chunk 2908
and asserts that the parsed proxy matches the original configuration. Then, it creates a proxy broker configuration with specific criteria and asserts that the returned proxy contains the "server" attribute.

Chunk 2909
This test function ensures that the parse_or_search_proxy function correctly handles parsing existing proxy configurations and searching for new ones based on specified criteria. It validates the integrity of the proxy parsing and searching logic

Chunk 2910
parsing and searching logic within the codebase.

Chunk 2911
Note:
Developers should run this test function to verify that the parse_or_search_proxy function behaves as expected when parsing or searching for proxy configurations.  
FunctionDef test_parse_or_search_proxy_exception

Chunk 2912
test_parse_or_search_proxy_exception: The function of test_parse_or_search_proxy_exception is to test the exception handling when parsing or searching for a proxy configuration.  
parameters:
- No parameters.  
Code Description:

Chunk 2913
The test_parse_or_search_proxy_exception function initializes a proxy configuration with a username and password. It then uses the pytest.raises context manager to capture an AssertionError raised by the parse_or_search_proxy function when it is

Chunk 2914
function when it is called with the provided proxy configuration. The function asserts that the error message contains the specific text "missing server in the proxy configuration".

Chunk 2915
This test function is crucial for ensuring that the parse_or_search_proxy function correctly handles scenarios where the required "server" attribute is missing from the proxy configuration. By using pytest.raises, the function validates that the

Chunk 2916
function validates that the appropriate exception is raised under the expected conditions.

Chunk 2917
Note:

Chunk 2918
Developers should run this test case to verify that the parse_or_search_proxy function raises an AssertionError with the correct error message when the "server" attribute is missing from the proxy configuration. This helps in maintaining the

Chunk 2919
This helps in maintaining the robustness and reliability of the proxy parsing and searching functionality in the project.

Chunk 2920
FunctionDef test_parse_or_search_proxy_unknown_server

Chunk 2921
test_parse_or_search_proxy_unknown_server: The function of test_parse_or_search_proxy_unknown_server is to test the behavior of the parse_or_search_proxy function when the proxy server is set to 'unknown'.  
parameters:
- No parameters.

Chunk 2922
- No parameters.  
Code Description:

Chunk 2923
The test_parse_or_search_proxy_unknown_server function initializes a proxy configuration with a server set to 'unknown'. It then uses pytest to assert that calling the parse_or_search_proxy function with this proxy configuration raises an

Chunk 2924
proxy configuration raises an AssertionError. The function further verifies that the error message contains the phrase "unknown proxy server".

Chunk 2925
The parse_or_search_proxy function is responsible for parsing a proxy configuration or searching for a new one based on specified criteria. It checks for the presence of the "server" attribute in the proxy configuration. If the server address is an

Chunk 2926
If the server address is an IPv4 address, the function parses the proxy configuration. If the server address is set to 'broker', the function searches for a proxy server based on the provided criteria.

Chunk 2927
In the project, this test function ensures that the parse_or_search_proxy function correctly handles the scenario where the proxy server is unknown. It helps maintain the functionality and reliability of the parse_or_search_proxy function by

Chunk 2928
function by validating its behavior under different conditions.

Chunk 2929
Note:

Chunk 2930
Developers should use this test function to confirm that the parse_or_search_proxy function raises an AssertionError with the appropriate error message when the proxy server is unknown. This ensures the robustness of the proxy parsing and searching

Chunk 2931
proxy parsing and searching functionality in the project.

Chunk 2932
FunctionDef _create_sample_file(filepath, content)  
_create_sample_file: The function of _create_sample_file is to create a sample file at a specified path with the provided content.
parameters:

Chunk 2933
parameters:
- filepath: A string representing the path where the sample file will be created.
- content: A string containing the content that will be written to the sample file.  
Code Description:

Chunk 2934
The _create_sample_file function takes in two parameters: filepath and content. It opens the specified filepath in write mode with UTF-8 encoding and writes the provided content to the file. This function is useful for creating sample files with

Chunk 2935
creating sample files with custom content dynamically.

Chunk 2936
In the project, this function is called by test cases such as test_srcfile_import_success and test_srcfile_import_missing_spec_loader. In test_srcfile_import_success, _create_sample_file is used to create a sample Python file with a specific

Chunk 2937
Python file with a specific function definition. This file is then imported dynamically using srcfile_import for testing purposes. On the other hand, in test_srcfile_import_missing_spec_loader, _create_sample_file is utilized to create an empty

Chunk 2938
utilized to create an empty sample file, triggering an ImportError scenario to test the handling of missing spec loader in the srcfile_import function.

Chunk 2939
Note:
- Ensure that the filepath provided is valid and accessible for writing the sample file.
- Make sure to handle any potential exceptions related to file operations when using this function.  
FunctionDef _delete_sample_file(filepath)

Chunk 2940
_delete_sample_file: The function of _delete_sample_file is to delete a sample file at a specified path.
parameters:
- filepath: A string representing the path of the file to be deleted.
Code Description:

Chunk 2941
The _delete_sample_file function checks if the file exists at the provided filepath. If the file exists, it is removed using the os.remove() function. This function is crucial for cleaning up sample files after they have been used for testing

Chunk 2942
have been used for testing purposes.

Chunk 2943
This function is called in the following scenarios in the project:
1. In the test_srcfile_import_success function, _delete_sample_file is used to delete a sample file created for testing the successful import of a source file.

Chunk 2944
2. In the test_srcfile_import_missing_spec_loader function, _delete_sample_file is utilized to delete a sample file created for testing the scenario where a spec loader is missing during source file import.

Chunk 2945
Note: Ensure that the filepath provided to this function is valid and points to the correct file that needs to be deleted.  
FunctionDef test_srcfile_import_success

Chunk 2946
test_srcfile_import_success: The function of test_srcfile_import_success is to test the successful import of a module from a source file and validate the accessibility of the imported module and its function.  
parameters:
- None  
Code Description:

Chunk 2947
The test_srcfile_import_success function begins by setting the module path and name. It then creates a sample file with a specific function definition using the _create_sample_file function. The srcfile_import function is called to import the module

Chunk 2948
called to import the module from the source file. Subsequently, the function asserts the presence of the "foo" function in the imported module, checks if calling the "foo" function returns "bar", and verifies if the module name is in the

Chunk 2949
if the module name is in the sys.modules. Finally, the sample file is deleted using the _delete_sample_file function.

Chunk 2950
This function is an essential part of the testing suite for the srcfile_import function. It ensures that the import process works correctly, and the imported module can be accessed and utilized as expected.  
Note:

Chunk 2951
Note:
Developers should ensure that the sample file created for testing purposes contains the necessary module and functions. Any issues with the import process or module accessibility will cause the assertions to fail.  
Output Example:

Chunk 2952
Output Example:
The imported module from the source file.  
FunctionDef test_srcfile_import_missing_spec

Chunk 2953
test_srcfile_import_missing_spec: The function of test_srcfile_import_missing_spec is to test the scenario where the source file does not exist, expecting a FileNotFoundError to be raised.
parameters:

Chunk 2954
parameters:
- No parameters are passed explicitly in the function.  
Code Description:

Chunk 2955
The test_srcfile_import_missing_spec function tests the behavior of the srcfile_import function when the specified source file does not exist. It sets the modpath variable to a non-existent file path and the modname variable to a corresponding

Chunk 2956
variable to a corresponding module name. The function then uses the pytest.raises context manager to check if a FileNotFoundError is raised when attempting to import the module using the srcfile_import function. This test case ensures that the

Chunk 2957
test case ensures that the srcfile_import function correctly handles the situation where the source file is missing, raising the appropriate exception.

Chunk 2958
The srcfile_import function, which is called within this test case, is responsible for importing a Python module from its source file. It utilizes importlib.util to handle the import process. The function first creates a spec from the file location,

Chunk 2959
spec from the file location, checks if the spec and loader are available, creates a module from the spec, adds the module to the global scope, and finally executes the module. If any issues occur during the import process, such as missing spec or

Chunk 2960
such as missing spec or loader, the function raises an ImportError.

Chunk 2961
Note:

Chunk 2962
Developers using the srcfile_import function should ensure that the specified source file exists and contains the necessary module to be imported. In the case of a missing source file, the function will raise a FileNotFoundError, indicating that the

Chunk 2963
indicating that the file could not be found. This test case serves to validate the expected behavior of the srcfile_import function in handling missing files.

Chunk 2964
FunctionDef test_srcfile_import_missing_spec_loader(mocker)

Chunk 2965
test_srcfile_import_missing_spec_loader: The function of test_srcfile_import_missing_spec_loader is to test the scenario where the loader is missing for the module in the source file, ensuring that an ImportError is raised with the appropriate

Chunk 2966
raised with the appropriate message.

Chunk 2967
parameters:
- mocker: A mocker object used for mocking in the test.  
Code Description:

Chunk 2968
The test_srcfile_import_missing_spec_loader function utilizes the mocker object to simulate a scenario where the loader is missing for a module in the source file. It creates a sample file with no content, mocks the spec_from_file_location function

Chunk 2969
function to return a spec with a None loader, and then attempts to import the module using srcfile_import. The function expects an ImportError to be raised with the message "missing spec loader for module at" during the import process. This test

Chunk 2970
the import process. This test ensures that the srcfile_import function handles the case of a missing loader correctly.

Chunk 2971
This function is part of the test suite for the srcfile_import function in the project. It complements other test cases such as test_srcfile_import_success and test_srcfile_import_missing_spec, covering different import scenarios to validate the

Chunk 2972
scenarios to validate the functionality and error handling of srcfile_import.

Chunk 2973
Note:

Chunk 2974
Developers running this test should ensure that the mocker object is properly configured to mock the required functions and behaviors for the test case. Additionally, the creation and deletion of sample files should be handled appropriately to set

Chunk 2975
handled appropriately to set up and clean up the test environment effectively.

Chunk 2976
Output Example:
An ImportError with the message "missing spec loader for module at" is expected to be raised during the execution of the test_srcfile_import_missing_spec_loader function.  
FunctionDef test_dynamic_import_success

Chunk 2977
test_dynamic_import_success: The function of test_dynamic_import_success is to test the dynamic import functionality by importing a Python module at runtime and asserting the successful import.  
parameters:

Chunk 2978
parameters:
- No parameters are passed to this function.  
Code Description:

Chunk 2979
The test_dynamic_import_success function first prints the current modules in sys.modules. It then defines a module name "playwright" and asserts that this module is not present in sys.modules. The function then calls the dynamic_import function to

Chunk 2980
dynamic_import function to dynamically import the "playwright" module. After the import, it asserts that "playwright" is now in sys.modules. Finally, it imports the "playwright" module to suppress the F401 flake8 warning.

Chunk 2981
The dynamic_import function is crucial for dynamically importing modules at runtime. It handles the import process by checking if the specified module is already in sys.modules. If not found, it attempts to import the module using importlib and adds

Chunk 2982
using importlib and adds it to sys.modules. If an ImportError occurs during the import, the function raises a custom ImportError with the provided message.

Chunk 2983
In the project, the test_dynamic_import_success function is used to verify the successful dynamic import of the "playwright" module. This test ensures that the dynamic import mechanism works as expected, allowing modules to be imported at runtime

Chunk 2984
to be imported at runtime based on specific conditions.

Chunk 2985
Note:

Chunk 2986
Developers can utilize test_dynamic_import_success as a test case to validate the dynamic import functionality in their code. It is essential to handle any ImportError exceptions that may arise during the dynamic import process to ensure smooth

Chunk 2987
process to ensure smooth execution of the code.

Chunk 2988
FunctionDef test_dynamic_import_module_already_imported  
test_dynamic_import_module_already_imported: The function of test_dynamic_import_module_already_imported is to test the dynamic import of a module that has already been imported.

Chunk 2989
parameters:
- modname: The name of the module to be imported.  
Code Description:

Chunk 2990
The test_dynamic_import_module_already_imported function first imports the "json" module. It then checks if the "json" module is present in the sys.modules. After that, it calls the dynamic_import function with the modname "json" to import the

Chunk 2991
modname "json" to import the module dynamically. Finally, it asserts that the "json" module is still present in the sys.modules after dynamic import.

Chunk 2992
The dynamic_import function is used to import a Python module at runtime. It checks if the specified module is already in sys.modules and imports the module using importlib if not found. If an ImportError occurs during the import, it raises an

Chunk 2993
the import, it raises an ImportError with a custom message. This function enables dynamic module loading based on runtime conditions.

Chunk 2994
In the project, the dynamic_import function is utilized to dynamically import backend libraries in the ChromiumLoader class, enhancing flexibility by allowing different backend configurations based on user preferences.  
Note:

Chunk 2995
Note:
Developers can leverage dynamic_import for runtime module loading, ensuring flexibility in module imports based on runtime conditions. Proper exception handling is crucial when using this function to manage import errors effectively.

Chunk 2996
FunctionDef test_dynamic_import_import_error_with_custom_message

Chunk 2997
test_dynamic_import_import_error_with_custom_message: The function of test_dynamic_import_import_error_with_custom_message is to test the dynamic_import function by checking if an ImportError is raised with a custom message when attempting to import

Chunk 2998
when attempting to import a non-existent module.

Chunk 2999
parameters:
- No explicit parameters are passed to this test function.  
Code Description:

Chunk 3000
The test_dynamic_import_import_error_with_custom_message function validates the behavior of the dynamic_import function when trying to import a module that does not exist. It sets the module name to "nonexistent2" and a custom error message to

Chunk 3001
and a custom error message to "could not import module". The test uses pytest to assert that an ImportError is raised with the specified message when dynamic_import is called with the non-existent module name. Additionally, it verifies that the

Chunk 3002
it verifies that the non-existent module is not added to sys.modules after the import attempt.

Chunk 3003
This test ensures that the dynamic_import function correctly handles ImportError situations with custom error messages, providing a robust mechanism for importing modules dynamically at runtime.  
Note:

Chunk 3004
Developers can refer to this test case to understand how to test scenarios where dynamic_import is expected to raise an ImportError with a custom message. It demonstrates the importance of handling import errors gracefully when dynamically importing

Chunk 3005
when dynamically importing modules in Python.

